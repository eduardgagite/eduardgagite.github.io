{"content":"\nREST с JSON — привычный выбор для API. Но когда сервисы общаются между собой (микросервисная архитектура), часто нужно что-то быстрее и строже. **gRPC** — это фреймворк удалённого вызова процедур от Google. Вместо \"отправь JSON на endpoint\" вы вызываете метод на удалённом сервере так, будто он локальный.\n\nПочему Go-разработчики часто выбирают gRPC:\n- Бинарный протокол (**Protocol Buffers**) вместо текстового JSON — компактнее и быстрее.\n- Строгая типизация — контракт описан в **.proto**-файле, клиент и сервер генерируются автоматически.\n- Двунаправленные стримы — сервер и клиент могут обмениваться данными в реальном времени.\n- Встроенная кодогенерация для Go, Python, Java и других языков.\n\n## Protocol Buffers — формат данных\n\nПрежде чем писать gRPC-сервис, нужно описать данные и методы в **.proto**-файле.\n\n```\nsyntax = \"proto3\";\n\npackage user;\n\noption go_package = \"github.com/myapp/proto/user\";\n\nmessage GetUserRequest {\n  int64 id = 1;\n}\n\nmessage User {\n  int64 id = 1;\n  string name = 2;\n  string email = 3;\n}\n\nservice UserService {\n  rpc GetUser(GetUserRequest) returns (User);\n  rpc ListUsers(ListUsersRequest) returns (stream User);\n}\n\nmessage ListUsersRequest {\n  int32 limit = 1;\n}\n```\n\nКаждое поле имеет номер (**= 1**, **= 2**). Эти номера — идентификаторы полей в бинарном формате. Менять их после публикации нельзя (сломается обратная совместимость), а добавлять новые — можно.\n\n## Кодогенерация\n\nИз **.proto**-файла генерируются Go-структуры и интерфейс сервиса.\n\n```\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n\nprotoc --go_out=. --go-grpc_out=. proto/user.proto\n```\n\nКоманда создаст два файла:\n- **user.pb.go** — структуры **GetUserRequest**, **User**, **ListUsersRequest**.\n- **user_grpc.pb.go** — интерфейс **UserServiceServer** (для сервера) и клиент **UserServiceClient**.\n\n## Реализация сервера\n\nСгенерированный интерфейс нужно реализовать.\n\n```\ntype userServer struct {\n    user.UnimplementedUserServiceServer\n}\n\nfunc (s *userServer) GetUser(ctx context.Context, req *user.GetUserRequest) (*user.User, error) {\n    if req.Id <= 0 {\n        return nil, status.Errorf(codes.InvalidArgument, \"невалидный ID: %d\", req.Id)\n    }\n\n    return &user.User{\n        Id:    req.Id,\n        Name:  \"Alice\",\n        Email: \"alice@example.com\",\n    }, nil\n}\n\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":50051\")\n    if err != nil {\n        log.Fatalf(\"не удалось слушать: %v\", err)\n    }\n\n    grpcServer := grpc.NewServer()\n    user.RegisterUserServiceServer(grpcServer, &userServer{})\n\n    log.Println(\"gRPC-сервер слушает :50051\")\n    if err := grpcServer.Serve(lis); err != nil {\n        log.Fatalf(\"ошибка сервера: %v\", err)\n    }\n}\n```\n\nВстраивание **UnimplementedUserServiceServer** — обязательный паттерн. Он гарантирует, что при добавлении новых методов в **.proto** сервер скомпилируется (новые методы вернут ошибку \"not implemented\"), а не сломается.\n\n## Реализация клиента\n\n```\nfunc main() {\n    conn, err := grpc.Dial(\"localhost:50051\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        log.Fatalf(\"не удалось подключиться: %v\", err)\n    }\n    defer conn.Close()\n\n    client := user.NewUserServiceClient(conn)\n\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n\n    resp, err := client.GetUser(ctx, &user.GetUserRequest{Id: 42})\n    if err != nil {\n        log.Fatalf(\"ошибка вызова: %v\", err)\n    }\n\n    fmt.Printf(\"Пользователь: %s (%s)\\n\", resp.Name, resp.Email)\n}\n```\n\nВызов **client.GetUser** выглядит как вызов обычного метода, но под капотом данные сериализуются в Protocol Buffers, летят по сети через HTTP/2 и десериализуются на другой стороне.\n\n## Обработка ошибок\n\ngRPC использует свою систему кодов ошибок (аналог HTTP-статусов, но для RPC).\n\n```\nimport (\n    \"google.golang.org/grpc/codes\"\n    \"google.golang.org/grpc/status\"\n)\n\nfunc (s *userServer) GetUser(ctx context.Context, req *user.GetUserRequest) (*user.User, error) {\n    u, err := s.db.FindUser(req.Id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, status.Errorf(codes.NotFound, \"пользователь %d не найден\", req.Id)\n        }\n        return nil, status.Errorf(codes.Internal, \"ошибка базы данных: %v\", err)\n    }\n    return u, nil\n}\n```\n\nОсновные коды: **NotFound**, **InvalidArgument**, **Internal**, **Unauthenticated**, **PermissionDenied**, **DeadlineExceeded**. На стороне клиента код ошибки можно извлечь:\n\n```\nresp, err := client.GetUser(ctx, req)\nif err != nil {\n    st, ok := status.FromError(err)\n    if ok && st.Code() == codes.NotFound {\n        fmt.Println(\"Пользователь не найден\")\n    }\n}\n```\n\n## Стриминг\n\ngRPC поддерживает три вида стримов помимо обычного unary-вызова.\n\n### Server streaming — сервер отдаёт поток данных\n\n```\nfunc (s *userServer) ListUsers(req *user.ListUsersRequest, stream user.UserService_ListUsersServer) error {\n    users := fetchUsersFromDB(req.Limit)\n    for _, u := range users {\n        if err := stream.Send(u); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\nКлиент читает данные по мере поступления:\n\n```\nstream, err := client.ListUsers(ctx, &user.ListUsersRequest{Limit: 100})\nif err != nil {\n    log.Fatal(err)\n}\n\nfor {\n    u, err := stream.Recv()\n    if err == io.EOF {\n        break\n    }\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Получен: %s\\n\", u.Name)\n}\n```\n\nСтриминг полезен, когда данных много и нет смысла загружать всё в память целиком.\n\n## Когда выбрать gRPC, а когда REST\n\n**gRPC** — для общения сервисов между собой (backend-to-backend), когда важна скорость и строгий контракт.\n\n**REST + JSON** — для публичных API, браузерных клиентов, когда нужна простота отладки (JSON читается человеком).\n\nМногие проекты используют оба подхода: gRPC внутри кластера, REST/JSON наружу для фронтенда и мобильных приложений.\n\n## Итог\n\ngRPC — протокол удалённого вызова процедур с бинарной сериализацией (Protocol Buffers), кодогенерацией и стримингом. В Go он поддерживается на уровне стандарта де-факто. **Для межсервисного общения gRPC быстрее и надёжнее REST, но для публичных API классический HTTP + JSON по-прежнему проще и универсальнее.**\n"}