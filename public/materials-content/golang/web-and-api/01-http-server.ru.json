{"content":"\nGo прославился как язык для веб-серверов. И не зря: стандартная библиотека **net/http** настолько мощная, что многие проекты обходятся без фреймворков.\n\nВ Java вам нужен Spring Boot, в Python — Flask или Django, в Node.js — Express. В Go вы можете поднять полноценный HTTP-сервер за 10 строк кода.\n\n## Минимальный сервер\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintln(w, \"Hello, World!\")\n    })\n\n    fmt.Println(\"Сервер запущен на http://localhost:8080\")\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\nОткройте браузер по адресу **http://localhost:8080/hello** — и увидите ответ.\n\n## Обработчик (Handler)\n\nКаждый обработчик получает два аргумента:\n- **w http.ResponseWriter** — сюда мы **пишем** ответ (тело, заголовки, статус).\n- **r \\*http.Request** — отсюда мы **читаем** входящий запрос (URL, тело, заголовки, метод).\n\n### Возврат JSON\n\n```\nfunc usersHandler(w http.ResponseWriter, r *http.Request) {\n    users := []map[string]string{\n        {\"name\": \"Alice\", \"email\": \"alice@mail.com\"},\n        {\"name\": \"Bob\", \"email\": \"bob@mail.com\"},\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    json.NewEncoder(w).Encode(users)\n}\n```\n\n### Чтение тела запроса (POST)\n\n```\ntype CreateUserRequest struct {\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nfunc createUserHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodPost {\n        http.Error(w, \"Метод не поддерживается\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    var req CreateUserRequest\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, \"Невалидный JSON\", http.StatusBadRequest)\n        return\n    }\n\n    fmt.Fprintf(w, \"Создан пользователь: %s\", req.Name)\n}\n```\n\n### Чтение URL-параметров\n\n```\nfunc userHandler(w http.ResponseWriter, r *http.Request) {\n    id := r.PathValue(\"id\")\n    fmt.Fprintf(w, \"Запрошен пользователь с ID: %s\", id)\n}\n\nhttp.HandleFunc(\"GET /users/{id}\", userHandler)\n```\n\n## Структура типичного API\n\n```\nfunc main() {\n    mux := http.NewServeMux()\n\n    mux.HandleFunc(\"GET /health\", healthHandler)\n    mux.HandleFunc(\"GET /users\", listUsersHandler)\n    mux.HandleFunc(\"GET /users/{id}\", getUserHandler)\n    mux.HandleFunc(\"POST /users\", createUserHandler)\n\n    fmt.Println(\"API запущен на :8080\")\n    http.ListenAndServe(\":8080\", mux)\n}\n```\n\n## Graceful Shutdown (Корректное завершение)\n\nВ продакшене нельзя просто убить сервер — нужно дождаться завершения текущих запросов.\n\n```\nfunc main() {\n    srv := &http.Server{Addr: \":8080\"}\n\n    go func() {\n        if err := srv.ListenAndServe(); err != http.ErrServerClosed {\n            log.Fatal(err)\n        }\n    }()\n\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, os.Interrupt)\n    <-quit\n\n    fmt.Println(\"Завершаю работу...\")\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n    srv.Shutdown(ctx)\n}\n```\n\n## Итог\n\n1. **net/http** достаточно для большинства задач. Фреймворк необязателен.\n2. **http.HandleFunc** регистрирует обработчик для пути.\n3. **w** — пишем ответ, **r** — читаем запрос.\n4. Для продакшена используйте Graceful Shutdown.\n"}