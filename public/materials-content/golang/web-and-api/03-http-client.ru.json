{"content":"\nСерверы не живут в изоляции. Они ходят в другие сервисы: платежные системы, сторонние API, микросервисы внутри компании. Для этого нужен HTTP-клиент.\n\nВ Go он встроен в стандартную библиотеку — пакет **net/http**.\n\n## Простой GET-запрос\n\n```\nresp, err := http.Get(\"https://api.example.com/users\")\nif err != nil {\n    fmt.Println(\"Ошибка запроса:\", err)\n    return\n}\ndefer resp.Body.Close()\n\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\n    fmt.Println(\"Ошибка чтения:\", err)\n    return\n}\n\nfmt.Println(\"Статус:\", resp.StatusCode)\nfmt.Println(\"Тело:\", string(body))\n```\n\n**Важно**: Всегда вызывайте **defer resp.Body.Close()**. Если забудете, соединение не вернется в пул и произойдет утечка ресурсов.\n\n## POST-запрос с JSON\n\n```\ntype CreateOrderRequest struct {\n    ProductID int `json:\"product_id\"`\n    Quantity  int `json:\"quantity\"`\n}\n\nfunc createOrder() error {\n    order := CreateOrderRequest{ProductID: 42, Quantity: 3}\n\n    jsonData, err := json.Marshal(order)\n    if err != nil {\n        return err\n    }\n\n    resp, err := http.Post(\n        \"https://api.example.com/orders\",\n        \"application/json\",\n        bytes.NewBuffer(jsonData),\n    )\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusCreated {\n        return fmt.Errorf(\"неожиданный статус: %d\", resp.StatusCode)\n    }\n\n    return nil\n}\n```\n\n## Настройка клиента\n\n**http.Get** и **http.Post** используют глобальный клиент по умолчанию. Проблема: у него **нет таймаута**. Если сервер зависнет, ваша программа будет ждать вечно.\n\nСоздавайте **свой клиент** с настройками.\n\n```\nclient := &http.Client{\n    Timeout: 10 * time.Second,\n}\n\nresp, err := client.Get(\"https://api.example.com/data\")\n```\n\n### Запрос с заголовками\n\nДля полного контроля используйте **http.NewRequest**.\n\n```\nreq, err := http.NewRequest(\"GET\", \"https://api.example.com/users\", nil)\nif err != nil {\n    return err\n}\n\nreq.Header.Set(\"Authorization\", \"Bearer my-token-123\")\nreq.Header.Set(\"Accept\", \"application/json\")\n\nclient := &http.Client{Timeout: 10 * time.Second}\nresp, err := client.Do(req)\n```\n\n### Запрос с контекстом (отмена и таймаут)\n\n```\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\nreq, _ := http.NewRequestWithContext(ctx, \"GET\", \"https://api.example.com/slow\", nil)\n\nresp, err := http.DefaultClient.Do(req)\nif err != nil {\n    fmt.Println(\"Запрос не успел:\", err)\n    return\n}\ndefer resp.Body.Close()\n```\n\n## Повторные запросы (Retry)\n\nСеть ненадежна. Запросы могут падать из-за временных проблем (перегрузка, таймаут, сетевой сбой). Простая стратегия повторов:\n\n```\nfunc doWithRetry(client *http.Client, req *http.Request, maxRetries int) (*http.Response, error) {\n    var resp *http.Response\n    var err error\n\n    for i := 0; i <= maxRetries; i++ {\n        resp, err = client.Do(req)\n        if err == nil && resp.StatusCode < 500 {\n            return resp, nil\n        }\n\n        if resp != nil {\n            resp.Body.Close()\n        }\n\n        wait := time.Duration(i+1) * time.Second\n        fmt.Printf(\"Попытка %d не удалась, жду %v...\\n\", i+1, wait)\n        time.Sleep(wait)\n    }\n\n    return resp, fmt.Errorf(\"все %d попыток провалились: %w\", maxRetries, err)\n}\n```\n\n## Итог\n\n1. Всегда вызывайте **defer resp.Body.Close()**.\n2. **Всегда задавайте таймаут** (**http.Client{Timeout: 10 \\* time.Second}**).\n3. Используйте **http.NewRequest**, когда нужны заголовки или контекст.\n4. Для ненадежных внешних API реализуйте повторные попытки с задержкой.\n"}