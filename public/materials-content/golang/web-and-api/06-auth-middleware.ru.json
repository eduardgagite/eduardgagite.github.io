{"content":"\nАутентификация отвечает на вопрос \"Кто ты?\", а авторизация — \"Что тебе можно?\". В Go оба механизма обычно реализуются через **middleware** — функции-обёртки вокруг HTTP-обработчиков.\n\n## JWT — стандарт для stateless аутентификации\n\n**JWT** (JSON Web Token) — компактный токен, который содержит информацию о пользователе. Сервер выдаёт токен при логине, клиент хранит его и передаёт в каждом запросе. Сервер проверяет подпись и читает данные без обращения к базе.\n\nПопулярная библиотека:\n\n```\ngo get github.com/golang-jwt/jwt/v5\n```\n\n### Создание токена при логине\n\n```\nimport (\n    \"time\"\n    \"github.com/golang-jwt/jwt/v5\"\n)\n\nvar secretKey = []byte(\"your-secret-key-min-32-bytes-long\")\n\ntype Claims struct {\n    UserID int    `json:\"user_id\"`\n    Role   string `json:\"role\"`\n    jwt.RegisteredClaims\n}\n\nfunc generateToken(userID int, role string) (string, error) {\n    claims := Claims{\n        UserID: userID,\n        Role:   role,\n        RegisteredClaims: jwt.RegisteredClaims{\n            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),\n            IssuedAt:  jwt.NewNumericDate(time.Now()),\n        },\n    }\n\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n    return token.SignedString(secretKey)\n}\n```\n\n### Проверка токена\n\n```\nfunc parseToken(tokenStr string) (*Claims, error) {\n    token, err := jwt.ParseWithClaims(tokenStr, &Claims{}, func(t *jwt.Token) (interface{}, error) {\n        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {\n            return nil, fmt.Errorf(\"неожиданный метод подписи: %v\", t.Header[\"alg\"])\n        }\n        return secretKey, nil\n    })\n    if err != nil {\n        return nil, err\n    }\n\n    claims, ok := token.Claims.(*Claims)\n    if !ok || !token.Valid {\n        return nil, fmt.Errorf(\"невалидный токен\")\n    }\n    return claims, nil\n}\n```\n\n## Middleware для аутентификации\n\nMiddleware — это функция, которая оборачивает handler. Она проверяет токен, и если всё в порядке — передаёт управление следующему обработчику:\n\n```\ntype contextKey string\n\nconst userClaimsKey contextKey = \"claims\"\n\nfunc AuthMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        authHeader := r.Header.Get(\"Authorization\")\n        if authHeader == \"\" {\n            http.Error(w, \"Authorization header required\", http.StatusUnauthorized)\n            return\n        }\n\n        // Ожидаем формат \"Bearer <token>\"\n        parts := strings.SplitN(authHeader, \" \", 2)\n        if len(parts) != 2 || parts[0] != \"Bearer\" {\n            http.Error(w, \"Invalid authorization format\", http.StatusUnauthorized)\n            return\n        }\n\n        claims, err := parseToken(parts[1])\n        if err != nil {\n            http.Error(w, \"Invalid token: \"+err.Error(), http.StatusUnauthorized)\n            return\n        }\n\n        // Кладём claims в контекст — handlers смогут их прочитать\n        ctx := context.WithValue(r.Context(), userClaimsKey, claims)\n        next.ServeHTTP(w, r.WithContext(ctx))\n    })\n}\n\n// Хелпер для получения claims в handler\nfunc ClaimsFromContext(ctx context.Context) (*Claims, bool) {\n    claims, ok := ctx.Value(userClaimsKey).(*Claims)\n    return claims, ok\n}\n```\n\n## Middleware для авторизации по ролям\n\n```\nfunc RequireRole(role string) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            claims, ok := ClaimsFromContext(r.Context())\n            if !ok {\n                http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n                return\n            }\n\n            if claims.Role != role {\n                http.Error(w, \"Forbidden\", http.StatusForbidden)\n                return\n            }\n\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n```\n\n## Применение middleware в маршрутах\n\n```\nfunc main() {\n    mux := http.NewServeMux()\n\n    // Публичные роуты — без авторизации\n    mux.HandleFunc(\"POST /login\", loginHandler)\n    mux.HandleFunc(\"GET /health\", healthHandler)\n\n    // Защищённые роуты — оборачиваем в AuthMiddleware\n    mux.Handle(\"GET /profile\", AuthMiddleware(http.HandlerFunc(profileHandler)))\n\n    // Роут только для администраторов\n    adminOnly := AuthMiddleware(RequireRole(\"admin\")(http.HandlerFunc(adminHandler)))\n    mux.Handle(\"GET /admin/users\", adminOnly)\n\n    http.ListenAndServe(\":8080\", mux)\n}\n\nfunc profileHandler(w http.ResponseWriter, r *http.Request) {\n    claims, _ := ClaimsFromContext(r.Context())\n    fmt.Fprintf(w, \"Привет, пользователь %d!\\n\", claims.UserID)\n}\n```\n\n## Handler для логина\n\n```\ntype LoginRequest struct {\n    Email    string `json:\"email\"`\n    Password string `json:\"password\"`\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n    var req LoginRequest\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, \"Invalid request body\", http.StatusBadRequest)\n        return\n    }\n\n    // Проверка пользователя в базе (заглушка)\n    user, err := findUserByEmail(req.Email)\n    if err != nil || !checkPassword(user, req.Password) {\n        http.Error(w, \"Invalid credentials\", http.StatusUnauthorized)\n        return\n    }\n\n    token, err := generateToken(user.ID, user.Role)\n    if err != nil {\n        http.Error(w, \"Token generation failed\", http.StatusInternalServerError)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(map[string]string{\"token\": token})\n}\n```\n\n## Refresh tokens — долгоживущие сессии\n\nХороший паттерн: выдавать два токена.\n- **Access token** — короткий (15 минут). Используется в каждом запросе.\n- **Refresh token** — длинный (7-30 дней). Хранится безопасно, используется только для получения нового access token.\n\nКогда access token истёк, клиент отправляет refresh token на отдельный endpoint и получает новую пару токенов. Это ограничивает ущерб при утечке access token.\n\n## Итого\n\nАутентификация в Go строится на **middleware** — это функции-обёртки, которые проверяют токен до вызова handler. JWT подходит для stateless API: сервер не хранит сессии, вся информация о пользователе в токене. **Передавайте claims через контекст запроса** — это стандартный способ донести данные о пользователе до handler без глобальных переменных.\n"}