{"content":"\nHTTP работает по модели запрос-ответ: клиент спрашивает, сервер отвечает, соединение закрывается. Для чата, уведомлений в реальном времени или онлайн-игры это не подходит — нужно постоянное двустороннее соединение.\n\n**WebSocket** — протокол, который начинается как обычный HTTP-запрос, а затем \"апгрейдится\" до постоянного соединения. После апгрейда сервер и клиент могут отправлять сообщения друг другу в любой момент.\n\n## Библиотека gorilla/websocket\n\nСтандартная библиотека Go не включает WebSocket. Самый популярный пакет — **gorilla/websocket**:\n\n```\ngo get github.com/gorilla/websocket\n```\n\n## Базовый WebSocket-сервер\n\nСервер принимает HTTP-соединение и апгрейдит его до WebSocket. Затем читает и отправляет сообщения в цикле:\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n    CheckOrigin: func(r *http.Request) bool {\n        return true // В production проверяйте Origin!\n    },\n}\n\nfunc handleWS(w http.ResponseWriter, r *http.Request) {\n    conn, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        log.Println(\"upgrade error:\", err)\n        return\n    }\n    defer conn.Close()\n\n    for {\n        messageType, message, err := conn.ReadMessage()\n        if err != nil {\n            log.Println(\"read error:\", err)\n            break\n        }\n\n        fmt.Printf(\"Получено: %s\\n\", message)\n\n        // Эхо — отправить то же сообщение обратно\n        if err := conn.WriteMessage(messageType, message); err != nil {\n            log.Println(\"write error:\", err)\n            break\n        }\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/ws\", handleWS)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\n**upgrader.Upgrade** переключает соединение с HTTP на WebSocket. После этого вы работаете с объектом **conn**: читаете сообщения через **ReadMessage** и отправляете через **WriteMessage**.\n\n## Отправка JSON через WebSocket\n\nНа практике сообщения почти всегда в формате JSON. Используйте **ReadJSON** и **WriteJSON** для удобства:\n\n```\ntype Message struct {\n    Type    string `json:\"type\"`\n    Payload string `json:\"payload\"`\n}\n\nfunc handleWS(w http.ResponseWriter, r *http.Request) {\n    conn, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        return\n    }\n    defer conn.Close()\n\n    for {\n        var msg Message\n        if err := conn.ReadJSON(&msg); err != nil {\n            break\n        }\n\n        response := Message{\n            Type:    \"response\",\n            Payload: \"Получил: \" + msg.Payload,\n        }\n        conn.WriteJSON(response)\n    }\n}\n```\n\n## Хаб для broadcast: отправка всем подключённым клиентам\n\nРеальные приложения (чаты, уведомления) требуют рассылки сообщений всем подключённым клиентам. Для этого используют **Hub** — центральный менеджер соединений:\n\n```\ntype Hub struct {\n    clients    map[*websocket.Conn]bool\n    broadcast  chan []byte\n    register   chan *websocket.Conn\n    unregister chan *websocket.Conn\n    mu         sync.Mutex\n}\n\nfunc NewHub() *Hub {\n    return &Hub{\n        clients:    make(map[*websocket.Conn]bool),\n        broadcast:  make(chan []byte),\n        register:   make(chan *websocket.Conn),\n        unregister: make(chan *websocket.Conn),\n    }\n}\n\nfunc (h *Hub) Run() {\n    for {\n        select {\n        case conn := <-h.register:\n            h.mu.Lock()\n            h.clients[conn] = true\n            h.mu.Unlock()\n\n        case conn := <-h.unregister:\n            h.mu.Lock()\n            delete(h.clients, conn)\n            h.mu.Unlock()\n            conn.Close()\n\n        case message := <-h.broadcast:\n            h.mu.Lock()\n            for conn := range h.clients {\n                conn.WriteMessage(websocket.TextMessage, message)\n            }\n            h.mu.Unlock()\n        }\n    }\n}\n```\n\nКаждый клиент при подключении регистрируется в хабе. При получении сообщения — отправляет его в канал **broadcast**, и хаб рассылает всем.\n\n## Настройка таймаутов и Ping/Pong\n\nWebSocket-соединения могут зависнуть, если клиент пропал. Настройте Ping/Pong для проверки \"жив ли клиент\":\n\n```\nconst (\n    writeWait  = 10 * time.Second\n    pongWait   = 60 * time.Second\n    pingPeriod = (pongWait * 9) / 10\n)\n\nfunc handleWS(w http.ResponseWriter, r *http.Request) {\n    conn, _ := upgrader.Upgrade(w, r, nil)\n    defer conn.Close()\n\n    conn.SetReadDeadline(time.Now().Add(pongWait))\n    conn.SetPongHandler(func(string) error {\n        conn.SetReadDeadline(time.Now().Add(pongWait))\n        return nil\n    })\n\n    ticker := time.NewTicker(pingPeriod)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-ticker.C:\n            conn.SetWriteDeadline(time.Now().Add(writeWait))\n            if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil {\n                return\n            }\n        }\n    }\n}\n```\n\nСервер отправляет **Ping** каждые 54 секунды. Если клиент не отвечает **Pong** в течение 60 секунд — соединение закрывается.\n\n## Итого\n\nWebSocket в Go реализуется через **gorilla/websocket** — апгрейд HTTP-соединения и работа с методами **ReadMessage/WriteMessage**. Для чатов и уведомлений используйте паттерн **Hub с каналами** — это безопасный способ рассылки всем клиентам. **Не забывайте про таймауты и Ping/Pong** — без них \"мёртвые\" соединения накапливаются и расходуют память.\n"}