{"content":"\nКогда API растет, появляется необходимость в двух вещах:\n1. **Маршрутизация**: Куда направить запрос в зависимости от URL и метода.\n2. **Middleware**: Общая логика, которая выполняется для **каждого** запроса (логирование, авторизация, CORS).\n\n## Маршрутизация\n\n### Стандартный ServeMux (Go 1.22+)\n\nНачиная с Go 1.22, стандартный маршрутизатор поддерживает методы и параметры в URL.\n\n```\nmux := http.NewServeMux()\n\nmux.HandleFunc(\"GET /api/users\", listUsers)\nmux.HandleFunc(\"GET /api/users/{id}\", getUser)\nmux.HandleFunc(\"POST /api/users\", createUser)\nmux.HandleFunc(\"DELETE /api/users/{id}\", deleteUser)\n\nhttp.ListenAndServe(\":8080\", mux)\n```\n\nДля большинства проектов этого достаточно. Фреймворк нужен, только если вам нужны группы маршрутов, встроенная валидация или WebSocket.\n\n## Middleware\n\nMiddleware — это функция-обертка вокруг обработчика. Она выполняется **до** и/или **после** основного кода.\n\nТипичные задачи для middleware:\n- Логирование (записать, какой запрос пришел и сколько занял).\n- Авторизация (проверить токен).\n- Паника-рекавери (если обработчик запаниковал, не ронять весь сервер).\n- CORS (разрешить запросы с других доменов).\n\n### Как это выглядит\n\nMiddleware — это функция, которая принимает **http.Handler** и возвращает новый **http.Handler**.\n\n```\nfunc loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n\n        next.ServeHTTP(w, r)\n\n        duration := time.Since(start)\n        fmt.Printf(\"%s %s — %v\\n\", r.Method, r.URL.Path, duration)\n    })\n}\n```\n\n### Применение\n\n```\nfunc main() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"GET /api/users\", listUsers)\n\n    handler := loggingMiddleware(mux)\n\n    http.ListenAndServe(\":8080\", handler)\n}\n```\n\nТеперь каждый запрос будет логироваться: **GET /api/users — 2.3ms**.\n\n### Цепочка middleware\n\nMiddleware можно вкладывать друг в друга. Запрос проходит через них как через слои луковицы.\n\n```\nfunc main() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"GET /api/users\", listUsers)\n\n    handler := recoveryMiddleware(loggingMiddleware(corsMiddleware(mux)))\n\n    http.ListenAndServe(\":8080\", handler)\n}\n```\n\n### Recovery Middleware (защита от паники)\n\nЕсли обработчик запаниковал, весь сервер упадет. Этот middleware ловит панику и возвращает 500 вместо краша.\n\n```\nfunc recoveryMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                fmt.Printf(\"PANIC: %v\\n\", err)\n                http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n            }\n        }()\n        next.ServeHTTP(w, r)\n    })\n}\n```\n\n## Итог\n\n1. Стандартный **ServeMux** (Go 1.22+) поддерживает методы и параметры URL — этого хватает для большинства API.\n2. **Middleware** — обертка вокруг обработчика для общей логики (логирование, авторизация).\n3. Middleware вкладываются друг в друга: **recovery(logging(cors(handler)))**.\n4. Recovery middleware — обязателен в продакшене, чтобы сервер не падал от паники.\n"}