{"content":"\nПакет **time** предоставляет всё необходимое для работы со временем: текущее время, измерение интервалов, форматирование дат, таймеры и тикеры. Он используется в каждом серьёзном Go-проекте.\n\n## Текущее время и основные типы\n\n```\nnow := time.Now()\nfmt.Println(now) // 2025-03-15 14:30:00.123456789 +0300 MSK\n```\n\n**time.Time** — основной тип. Содержит момент времени с точностью до наносекунды.\n\n**time.Duration** — промежуток времени. Это просто **int64**, представляющий наносекунды:\n\n```\nfmt.Println(time.Second)      // 1s\nfmt.Println(time.Minute)      // 1m0s\nfmt.Println(time.Hour)        // 1h0m0s\nfmt.Println(5 * time.Second)  // 5s\nfmt.Println(time.Second / 2)  // 500ms\n```\n\n## Разбор компонентов времени\n\n```\nt := time.Now()\n\nfmt.Println(t.Year())        // 2025\nfmt.Println(t.Month())       // March\nfmt.Println(int(t.Month()))  // 3\nfmt.Println(t.Day())         // 15\nfmt.Println(t.Hour())        // 14\nfmt.Println(t.Minute())      // 30\nfmt.Println(t.Second())      // 0\nfmt.Println(t.Weekday())     // Saturday\nfmt.Println(t.Unix())        // 1742039400 — Unix timestamp (секунды с 1970)\nfmt.Println(t.UnixMilli())   // 1742039400123 — миллисекунды\n```\n\n## Форматирование дат\n\nГлавная особенность Go: вместо шаблонов вроде **%Y-%m-%d** используется конкретная дата — **Mon Jan 2 15:04:05 MST 2006**. Это опорное время (reference time). Запоминайте так: **01/02 03:04:05PM '06 -0700**.\n\n```\nt := time.Now()\n\nfmt.Println(t.Format(\"2006-01-02\"))                    // 2025-03-15\nfmt.Println(t.Format(\"02.01.2006\"))                    // 15.03.2025\nfmt.Println(t.Format(\"2006-01-02 15:04:05\"))           // 2025-03-15 14:30:00\nfmt.Println(t.Format(\"02 Jan 2006 15:04 MST\"))         // 15 Mar 2025 14:30 MSK\nfmt.Println(t.Format(time.RFC3339))                    // 2025-03-15T14:30:00+03:00\nfmt.Println(t.Format(time.RFC3339Nano))                // 2025-03-15T14:30:00.123456789+03:00\n```\n\n**time.RFC3339** — стандарт для API и баз данных. Используйте его, когда нужна совместимость с другими системами.\n\n## Парсинг строки в time.Time\n\n```\ns := \"2025-03-15 14:30:00\"\nt, err := time.Parse(\"2006-01-02 15:04:05\", s)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(t.Year()) // 2025\n```\n\nДля строк с часовым поясом используйте **time.ParseInLocation**:\n\n```\nloc, _ := time.LoadLocation(\"Europe/Moscow\")\nt, err := time.ParseInLocation(\"2006-01-02 15:04:05\", \"2025-03-15 14:30:00\", loc)\n```\n\n## Арифметика со временем\n\n```\nt := time.Now()\n\n// Добавить время\ntomorrow := t.Add(24 * time.Hour)\nnextWeek := t.Add(7 * 24 * time.Hour)\nin30min := t.Add(30 * time.Minute)\n\n// AddDate для дней/месяцев/лет\nnextMonth := t.AddDate(0, 1, 0)\nnextYear := t.AddDate(1, 0, 0)\n\n// Разница между двумя моментами\ndiff := tomorrow.Sub(t)\nfmt.Println(diff) // 24h0m0s\n\n// Удобный способ: time.Since и time.Until\nelapsed := time.Since(t)  // сколько прошло с t\nremaining := time.Until(t) // сколько осталось до t\n```\n\n## Сравнение времён\n\n```\na := time.Now()\nb := a.Add(time.Hour)\n\nfmt.Println(a.Before(b)) // true\nfmt.Println(a.After(b))  // false\nfmt.Println(a.Equal(b))  // false\n```\n\nНикогда не сравнивайте **time.Time** через **==** напрямую — это не учитывает часовой пояс. Используйте **Equal**.\n\n## Измерение времени выполнения\n\n```\nstart := time.Now()\n\n// ... какой-то код ...\ntime.Sleep(100 * time.Millisecond)\n\nelapsed := time.Since(start)\nfmt.Printf(\"Выполнено за %v\\n\", elapsed) // Выполнено за 100.123ms\n```\n\n## Таймеры и тикеры\n\n**time.After** — одноразовый таймер, возвращает канал:\n\n```\n// Подождать 5 секунд\n<-time.After(5 * time.Second)\n\n// С select — таймаут для операции\nselect {\ncase result := <-workChan:\n    fmt.Println(\"Результат:\", result)\ncase <-time.After(3 * time.Second):\n    fmt.Println(\"Таймаут!\")\n}\n```\n\n**time.Ticker** — периодический таймер:\n\n```\nticker := time.NewTicker(time.Second)\ndefer ticker.Stop() // ВАЖНО: всегда останавливать тикер\n\nfor i := 0; i < 5; i++ {\n    <-ticker.C\n    fmt.Printf(\"Тик %d в %s\\n\", i+1, time.Now().Format(\"15:04:05\"))\n}\n```\n\n**time.Timer** — одноразовый таймер с возможностью остановки:\n\n```\ntimer := time.NewTimer(5 * time.Second)\n\ngo func() {\n    // Отменить таймер, если работа закончилась раньше\n    timer.Stop()\n}()\n\n<-timer.C\nfmt.Println(\"Таймер сработал\")\n```\n\n## Часовые пояса\n\n```\nutc := time.Now().UTC()\nmoscow, _ := time.LoadLocation(\"Europe/Moscow\")\nt := time.Now().In(moscow)\n\nfmt.Println(utc.Format(\"15:04 MST\"))    // 11:30 UTC\nfmt.Println(t.Format(\"15:04 MST\"))      // 14:30 MSK\n```\n\nДля хранения времени в базе данных всегда сохраняйте UTC и конвертируйте при отображении.\n\n## Итого\n\nПакет **time** строится вокруг двух типов: **time.Time** (момент) и **time.Duration** (промежуток). **Формат даты в Go — это опорное время 2006-01-02 15:04:05**, а не шаблоны с процентами. Для API используйте **time.RFC3339**. Тикеры всегда **Stop()** после использования — иначе горутина за ними зависнет в памяти.\n"}