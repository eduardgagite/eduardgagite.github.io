{"content":"\nСтроки в Go — неизменяемые последовательности байт. Пакет **strings** предоставляет все операции над строками, а **bytes** — аналогичные операции над срезами байт **[]byte**. API у них почти идентичный.\n\n## Основные операции со строками\n\n```\ns := \"Hello, Gopher!\"\n\nfmt.Println(strings.ToUpper(s))          // HELLO, GOPHER!\nfmt.Println(strings.ToLower(s))          // hello, gopher!\nfmt.Println(strings.TrimSpace(\"  hi \"))  // hi\nfmt.Println(strings.Trim(\"--hi--\", \"-\")) // hi — убрать указанные символы с краёв\nfmt.Println(strings.TrimPrefix(s, \"Hello, \")) // Gopher!\nfmt.Println(strings.TrimSuffix(s, \"!\"))       // Hello, Gopher\n```\n\n## Поиск и проверки\n\n```\ns := \"Hello, Gopher!\"\n\nfmt.Println(strings.Contains(s, \"Gopher\"))        // true\nfmt.Println(strings.HasPrefix(s, \"Hello\"))         // true\nfmt.Println(strings.HasSuffix(s, \"!\"))             // true\nfmt.Println(strings.Count(s, \"o\"))                 // 2\nfmt.Println(strings.Index(s, \"Gopher\"))            // 7 (позиция первого вхождения)\nfmt.Println(strings.LastIndex(\"go/go/go\", \"go\"))   // 6\nfmt.Println(strings.ContainsAny(s, \"aeiou\"))       // true — есть хотя бы один символ из набора\n```\n\n## Замена и разбивка\n\n```\ns := \"foo bar foo baz foo\"\n\n// Replace — заменить n первых вхождений (-1 = все)\nfmt.Println(strings.Replace(s, \"foo\", \"qux\", 2))    // qux bar qux baz foo\nfmt.Println(strings.ReplaceAll(s, \"foo\", \"qux\"))     // qux bar qux baz qux\n\n// Split — разбить строку по разделителю\nparts := strings.Split(\"a,b,c\", \",\")\nfmt.Println(parts)      // [a b c]\nfmt.Println(len(parts)) // 3\n\n// SplitN — не более N частей\nparts2 := strings.SplitN(\"a,b,c,d\", \",\", 2)\nfmt.Println(parts2) // [a b,c,d]\n\n// Fields — разбить по пробельным символам\nwords := strings.Fields(\"  hello   world  \")\nfmt.Println(words) // [hello world]\n\n// Join — объединить срез в строку\nfmt.Println(strings.Join([]string{\"a\", \"b\", \"c\"}, \"-\")) // a-b-c\n```\n\n## strings.Builder — эффективная сборка строк\n\nКонкатенация через **+** в цикле создаёт новую строку на каждой итерации. Для эффективной сборки используйте **strings.Builder**:\n\n```\nvar b strings.Builder\nfor i := 0; i < 5; i++ {\n    fmt.Fprintf(&b, \"item%d \", i)\n}\nresult := b.String() // item0 item1 item2 item3 item4\n```\n\n**strings.Builder** реализует **io.Writer**, поэтому с ним работает **fmt.Fprintf**.\n\n## strings.Reader — строка как io.Reader\n\nКогда функция принимает **io.Reader**, а у вас строка:\n\n```\nr := strings.NewReader(\"hello world\")\ndata, _ := io.ReadAll(r)\nfmt.Println(string(data)) // hello world\n```\n\nЭто полезно в тестах: вместо создания файла передаёте строку.\n\n## Пакет bytes — те же операции для []byte\n\n**bytes** — это зеркало **strings** для **[]byte**. Все функции аналогичны:\n\n```\nb := []byte(\"Hello, Gopher!\")\n\nfmt.Println(bytes.Contains(b, []byte(\"Gopher\")))   // true\nfmt.Println(bytes.ToUpper(b))                       // [72 69 76 76 79 ...]\nfmt.Println(string(bytes.ToUpper(b)))               // HELLO, GOPHER!\n\nparts := bytes.Split(b, []byte(\",\"))\nfmt.Println(len(parts)) // 2\n```\n\n**bytes.Buffer** — аналог **strings.Builder** для байт:\n\n```\nvar buf bytes.Buffer\nbuf.WriteString(\"Hello\")\nbuf.WriteString(\", \")\nbuf.WriteString(\"World!\")\nfmt.Println(buf.String()) // Hello, World!\n```\n\n**bytes.Buffer** также реализует **io.Reader** и **io.Writer** — удобно при работе с сетью или файлами в тестах.\n\n## Когда string, а когда []byte\n\nИспользуйте **string** для:\n- Текстовых данных, ключей карт, идентификаторов.\n- Данных, которые не меняются.\n\nИспользуйте **[]byte** для:\n- Данных, которые нужно модифицировать.\n- Работы с бинарными данными (файлы, сеть, шифрование).\n- Производительных операций — преобразование **string → []byte** копирует данные.\n\nПреобразование между ними:\n```\ns := \"hello\"\nb := []byte(s)    // string → []byte (копирование)\ns2 := string(b)   // []byte → string (копирование)\n```\n\nВ Go 1.20+ добавили **unsafe.String** и **unsafe.SliceData** для преобразования без копирования, но это нужно редко.\n\n## Итого\n\n**strings** и **bytes** — парные пакеты с одинаковым API. **strings.Builder** незаменим при сборке строк в цикле. **strings.NewReader** и **bytes.Buffer** — мосты между строками/байтами и интерфейсом **io.Reader/Writer**, которые используются повсюду в стандартной библиотеке.\n"}