{"content":"\nСортировка и поиск в коллекциях — одни из самых частых задач. В Go для этого есть два пакета: классический **sort** (с Go 1.0) и современный **slices** (с Go 1.21), который работает удобнее благодаря дженерикам.\n\n## Пакет sort — сортировка стандартных типов\n\nДля срезов базовых типов есть готовые функции:\n\n```\nints := []int{5, 2, 8, 1, 9, 3}\nsort.Ints(ints)\nfmt.Println(ints) // [1 2 3 5 8 9]\n\nstrs := []string{\"banana\", \"apple\", \"cherry\"}\nsort.Strings(strs)\nfmt.Println(strs) // [apple banana cherry]\n\nfloats := []float64{3.14, 1.41, 2.71}\nsort.Float64s(floats)\nfmt.Println(floats) // [1.41 2.71 3.14]\n```\n\nСортировка по убыванию — через **sort.Reverse**:\n\n```\nsort.Sort(sort.Reverse(sort.IntSlice(ints)))\nfmt.Println(ints) // [9 8 5 3 2 1]\n```\n\n## sort.Slice — сортировка с кастомным компаратором\n\nДля структур и нестандартных критериев используйте **sort.Slice**:\n\n```\ntype User struct {\n    Name string\n    Age  int\n}\n\nusers := []User{\n    {\"Charlie\", 30},\n    {\"Alice\", 25},\n    {\"Bob\", 35},\n}\n\n// Сортировка по возрасту\nsort.Slice(users, func(i, j int) bool {\n    return users[i].Age < users[j].Age\n})\nfmt.Println(users) // [{Alice 25} {Charlie 30} {Bob 35}]\n\n// Сортировка по имени\nsort.Slice(users, func(i, j int) bool {\n    return users[i].Name < users[j].Name\n})\nfmt.Println(users) // [{Alice 25} {Bob 35} {Charlie 30}]\n```\n\n**sort.SliceStable** — сохраняет порядок равных элементов (стабильная сортировка).\n\n## Бинарный поиск\n\nПосле сортировки можно использовать бинарный поиск — O(log n) вместо O(n):\n\n```\nints := []int{1, 2, 3, 5, 8, 9}\n\nidx := sort.SearchInts(ints, 5)\nfmt.Println(idx) // 3 — индекс, где стоит 5\n\n// Для произвольного типа:\nidx = sort.Search(len(ints), func(i int) bool {\n    return ints[i] >= 7\n})\nfmt.Println(idx)         // 5 — первая позиция >= 7\nfmt.Println(ints[idx])   // 8\n```\n\n**sort.Search** возвращает первый индекс, где предикат стал **true**. Если элемент не найден — возвращает **len(slice)**.\n\n## Пакет slices (Go 1.21+) — современный API\n\nС Go 1.21 появился пакет **slices** с дженерик-функциями. Он удобнее и безопаснее:\n\n```\nimport \"slices\"\n\nnums := []int{5, 2, 8, 1, 9, 3}\nslices.Sort(nums)\nfmt.Println(nums) // [1 2 3 5 8 9]\n\n// Обратная сортировка\nslices.SortFunc(nums, func(a, b int) int {\n    return b - a // убывание\n})\nfmt.Println(nums) // [9 8 5 3 2 1]\n```\n\nСортировка структур:\n\n```\nusers := []User{\n    {\"Charlie\", 30},\n    {\"Alice\", 25},\n    {\"Bob\", 35},\n}\n\nslices.SortFunc(users, func(a, b User) int {\n    return strings.Compare(a.Name, b.Name)\n})\n```\n\nБинарный поиск:\n\n```\nnums := []int{1, 2, 3, 5, 8, 9}\nidx, found := slices.BinarySearch(nums, 5)\nfmt.Println(idx, found) // 3 true\n```\n\n## Дополнительные операции в пакете slices\n\n```\nnums := []int{1, 2, 3, 4, 5}\n\n// Проверки\nfmt.Println(slices.Contains(nums, 3))   // true\nfmt.Println(slices.Index(nums, 3))      // 2\n\n// Максимум и минимум\nfmt.Println(slices.Max(nums))           // 5\nfmt.Println(slices.Min(nums))           // 1\n\n// Сравнение срезов\na := []int{1, 2, 3}\nb := []int{1, 2, 3}\nfmt.Println(slices.Equal(a, b))         // true\n\n// Удаление дубликатов (срез должен быть отсортирован)\ndupes := []int{1, 1, 2, 3, 3, 4}\ncompact := slices.Compact(dupes)\nfmt.Println(compact) // [1 2 3 4]\n\n// Разворот\nslices.Reverse(nums)\nfmt.Println(nums) // [5 4 3 2 1]\n```\n\n## sort.IsSorted — проверить, отсортирован ли срез\n\n```\nsorted := []int{1, 2, 3, 5, 8}\nunsorted := []int{5, 2, 8, 1}\n\nfmt.Println(sort.IntsAreSorted(sorted))   // true\nfmt.Println(sort.IntsAreSorted(unsorted)) // false\n\n// В slices:\nfmt.Println(slices.IsSorted(sorted)) // true\n```\n\n## Итого\n\nДля нового кода (Go 1.21+) используйте пакет **slices** — он проще, типобезопаснее и не требует написания `sort.Slice` с замыканием. Для старого кода или кастомной сортировки — **sort.Slice**. **Бинарный поиск работает только на отсортированных данных** — всегда сортируйте перед поиском или поддерживайте порядок при вставке.\n"}