{"content":"\nПакет **os** — это интерфейс к операционной системе: переменные окружения, аргументы командной строки, файловая система, сигналы. Пакет **os/exec** позволяет запускать внешние команды и программы.\n\n## Переменные окружения\n\n```\n// Получить значение переменной\nhome := os.Getenv(\"HOME\")\nfmt.Println(home) // /Users/username\n\n// Получить с проверкой наличия\nval, ok := os.LookupEnv(\"DATABASE_URL\")\nif !ok {\n    log.Fatal(\"DATABASE_URL не задан\")\n}\n\n// Установить переменную (только для текущего процесса)\nos.Setenv(\"MY_VAR\", \"hello\")\n\n// Удалить переменную\nos.Unsetenv(\"MY_VAR\")\n\n// Все переменные окружения\nfor _, env := range os.Environ() {\n    fmt.Println(env) // KEY=VALUE\n}\n```\n\n## Аргументы командной строки\n\n```\n// os.Args[0] — путь к исполняемому файлу\n// os.Args[1:] — аргументы\nfmt.Println(os.Args)     // [./myapp arg1 arg2]\nfmt.Println(os.Args[0])  // ./myapp\nfmt.Println(os.Args[1:]) // [arg1 arg2]\n\nif len(os.Args) < 2 {\n    fmt.Fprintln(os.Stderr, \"Использование: myapp <имя>\")\n    os.Exit(1)\n}\nname := os.Args[1]\n```\n\n## Выход из программы\n\n```\nos.Exit(0)  // успешное завершение\nos.Exit(1)  // завершение с ошибкой\n```\n\n**Важно**: **os.Exit** не выполняет отложенные функции **defer**. Если нужна очистка — используйте код возврата из **main** или паникуйте с recover.\n\n## Информация о системе\n\n```\nhostname, _ := os.Hostname()\nfmt.Println(hostname) // my-server\n\nwd, _ := os.Getwd()\nfmt.Println(wd) // /home/user/projects\n\npid := os.Getpid()\nfmt.Println(pid) // 12345\n```\n\n## Временные файлы и директории\n\n```\n// Временный файл\ntmpFile, err := os.CreateTemp(\"\", \"myapp-*.txt\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer os.Remove(tmpFile.Name()) // удалить после использования\nfmt.Println(tmpFile.Name()) // /tmp/myapp-123456.txt\n\n// Временная директория\ntmpDir, err := os.MkdirTemp(\"\", \"myapp-*\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer os.RemoveAll(tmpDir)\n```\n\nПервый аргумент — базовая директория (пустая строка = системная tmp). Второй — паттерн для имени, **\\*** заменяется случайным суффиксом.\n\n## os/exec — запуск внешних команд\n\n```\nimport \"os/exec\"\n\n// Простой запуск команды\ncmd := exec.Command(\"ls\", \"-la\")\noutput, err := cmd.Output()\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(string(output))\n```\n\n**cmd.Output()** запускает команду и возвращает её stdout. Если команда завершилась с ненулевым кодом — возвращается **\\*exec.ExitError**.\n\n## Захват stdout и stderr по отдельности\n\n```\ncmd := exec.Command(\"go\", \"build\", \"./...\")\n\nvar stdout, stderr bytes.Buffer\ncmd.Stdout = &stdout\ncmd.Stderr = &stderr\n\nerr := cmd.Run()\nif err != nil {\n    fmt.Println(\"Ошибка:\", err)\n    fmt.Println(\"Stderr:\", stderr.String())\n}\nfmt.Println(\"Stdout:\", stdout.String())\n```\n\n## Передача входных данных через stdin\n\n```\ncmd := exec.Command(\"wc\", \"-l\")\ncmd.Stdin = strings.NewReader(\"строка1\\nстрока2\\nстрока3\\n\")\n\noutput, err := cmd.Output()\nfmt.Println(strings.TrimSpace(string(output))) // 3\n```\n\n## Переменные окружения для дочернего процесса\n\n```\ncmd := exec.Command(\"printenv\", \"MY_VAR\")\ncmd.Env = append(os.Environ(), \"MY_VAR=hello_from_parent\")\n\noutput, _ := cmd.Output()\nfmt.Println(string(output)) // hello_from_parent\n```\n\nЕсли **cmd.Env** не задан — дочерний процесс наследует окружение родителя. Если задан явно — используется только то, что указано.\n\n## Потоковый вывод команды\n\nИногда нужно читать вывод команды в реальном времени:\n\n```\ncmd := exec.Command(\"ping\", \"-c\", \"4\", \"8.8.8.8\")\ncmd.Stdout = os.Stdout // пробрасываем напрямую в наш stdout\ncmd.Stderr = os.Stderr\n\nif err := cmd.Run(); err != nil {\n    log.Fatal(err)\n}\n```\n\n## Проверка существования программы\n\n```\npath, err := exec.LookPath(\"git\")\nif err != nil {\n    fmt.Println(\"git не найден в PATH\")\n} else {\n    fmt.Println(\"git находится по пути:\", path)\n}\n```\n\n## Контекст с таймаутом для команды\n\n```\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\ncmd := exec.CommandContext(ctx, \"sleep\", \"10\")\nif err := cmd.Run(); err != nil {\n    if ctx.Err() == context.DeadlineExceeded {\n        fmt.Println(\"Команда прервана по таймауту\")\n    }\n}\n```\n\n**exec.CommandContext** автоматически убьёт процесс при отмене контекста.\n\n## Итого\n\nПакет **os** — стандартный способ работать с окружением, процессом и системой. Для переменных окружения предпочитайте **LookupEnv** вместо **Getenv** — он показывает, задана ли переменная вообще. **os/exec** запускает внешние команды; всегда используйте **CommandContext с таймаутом** для команд, которые могут зависнуть.\n"}