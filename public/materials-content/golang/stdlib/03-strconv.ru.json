{"content":"\nВ Go нельзя просто присвоить число строке или наоборот — нужно явное преобразование. За это отвечает пакет **strconv** (String Converter): он конвертирует числа, булевы значения и другие примитивы в строки и обратно.\n\n## Числа в строки: Itoa и FormatInt\n\nСамый частый случай — преобразовать **int** в **string**:\n\n```\nn := 42\ns := strconv.Itoa(n)\nfmt.Println(s)         // \"42\"\nfmt.Printf(\"%T\\n\", s) // string\n```\n\n**Itoa** — это сокращение от \"Integer to ASCII\". Обратная функция — **Atoi** (ASCII to Integer).\n\nДля точного контроля над форматом используйте **FormatInt**:\n\n```\n// FormatInt(значение, основание_счисления)\nfmt.Println(strconv.FormatInt(255, 10))  // \"255\"   — десятичное\nfmt.Println(strconv.FormatInt(255, 16))  // \"ff\"    — шестнадцатеричное\nfmt.Println(strconv.FormatInt(255, 2))   // \"11111111\" — двоичное\nfmt.Println(strconv.FormatInt(255, 8))   // \"377\"   — восьмеричное\n```\n\nДля **float64**:\n\n```\nf := 3.14159\nfmt.Println(strconv.FormatFloat(f, 'f', 2, 64))  // \"3.14\"   — фиксированная точка, 2 знака\nfmt.Println(strconv.FormatFloat(f, 'e', 3, 64))  // \"3.142e+00\" — экспоненциальная\nfmt.Println(strconv.FormatFloat(f, 'g', -1, 64)) // \"3.14159\"  — кратчайшее представление\n```\n\n## Строки в числа: Atoi и ParseInt\n\n```\nn, err := strconv.Atoi(\"42\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(n) // 42\n```\n\nЕсли строка не является числом — **err** будет **\\*strconv.NumError**:\n\n```\nn, err := strconv.Atoi(\"abc\")\n// err.(*strconv.NumError).Func = \"Atoi\"\n// err.(*strconv.NumError).Num = \"abc\"\n// err.(*strconv.NumError).Err = strconv.ErrSyntax\n```\n\n**ParseInt** даёт больше контроля:\n\n```\n// ParseInt(строка, основание, размер_в_битах)\nn, err := strconv.ParseInt(\"ff\", 16, 64) // из шестнадцатеричной\nfmt.Println(n) // 255\n\nn, err = strconv.ParseInt(\"11111111\", 2, 64) // из двоичной\nfmt.Println(n) // 255\n```\n\nРазмер в битах (8, 16, 32, 64) ограничивает диапазон, но тип результата всегда **int64**.\n\n```\nf, err := strconv.ParseFloat(\"3.14159\", 64)\nfmt.Println(f) // 3.14159\n```\n\n## Булевы значения\n\n```\n// bool → string\nfmt.Println(strconv.FormatBool(true))   // \"true\"\nfmt.Println(strconv.FormatBool(false))  // \"false\"\n\n// string → bool\nb, err := strconv.ParseBool(\"true\")   // true\nb, err = strconv.ParseBool(\"1\")       // true\nb, err = strconv.ParseBool(\"false\")   // false\nb, err = strconv.ParseBool(\"0\")       // false\nb, err = strconv.ParseBool(\"yes\")     // error: invalid syntax\n```\n\n## AppendInt и AppendFloat — эффективная запись в []byte\n\nЕсли вам нужно добавить число к существующему срезу байт без выделения новой строки:\n\n```\nbuf := []byte(\"count: \")\nbuf = strconv.AppendInt(buf, 42, 10)\nfmt.Println(string(buf)) // count: 42\n```\n\nЭто полезно при построении ответов сервера или работе с протоколами вручную — избегает лишних аллокаций.\n\n## Quote и Unquote — экранирование строк\n\n```\ns := \"hello\\nworld\"\nquoted := strconv.Quote(s)\nfmt.Println(quoted) // \"hello\\nworld\" — с экранированием\n\nunquoted, _ := strconv.Unquote(`\"hello\\nworld\"`)\nfmt.Println(unquoted) // hello\n                      // world\n```\n\nИспользуется при генерации кода, сериализации или парсинге конфигурационных файлов.\n\n## Типичный паттерн: парсинг из параметров запроса\n\nURL-параметры всегда строки. Вот стандартный паттерн конвертации:\n\n```\nfunc handleGetUser(w http.ResponseWriter, r *http.Request) {\n    idStr := r.URL.Query().Get(\"id\")\n    if idStr == \"\" {\n        http.Error(w, \"id parameter required\", http.StatusBadRequest)\n        return\n    }\n\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        http.Error(w, \"id must be a number\", http.StatusBadRequest)\n        return\n    }\n\n    // Работаем с id как с int\n    user, err := db.GetUser(id)\n    // ...\n}\n```\n\n## Итого\n\n**strconv** — мост между строками и числовыми типами. **Atoi/Itoa** покрывают 80% задач — конвертация **int ↔ string**. **ParseInt/FormatInt** нужны при работе с другими системами счисления (hex, binary). **Всегда проверяйте ошибку** — пользовательский ввод ненадёжен, и непроверенная ошибка приведёт к нулевому значению вместо корректного числа.\n"}