{"content":"\nРегулярные выражения (regexp) — язык для поиска паттернов в строках. В Go они реализованы через пакет **regexp** с синтаксисом RE2 — гарантированно выполняются за линейное время, без катастрофического возврата (ReDoS-атак).\n\n## Компиляция паттерна\n\nПеред использованием паттерн нужно скомпилировать:\n\n```\n// MustCompile — паникует при ошибке в паттерне (для статических паттернов)\nre := regexp.MustCompile(`\\d+`)\n\n// Compile — возвращает ошибку (для динамических паттернов)\nre, err := regexp.Compile(`\\d+`)\nif err != nil {\n    log.Fatal(err)\n}\n```\n\nКомпиляция — затратная операция. **Компилируйте паттерны один раз** — в переменную пакета или в функции инициализации, а не внутри цикла.\n\n```\n// Хорошо: один раз на весь пакет\nvar emailRegexp = regexp.MustCompile(`^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$`)\n\n// Плохо: компиляция при каждом вызове\nfunc validateEmail(email string) bool {\n    re := regexp.MustCompile(`^[a-zA-Z0-9._%+\\-]+@...`) // не делайте так\n    return re.MatchString(email)\n}\n```\n\n## Базовые операции\n\n```\nre := regexp.MustCompile(`\\d+`)\ns := \"У меня 3 кота и 12 собак\"\n\nfmt.Println(re.MatchString(s))           // true — есть ли совпадение\nfmt.Println(re.FindString(s))            // \"3\" — первое совпадение\nfmt.Println(re.FindAllString(s, -1))     // [\"3\" \"12\"] — все совпадения (-1 = без ограничений)\nfmt.Println(re.FindAllString(s, 1))      // [\"3\"] — только первое совпадение\nfmt.Println(re.ReplaceAllString(s, \"N\")) // \"У меня N кота и N собак\"\n```\n\n## Захватывающие группы\n\nГруппы в скобках позволяют захватить части паттерна:\n\n```\nre := regexp.MustCompile(`(\\d{4})-(\\d{2})-(\\d{2})`)\ns := \"Дата: 2025-03-15\"\n\nmatch := re.FindStringSubmatch(s)\n// match[0] = \"2025-03-15\" — всё совпадение\n// match[1] = \"2025\"       — первая группа\n// match[2] = \"03\"         — вторая группа\n// match[3] = \"15\"         — третья группа\n\nif len(match) > 0 {\n    fmt.Printf(\"Год: %s, месяц: %s, день: %s\\n\", match[1], match[2], match[3])\n}\n```\n\nДля именованных групп:\n\n```\nre := regexp.MustCompile(`(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})`)\ns := \"2025-03-15\"\n\nmatch := re.FindStringSubmatch(s)\nnames := re.SubexpNames()\n\nresult := map[string]string{}\nfor i, name := range names {\n    if name != \"\" && i < len(match) {\n        result[name] = match[i]\n    }\n}\nfmt.Println(result[\"year\"])  // 2025\nfmt.Println(result[\"month\"]) // 03\n```\n\n## Все совпадения с группами\n\n```\nre := regexp.MustCompile(`(\\w+)=(\\w+)`)\ns := \"name=Alice age=30 city=Moscow\"\n\nmatches := re.FindAllStringSubmatch(s, -1)\nfor _, m := range matches {\n    fmt.Printf(\"ключ=%s, значение=%s\\n\", m[1], m[2])\n}\n// ключ=name, значение=Alice\n// ключ=age, значение=30\n// ключ=city, значение=Moscow\n```\n\n## Разбивка строки по паттерну\n\n```\nre := regexp.MustCompile(`\\s+`)\nparts := re.Split(\"один  два   три\\tчетыре\", -1)\nfmt.Println(parts) // [один два три четыре]\n```\n\n## Замена с функцией\n\n**ReplaceAllStringFunc** позволяет обработать каждое совпадение:\n\n```\nre := regexp.MustCompile(`\\d+`)\ns := \"у меня 3 кота и 12 собак\"\n\nresult := re.ReplaceAllStringFunc(s, func(match string) string {\n    n, _ := strconv.Atoi(match)\n    return strconv.Itoa(n * 2) // удвоить каждое число\n})\nfmt.Println(result) // у меня 6 кота и 24 собак\n```\n\n## Основные метасимволы RE2\n\n```\n.       — любой символ (кроме \\n)\n\\d      — цифра [0-9]\n\\D      — не цифра\n\\w      — буква, цифра или _\n\\W      — не \\w\n\\s      — пробельный символ\n\\S      — не пробельный\n\n^       — начало строки\n$       — конец строки\n*       — 0 или больше повторений\n+       — 1 или больше повторений\n?       — 0 или 1 повторение\n{n}     — ровно n повторений\n{n,m}   — от n до m повторений\n[abc]   — один из символов\n[^abc]  — любой кроме указанных\n(a|b)   — a или b\n```\n\n## Практический пример: валидация данных\n\n```\nvar (\n    emailRe = regexp.MustCompile(`^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$`)\n    phoneRe = regexp.MustCompile(`^\\+7\\d{10}$`)\n    uuidRe  = regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)\n)\n\nfunc validateEmail(email string) bool {\n    return emailRe.MatchString(email)\n}\n\nfunc validatePhone(phone string) bool {\n    return phoneRe.MatchString(phone)\n}\n```\n\n## Итого\n\nПакет **regexp** использует синтаксис RE2 — он безопасен по времени выполнения. **Компилируйте паттерны один раз** в переменные пакета — это критично для производительности. Для захвата частей используйте группы и **FindStringSubmatch**. Если задачу можно решить через **strings.Contains** или **strings.Split** — предпочтите их: они быстрее и читаемее.\n"}