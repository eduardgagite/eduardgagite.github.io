{"content":"\nЛюбая программа рано или поздно должна что-то сохранить на диск или прочитать оттуда: конфиги, логи, данные пользователей, результаты работы. В Go работа с файлами реализована в пакете `os` и его помощниках.\n\n## Чтение файла целиком\n\nСамый простой способ. Подходит для небольших файлов (конфиги, ключи, шаблоны).\n\n```go\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // ReadFile возвращает []byte (срез байтов) и ошибку\n    data, err := os.ReadFile(\"config.json\")\n    if err != nil {\n        fmt.Println(\"Ошибка:\", err)\n        return\n    }\n\n    // Превращаем байты в строку\n    content := string(data)\n    fmt.Println(content)\n}\n```\n\n**Когда НЕ использовать**: Если файл большой (логи, дампы, видео). `os.ReadFile` загружает **ВЕСЬ** файл в оперативную память. Файл на 5 ГБ = 5 ГБ памяти. Для больших файлов используйте потоковое чтение (следующий урок).\n\n## Запись в файл\n\n### Перезапись (WriteFile)\n\nСоздает файл (или перезаписывает, если существует).\n\n```go\ncontent := []byte(\"Hello, Go!\\nВторая строка\")\n\n// 0644 — права доступа (я читаю/пишу, остальные только читают)\nerr := os.WriteFile(\"output.txt\", content, 0644)\nif err != nil {\n    fmt.Println(\"Ошибка записи:\", err)\n}\n```\n\n### Дописать в конец файла (Append)\n\nЕсли нужно добавить строку, а не перезаписать весь файл (например, в лог):\n\n```go\n// Открываем файл с флагами: Append + Create (если нет) + WriteOnly\nf, err := os.OpenFile(\"app.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\nif err != nil {\n    panic(err)\n}\ndefer f.Close() // Закроем файл, когда функция завершится\n\nf.WriteString(\"2025-01-28 Событие произошло\\n\")\n```\n\n## Проверка существования файла\n\n```go\n_, err := os.Stat(\"config.json\")\n\nif os.IsNotExist(err) {\n    fmt.Println(\"Файл не существует\")\n} else if err != nil {\n    fmt.Println(\"Ошибка:\", err)\n} else {\n    fmt.Println(\"Файл найден\")\n}\n```\n\n## Создание и удаление\n\n```go\n// Создать директорию (с вложенными)\nos.MkdirAll(\"data/uploads/images\", 0755)\n\n// Удалить файл\nos.Remove(\"temp.txt\")\n\n// Удалить директорию со всем содержимым\nos.RemoveAll(\"data/uploads\")\n```\n\n## Работа с путями (filepath)\n\nВ Windows пути пишутся через обратный слэш: `C:\\Users\\file.txt`.\nВ Linux/macOS — через прямой: `/home/user/file.txt`.\n\nЧтобы программа работала на любой ОС, **никогда не склеивайте пути через `+` или конкатенацию строк**. Используйте пакет `path/filepath`.\n\n```go\nimport \"path/filepath\"\n\n// Склеить путь (автоматически выберет правильный разделитель)\npath := filepath.Join(\"data\", \"uploads\", \"image.png\")\n// Linux: data/uploads/image.png\n// Windows: data\\uploads\\image.png\n\n// Получить расширение\next := filepath.Ext(\"photo.jpg\") // \".jpg\"\n\n// Получить имя файла без пути\nname := filepath.Base(\"/home/user/photo.jpg\") // \"photo.jpg\"\n\n// Получить директорию\ndir := filepath.Dir(\"/home/user/photo.jpg\") // \"/home/user\"\n```\n\n### Обход директории (Walk)\n\nЧтобы найти все файлы в папке (рекурсивно):\n\n```go\nfilepath.Walk(\".\", func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n        return err\n    }\n    if !info.IsDir() {\n        fmt.Println(\"Файл:\", path)\n    }\n    return nil\n})\n```\n\n## Итог\n\n1. `os.ReadFile` — быстро прочитать маленький файл.\n2. `os.WriteFile` — записать/перезаписать файл.\n3. `os.OpenFile` с `O_APPEND` — дописать в конец (для логов).\n4. `filepath.Join` — безопасно склеивать пути на любой ОС.\n5. Не забывайте `defer f.Close()` при работе с открытыми файлами.\n"}