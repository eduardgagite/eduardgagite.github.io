{"content":"\nЛюбая программа рано или поздно должна что-то сохранить на диск или прочитать оттуда: конфиги, логи, данные пользователей, результаты работы. В Go работа с файлами реализована в пакете **os** и его помощниках.\n\n## Чтение файла целиком\n\nСамый простой способ. Подходит для небольших файлов (конфиги, ключи, шаблоны).\n\n```\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    data, err := os.ReadFile(\"config.json\")\n    if err != nil {\n        fmt.Println(\"Ошибка:\", err)\n        return\n    }\n\n    content := string(data)\n    fmt.Println(content)\n}\n```\n\n**Когда НЕ использовать**: Если файл большой (логи, дампы, видео). **os.ReadFile** загружает **ВЕСЬ** файл в оперативную память. Файл на 5 ГБ = 5 ГБ памяти. Для больших файлов используйте потоковое чтение (следующий урок).\n\n## Запись в файл\n\n### Перезапись (WriteFile)\n\nСоздает файл (или перезаписывает, если существует).\n\n```\ncontent := []byte(\"Hello, Go!\\nВторая строка\")\n\nerr := os.WriteFile(\"output.txt\", content, 0644)\nif err != nil {\n    fmt.Println(\"Ошибка записи:\", err)\n}\n```\n\n### Дописать в конец файла (Append)\n\nЕсли нужно добавить строку, а не перезаписать весь файл (например, в лог):\n\n```\nf, err := os.OpenFile(\"app.log\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\nif err != nil {\n    panic(err)\n}\ndefer f.Close()\n\nf.WriteString(\"2025-01-28 Событие произошло\\n\")\n```\n\n## Проверка существования файла\n\n```\n_, err := os.Stat(\"config.json\")\n\nif os.IsNotExist(err) {\n    fmt.Println(\"Файл не существует\")\n} else if err != nil {\n    fmt.Println(\"Ошибка:\", err)\n} else {\n    fmt.Println(\"Файл найден\")\n}\n```\n\n## Создание и удаление\n\n```\nos.MkdirAll(\"data/uploads/images\", 0755)\n\nos.Remove(\"temp.txt\")\n\nos.RemoveAll(\"data/uploads\")\n```\n\n## Работа с путями (filepath)\n\nВ Windows пути пишутся через обратный слэш: **C:\\Users\\file.txt**.\nВ Linux/macOS — через прямой: **/home/user/file.txt**.\n\nЧтобы программа работала на любой ОС, **никогда не склеивайте пути через + или конкатенацию строк**. Используйте пакет **path/filepath**.\n\n```\nimport \"path/filepath\"\n\npath := filepath.Join(\"data\", \"uploads\", \"image.png\")\n\next := filepath.Ext(\"photo.jpg\") // \".jpg\"\n\nname := filepath.Base(\"/home/user/photo.jpg\") // \"photo.jpg\"\n\ndir := filepath.Dir(\"/home/user/photo.jpg\") // \"/home/user\"\n```\n\n### Обход директории (Walk)\n\nЧтобы найти все файлы в папке (рекурсивно):\n\n```\nfilepath.Walk(\".\", func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n        return err\n    }\n    if !info.IsDir() {\n        fmt.Println(\"Файл:\", path)\n    }\n    return nil\n})\n```\n\n## Итог\n\n1. **os.ReadFile** — быстро прочитать маленький файл.\n2. **os.WriteFile** — записать/перезаписать файл.\n3. **os.OpenFile** с **O_APPEND** — дописать в конец (для логов).\n4. **filepath.Join** — безопасно склеивать пути на любой ОС.\n5. Не забывайте **defer f.Close()** при работе с открытыми файлами.\n"}