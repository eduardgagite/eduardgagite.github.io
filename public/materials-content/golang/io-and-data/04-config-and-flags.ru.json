{"content":"\nХардкодить (жестко прописывать) настройки в коде — плохая практика. Порт сервера, адрес базы данных, API-ключи — всё это должно приходить извне, чтобы один и тот же код работал в разных окружениях (разработка, тестирование, продакшен).\n\nВ Go есть два стандартных подхода: **флаги командной строки** и **переменные окружения**.\n\n## Флаги командной строки (flag)\n\nПредставьте, что вы хотите запускать программу так:\n\n```\n./myapp -port=8080 -env=production -debug\n```\n\nПакет **flag** из стандартной библиотеки разбирает такие аргументы.\n\n```\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    port := flag.Int(\"port\", 3000, \"Port to run server on\")\n    env := flag.String(\"env\", \"dev\", \"Environment (dev/staging/prod)\")\n    debug := flag.Bool(\"debug\", false, \"Enable debug mode\")\n\n    flag.Parse()\n\n    fmt.Printf(\"Порт: %d\\n\", *port)\n    fmt.Printf(\"Окружение: %s\\n\", *env)\n\n    if *debug {\n        fmt.Println(\"Режим отладки включен\")\n    }\n}\n```\n\n### Автоматическая справка\n\nЕсли пользователь запустит программу с флагом **-help** или **-h**, Go автоматически покажет описание всех флагов:\n\n```\n./myapp -help\n# Usage of ./myapp:\n#   -debug\n#         Enable debug mode\n#   -env string\n#         Environment (dev/staging/prod) (default \"dev\")\n#   -port int\n#         Port to run server on (default 3000)\n```\n\n## Переменные окружения (Environment Variables)\n\nВ мире Docker и Kubernetes настройки чаще передают через переменные окружения. Это стандарт для облачных приложений.\n\n```\nDB_HOST=localhost DB_PORT=5432 DB_PASSWORD=secret ./myapp\n```\n\nВ Go их читают через **os.Getenv**.\n\n```\nimport (\n    \"os\"\n    \"fmt\"\n)\n\nfunc main() {\n    dbHost := os.Getenv(\"DB_HOST\")\n    dbPort := os.Getenv(\"DB_PORT\")\n    dbPass := os.Getenv(\"DB_PASSWORD\")\n\n    if dbHost == \"\" {\n        dbHost = \"localhost\"\n    }\n\n    fmt.Printf(\"Подключение к %s:%s\\n\", dbHost, dbPort)\n}\n```\n\n### Проблема: os.Getenv не отличает \"пусто\" от \"не задано\"\n\n**os.Getenv(\"MISSING\")** вернет пустую строку **\"\"**. Но что если переменная специально задана как пустая?\n\nИспользуйте **os.LookupEnv**, чтобы различить эти случаи:\n\n```\nvalue, exists := os.LookupEnv(\"DB_PASSWORD\")\nif !exists {\n    fmt.Println(\"Переменная DB_PASSWORD не задана!\")\n} else if value == \"\" {\n    fmt.Println(\"Переменная задана, но пустая\")\n} else {\n    fmt.Println(\"Пароль получен\")\n}\n```\n\n## Комбинированный подход\n\nНа практике часто используют оба способа с приоритетом:\n1. Флаг командной строки (высший приоритет).\n2. Переменная окружения.\n3. Значение по умолчанию.\n\n```\nfunc getConfig() string {\n    port := flag.Int(\"port\", 0, \"Server port\")\n    flag.Parse()\n\n    if *port != 0 {\n        return fmt.Sprintf(\":%d\", *port)\n    }\n\n    if envPort := os.Getenv(\"PORT\"); envPort != \"\" {\n        return \":\" + envPort\n    }\n\n    return \":3000\"\n}\n```\n\n## Конфигурационные файлы\n\nДля сложных конфигураций (десятки параметров) удобнее использовать файл. Go умеет читать JSON \"из коробки\":\n\n```\ntype Config struct {\n    Port     int    `json:\"port\"`\n    Database string `json:\"database_url\"`\n    Debug    bool   `json:\"debug\"`\n}\n\nfunc LoadConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, err\n    }\n\n    var cfg Config\n    if err := json.Unmarshal(data, &cfg); err != nil {\n        return nil, err\n    }\n    return &cfg, nil\n}\n```\n\n## Итог\n\n1. **flag** — для параметров, которые удобно менять при ручном запуске (**-port**, **-verbose**).\n2. **os.Getenv** — для секретов и настроек в Docker/Kubernetes.\n3. Комбинируйте: флаг > переменная окружения > значение по умолчанию.\n4. Для сложных конфигов — читайте JSON/YAML файл.\n"}