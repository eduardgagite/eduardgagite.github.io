{"content":"\nJSON — это формат обмена данными, который используется повсеместно: REST API, конфигурационные файлы, логи, межсервисное общение. Go имеет встроенную поддержку JSON в пакете **encoding/json**.\n\n## Теги структур (Struct Tags)\n\nЧтобы Go знал, как превратить структуру в JSON (и обратно), используются **теги** — метаданные, записанные в обратных кавычках после типа поля.\n\n```\ntype User struct {\n    Name     string `json:\"username\"`\n    Age      int    `json:\"age\"`\n    Password string `json:\"-\"`\n    Email    string `json:\"email,omitempty\"`\n}\n```\n\n### Разбор тегов\n\n- **json:\"username\"** — В JSON это поле будет называться **username** (а не **Name**).\n- **json:\"-\"** — Минус означает \"не включать в JSON вообще\". Идеально для паролей, токенов и секретов.\n- **json:\"email,omitempty\"** — Если поле пустое (нулевое значение), оно не попадет в JSON. Удобно, чтобы не засорять ответ полями типа \"email\": \"\".\n\n**Важно**: Поля должны начинаться с **Заглавной** буквы. Приватные поля (с маленькой буквы) пакет **json** просто не увидит — они не попадут ни в JSON, ни обратно.\n\n## Сериализация (Структура -> JSON)\n\nФункция **json.Marshal** превращает Go-структуру в срез байтов (JSON).\n\n```\nuser := User{\n    Name:     \"Alice\",\n    Age:      25,\n    Password: \"super_secret\",\n    Email:    \"alice@mail.com\",\n}\n\ndata, err := json.Marshal(user)\nif err != nil {\n    panic(err)\n}\n\nfmt.Println(string(data))\n// {\"username\":\"Alice\",\"age\":25,\"email\":\"alice@mail.com\"}\n```\n\n### Красивый вывод (MarshalIndent)\n\nДля отладки или логов удобно использовать **MarshalIndent** — он добавляет переносы строк и отступы.\n\n```\ndata, _ := json.MarshalIndent(user, \"\", \"  \")\nfmt.Println(string(data))\n// {\n//   \"username\": \"Alice\",\n//   \"age\": 25,\n//   \"email\": \"alice@mail.com\"\n// }\n```\n\n## Десериализация (JSON -> Структура)\n\nФункция **json.Unmarshal** делает обратное: берет JSON и заполняет структуру.\n\n```\njsonStr := `{\"username\": \"Bob\", \"age\": 40, \"email\": \"bob@mail.com\"}`\n\nvar user User\nerr := json.Unmarshal([]byte(jsonStr), &user)\nif err != nil {\n    fmt.Println(\"Ошибка парсинга:\", err)\n    return\n}\n\nfmt.Println(user.Name)  // Bob\nfmt.Println(user.Age)   // 40\nfmt.Println(user.Email) // bob@mail.com\n```\n\n**Обратите внимание**: Передаем **&user** (указатель), чтобы функция могла изменить нашу переменную. Без **&** Go создаст копию, заполнит её и выбросит.\n\n### Что если в JSON есть лишние поля?\n\nGo спокойно их проигнорирует. Это удобно: API может вернуть 20 полей, а вам нужны только 3.\n\n```\njsonStr := `{\"username\": \"Bob\", \"age\": 40, \"country\": \"USA\", \"phone\": \"+1234\"}`\n\nvar user User\njson.Unmarshal([]byte(jsonStr), &user)\n```\n\n## Потоковый JSON (Encoder/Decoder)\n\nЕсли вы работаете с **io.Writer** (HTTP-ответ, файл), удобнее использовать **json.Encoder**. Он пишет JSON напрямую в поток, без промежуточного создания **[]byte**.\n\n```\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    user := User{Name: \"Alice\", Age: 25}\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(user)\n}\n```\n\nАналогично **json.Decoder** читает JSON из **io.Reader**:\n\n```\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    var user User\n    json.NewDecoder(r.Body).Decode(&user)\n    fmt.Println(user.Name)\n}\n```\n\n## Итог\n\n1. Используйте **теги** **json:\"name\"**, чтобы управлять именами полей в JSON.\n2. **json:\"-\"** — скрыть поле (пароли, секреты).\n3. **json:\"field,omitempty\"** — не включать пустые значения.\n4. **Marshal** / **Unmarshal** — для работы с **[]byte**.\n5. **Encoder** / **Decoder** — для потоков (HTTP, файлы).\n"}