{"content":"\nХороший CLI-инструмент предсказуем и удобен: корректные коды завершения, правильные потоки вывода, обработка сигналов, прогресс для долгих операций. Эти паттерны встречаются в каждом серьёзном Go-инструменте.\n\n## Коды завершения\n\nПо стандарту Unix: **0** — успех, ненулевой код — ошибка. Никогда не выходите с кодом 0 при ошибке.\n\n```\nfunc main() {\n    if err := run(); err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n}\n\nfunc run() error {\n    // Вся логика здесь\n    if err := doWork(); err != nil {\n        return fmt.Errorf(\"работа завершилась с ошибкой: %w\", err)\n    }\n    return nil\n}\n```\n\nПаттерн **func run() error** в **main.go** — стандарт для Go CLI. Он позволяет использовать **defer** для очистки (в отличие от **os.Exit**) и тестировать логику без реального запуска.\n\n## Стандартные потоки вывода\n\n```\n// stdout — результат работы программы (можно перенаправить в файл)\nfmt.Println(\"user@example.com 30\")\n\n// stderr — диагностика, ошибки, прогресс (не мешает результату)\nfmt.Fprintln(os.Stderr, \"Подключение к базе данных...\")\nfmt.Fprintln(os.Stderr, \"Обработано 150 записей\")\n```\n\nПравило: если пользователь делает **myapp > output.txt**, в файл должен попасть только результат, а не сообщения о прогрессе.\n\n## Graceful shutdown по сигналу\n\nCLI-инструменты должны корректно завершаться по **Ctrl+C** (SIGINT) и **SIGTERM**:\n\n```\nfunc run() error {\n    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)\n    defer stop()\n\n    // Передаём контекст во все долгие операции\n    if err := processFiles(ctx, files); err != nil {\n        if errors.Is(err, context.Canceled) {\n            fmt.Fprintln(os.Stderr, \"\\nПрервано пользователем\")\n            return nil // Не ошибка, если пользователь нажал Ctrl+C\n        }\n        return err\n    }\n    return nil\n}\n```\n\n**signal.NotifyContext** (Go 1.16+) создаёт контекст, который отменяется при получении сигнала. Это элегантнее, чем вручную слушать канал сигналов.\n\n## Прогресс для долгих операций\n\nПростой прогресс через **\\r** (возврат каретки без новой строки):\n\n```\nfunc processWithProgress(items []string) {\n    total := len(items)\n    for i, item := range items {\n        fmt.Fprintf(os.Stderr, \"\\rОбработка: %d/%d (%s)...\", i+1, total, item)\n        process(item)\n    }\n    fmt.Fprintln(os.Stderr, \"\\rГотово!                        \")\n}\n```\n\nДля серьёзных инструментов используйте библиотеки вроде **github.com/schollz/progressbar/v3**:\n\n```\nbar := progressbar.Default(int64(len(items)))\nfor _, item := range items {\n    process(item)\n    bar.Add(1)\n}\n```\n\n## Цветной вывод\n\nЦвета полезны, но должны отключаться при выводе не в терминал:\n\n```\nimport \"github.com/fatih/color\"\n\n// color автоматически отключает цвета, если stdout — не терминал (NO_COLOR, CI)\ncolor.Green(\"✓ Успешно\")\ncolor.Red(\"✗ Ошибка\")\ncolor.Yellow(\"⚠ Предупреждение\")\n```\n\nИли минималистично через ANSI-коды:\n\n```\nconst (\n    colorReset  = \"\\033[0m\"\n    colorRed    = \"\\033[31m\"\n    colorGreen  = \"\\033[32m\"\n    colorYellow = \"\\033[33m\"\n)\n\nfunc isTerminal() bool {\n    fi, err := os.Stdout.Stat()\n    if err != nil {\n        return false\n    }\n    return (fi.Mode() & os.ModeCharDevice) != 0\n}\n```\n\n## Конфигурация: флаги → переменные окружения → файл конфига\n\nПорядок приоритетов в стандартных инструментах:\n\n```\ntype Config struct {\n    Host     string\n    Port     int\n    LogLevel string\n}\n\nfunc loadConfig(flags *Flags) Config {\n    cfg := Config{\n        // 1. Значения по умолчанию\n        Host:     \"localhost\",\n        Port:     8080,\n        LogLevel: \"info\",\n    }\n\n    // 2. Переменные окружения\n    if v := os.Getenv(\"APP_HOST\"); v != \"\" {\n        cfg.Host = v\n    }\n    if v := os.Getenv(\"APP_PORT\"); v != \"\" {\n        cfg.Port, _ = strconv.Atoi(v)\n    }\n\n    // 3. Флаги командной строки (наивысший приоритет)\n    if flags.Host != \"\" {\n        cfg.Host = flags.Host\n    }\n    if flags.Port != 0 {\n        cfg.Port = flags.Port\n    }\n\n    return cfg\n}\n```\n\nЭтот паттерн используют **kubectl**, **docker** и другие инструменты. Пользователь может настроить через env (в Docker/CI) или явным флагом.\n\n## Читаемый вывод таблиц\n\nДля вывода структурированных данных используйте выравнивание:\n\n```\nimport \"text/tabwriter\"\n\nfunc printUsers(users []User) {\n    w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)\n    fmt.Fprintln(w, \"ID\\tИМЯ\\tEMAIL\\tСТАТУС\")\n    fmt.Fprintln(w, \"--\\t---\\t-----\\t------\")\n    for _, u := range users {\n        fmt.Fprintf(w, \"%d\\t%s\\t%s\\t%s\\n\", u.ID, u.Name, u.Email, u.Status)\n    }\n    w.Flush()\n}\n```\n\nВывод:\n\n```\nID  ИМЯ      EMAIL              СТАТУС\n--  ---      -----              ------\n1   Alice    alice@example.com  active\n2   Bob      bob@example.com    inactive\n```\n\n## Итого\n\nХорошее CLI строится на простых принципах: **ошибки в stderr, результат в stdout**, корректные коды завершения, graceful shutdown через контекст. Паттерн **func run() error** в main — стандарт Go-сообщества, который делает код тестируемым и предсказуемым. Для конфигурации соблюдайте порядок приоритетов: **флаги > переменные окружения > файл конфига > значения по умолчанию**.\n"}