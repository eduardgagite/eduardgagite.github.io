{"content":"\nВ Go нет наследования (extends). Вообще. Создатели языка считают, что наследование создает больше проблем, чем решает (хрупкие иерархии, проблема ромба, тесная связанность).\n\nВместо него Go предлагает два мощных механизма:\n1. **Интерфейсы** — для полиморфизма (\"мне не важно что ты, важно что ты умеешь\").\n2. **Встраивание** — для переиспользования кода (композиция вместо наследования).\n\n## Интерфейсы\n\nИнтерфейс — это контракт. Он описывает **набор методов**, но не реализует их.\n\nКлючевая особенность Go: **интерфейсы реализуются неявно**. Вам не нужно писать **implements MyInterface**. Если структура имеет все методы интерфейса — она его реализует автоматически.\n\nЭто называется **утиная типизация** (Duck Typing): \"Если оно ходит как утка и крякает как утка — это утка\".\n\n### Пример\n\nСоздаем интерфейс **Speaker** — \"тот, кто умеет говорить\".\n\n```\ntype Speaker interface {\n    Speak() string\n}\n```\n\nЛюбой тип, у которого есть метод **Speak() string**, автоматически является **Speaker**.\n\n```\ntype Dog struct {\n    Name string\n}\n\nfunc (d Dog) Speak() string {\n    return d.Name + \" говорит: Гав!\"\n}\n\ntype Human struct {\n    Name string\n}\n\nfunc (h Human) Speak() string {\n    return h.Name + \" говорит: Привет!\"\n}\n```\n\nТеперь мы можем написать функцию, которая работает с **любым** Speaker.\n\n```\nfunc announce(s Speaker) {\n    fmt.Println(s.Speak())\n}\n\nfunc main() {\n    dog := Dog{Name: \"Бобик\"}\n    human := Human{Name: \"Алиса\"}\n\n    announce(dog)   // \"Бобик говорит: Гав!\"\n    announce(human) // \"Алиса говорит: Привет!\"\n}\n```\n\n### Зачем это нужно на практике?\n\nИнтерфейсы позволяют писать **гибкий и тестируемый** код.\n\nПредставьте: у вас есть сервис, который отправляет уведомления. Сегодня — по email, завтра — через Telegram, послезавтра — через SMS.\n\n```\ntype Notifier interface {\n    Send(message string) error\n}\n\ntype EmailNotifier struct { /* ... */ }\nfunc (e EmailNotifier) Send(message string) error { /* ... */ }\n\ntype TelegramNotifier struct { /* ... */ }\nfunc (t TelegramNotifier) Send(message string) error { /* ... */ }\n\nfunc NotifyUser(n Notifier, msg string) {\n    n.Send(msg)\n}\n```\n\nА в тестах вы можете подставить фейковый Notifier, который ничего не отправляет, а просто записывает сообщения.\n\n### Маленькие интерфейсы\n\nВ Go принято делать интерфейсы **маленькими** (1-2 метода). Стандартная библиотека полна таких примеров:\n\n- **io.Reader** — у кого есть метод **Read()**.\n- **io.Writer** — у кого есть метод **Write()**.\n- **fmt.Stringer** — у кого есть метод **String()**.\n- **error** — у кого есть метод **Error()**.\n\n### Пустой интерфейс (any)\n\nИнтерфейс без методов. Ему удовлетворяет **любой** тип.\n\n```\nvar x any\n\nx = 42\nx = \"строка\"\nx = true\nx = User{Name: \"Alice\"}\n```\n\nИспользуется в функциях, которые принимают \"что угодно\" (например, **fmt.Println**). Но злоупотреблять не стоит — вы теряете проверку типов на этапе компиляции.\n\n## Встраивание (Embedding)\n\nКак переиспользовать код без наследования? Через встраивание одной структуры в другую.\n\n```\ntype User struct {\n    Name  string\n    Email string\n}\n\nfunc (u *User) Greet() string {\n    return \"Привет, \" + u.Name\n}\n```\n\nХотим создать Admin, который умеет всё то же, что и User, плюс имеет уровень доступа.\n\n```\ntype Admin struct {\n    User\n    Level int\n}\n```\n\nТеперь Admin \"наследует\" поля и методы User.\n\n```\nfunc main() {\n    admin := Admin{\n        User:  User{Name: \"Иван\", Email: \"ivan@admin.com\"},\n        Level: 100,\n    }\n\n    fmt.Println(admin.Name)  // \"Иван\"\n    fmt.Println(admin.Email) // \"ivan@admin.com\"\n\n    fmt.Println(admin.Greet()) // \"Привет, Иван\"\n}\n```\n\n### Это не наследование!\n\nВажное отличие: Admin не является \"подтипом\" User. Вы **не можете** передать Admin туда, где ожидается User. Это именно **композиция** — Admin содержит User внутри себя.\n\nНо если есть интерфейс, который User реализует, то Admin тоже его реализует (потому что у него есть те же методы).\n\n## Итог\n\n1. **Интерфейсы** определяют поведение. Реализуются **неявно** — просто добавьте нужные методы.\n2. Делайте интерфейсы **маленькими** (1-2 метода).\n3. **Встраивание** заменяет наследование через композицию.\n4. **any** (пустой интерфейс) принимает что угодно, но лишает вас проверки типов.\n"}