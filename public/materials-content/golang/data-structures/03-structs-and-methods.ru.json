{"content":"\nВ Go нет классов (как в Java, Python или C#). Вместо них используются **структуры** (structs) — пользовательский тип данных, объединяющий несколько полей.\n\nЕсли переменная — это \"одна ячейка\" (число, строка), то структура — это \"карточка\" с несколькими полями. Например, карточка пользователя с именем, возрастом и email.\n\n## Объявление структуры\n\n```go\ntype User struct {\n    Name  string\n    Age   int\n    Email string\n}\n```\n\n`type` — создаем новый тип. `User` — его имя. `struct` — это структура с полями внутри.\n\n## Создание экземпляра\n\nЕсть несколько способов.\n\n### 1. По именам полей (рекомендуется)\n\n```go\nu := User{\n    Name:  \"Alice\",\n    Age:   30,\n    Email: \"alice@example.com\",\n}\n```\n\nЭтот способ самый надежный: если вы добавите новое поле в структуру, код не сломается.\n\n### 2. Частичное заполнение\n\n```go\nu := User{Name: \"Bob\"}\n// Age будет 0, Email будет \"\" (нулевые значения)\n```\n\n### 3. Пустая структура\n\n```go\nvar u User\n// Все поля — нулевые значения\nfmt.Println(u.Name) // \"\"\nfmt.Println(u.Age)  // 0\n```\n\n## Доступ к полям\n\nЧерез точку. Просто и понятно.\n\n```go\nfmt.Println(u.Name) // Чтение\nu.Age = 31          // Запись\n```\n\n## Методы\n\nСтруктура — это просто данные. Чтобы добавить **поведение** (функции, которые работают с этими данными), используются методы.\n\nМетод — это обычная функция, но с дополнительным параметром перед именем: **receiver** (получатель). Он привязывает функцию к конкретному типу.\n\n```go\nfunc (u User) Greet() string {\n    return fmt.Sprintf(\"Привет, я %s, мне %d лет\", u.Name, u.Age)\n}\n\nfunc main() {\n    alice := User{Name: \"Alice\", Age: 30}\n    fmt.Println(alice.Greet()) // \"Привет, я Alice, мне 30 лет\"\n}\n```\n\n## Value Receiver vs Pointer Receiver\n\nЭто **критически важный** момент. Когда вы пишете метод, у вас есть выбор: работать с копией данных или с оригиналом.\n\n### Value Receiver (Копия)\n\nПолучатель `(u User)` получает **копию** структуры. Любые изменения внутри метода **не затронут** оригинал.\n\n```go\nfunc (u User) SetAge(newAge int) {\n    u.Age = newAge // Меняем КОПИЮ\n}\n\nfunc main() {\n    bob := User{Name: \"Bob\", Age: 25}\n    bob.SetAge(100)\n    fmt.Println(bob.Age) // 25 — ничего не изменилось!\n}\n```\n\nИспользуйте Value Receiver, когда метод **только читает** данные и структура маленькая.\n\n### Pointer Receiver (Указатель на оригинал)\n\nПолучатель `(u *User)` — со звездочкой — получает **указатель** на оригинальную структуру. Изменения **сохранятся**.\n\n```go\nfunc (u *User) SetAge(newAge int) {\n    u.Age = newAge // Меняем оригинал!\n}\n\nfunc main() {\n    bob := User{Name: \"Bob\", Age: 25}\n    bob.SetAge(100)\n    fmt.Println(bob.Age) // 100 — теперь всё работает\n}\n```\n\n### Когда что использовать?\n\n**Правило**: Если сомневаетесь — используйте Pointer Receiver `*User`. Вот почему:\n1. Он позволяет менять данные.\n2. Он быстрее для больших структур (не нужно копировать все поля).\n3. **Консистентность**: Если хотя бы один метод использует `*User`, делайте все методы с `*User`.\n\n## Конструкторы\n\nВ Go нет встроенных конструкторов. Вместо них пишут обычные функции с префиксом `New`.\n\n```go\nfunc NewUser(name, email string) *User {\n    return &User{\n        Name:  name,\n        Email: email,\n        Age:   18, // Дефолтное значение\n    }\n}\n\nfunc main() {\n    user := NewUser(\"John\", \"john@mail.com\")\n    fmt.Println(user.Name) // John\n    fmt.Println(user.Age)  // 18\n}\n```\n\nКонструктор возвращает `*User` (указатель), чтобы:\n1. Не копировать структуру при возврате.\n2. Методы с Pointer Receiver работали сразу.\n\n## Итог\n\n1. **Структура** — это набор полей (данные).\n2. **Методы** — функции, привязанные к структуре (поведение).\n3. Если метод меняет данные — используйте **Pointer Receiver** `(u *User)`.\n4. Конструктор — это обычная функция `NewТип()`.\n"}