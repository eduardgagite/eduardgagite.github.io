{"content":"\nВ Go нет классов (как в Java, Python или C#). Вместо них используются **структуры** (structs) — пользовательский тип данных, объединяющий несколько полей.\n\nЕсли переменная — это \"одна ячейка\" (число, строка), то структура — это \"карточка\" с несколькими полями. Например, карточка пользователя с именем, возрастом и email.\n\n## Объявление структуры\n\n```\ntype User struct {\n    Name  string\n    Age   int\n    Email string\n}\n```\n\n**type** — создаем новый тип. **User** — его имя. **struct** — это структура с полями внутри.\n\n## Создание экземпляра\n\nЕсть несколько способов.\n\n### 1. По именам полей (рекомендуется)\n\n```\nu := User{\n    Name:  \"Alice\",\n    Age:   30,\n    Email: \"alice@example.com\",\n}\n```\n\nЭтот способ самый надежный: если вы добавите новое поле в структуру, код не сломается.\n\n### 2. Частичное заполнение\n\n```\nu := User{Name: \"Bob\"}\n```\n\n### 3. Пустая структура\n\n```\nvar u User\nfmt.Println(u.Name) // \"\"\nfmt.Println(u.Age)  // 0\n```\n\n## Доступ к полям\n\nЧерез точку. Просто и понятно.\n\n```\nfmt.Println(u.Name)\nu.Age = 31\n```\n\n## Методы\n\nСтруктура — это просто данные. Чтобы добавить **поведение** (функции, которые работают с этими данными), используются методы.\n\nМетод — это обычная функция, но с дополнительным параметром перед именем: **receiver** (получатель). Он привязывает функцию к конкретному типу.\n\n```\nfunc (u User) Greet() string {\n    return fmt.Sprintf(\"Привет, я %s, мне %d лет\", u.Name, u.Age)\n}\n\nfunc main() {\n    alice := User{Name: \"Alice\", Age: 30}\n    fmt.Println(alice.Greet()) // \"Привет, я Alice, мне 30 лет\"\n}\n```\n\n## Value Receiver vs Pointer Receiver\n\nЭто **критически важный** момент. Когда вы пишете метод, у вас есть выбор: работать с копией данных или с оригиналом.\n\n### Value Receiver (Копия)\n\nПолучатель **(u User)** получает **копию** структуры. Любые изменения внутри метода **не затронут** оригинал.\n\n```\nfunc (u User) SetAge(newAge int) {\n    u.Age = newAge\n}\n\nfunc main() {\n    bob := User{Name: \"Bob\", Age: 25}\n    bob.SetAge(100)\n    fmt.Println(bob.Age) // 25\n}\n```\n\nИспользуйте Value Receiver, когда метод **только читает** данные и структура маленькая.\n\n### Pointer Receiver (Указатель на оригинал)\n\nПолучатель **(u \\*User)** — со звездочкой — получает **указатель** на оригинальную структуру. Изменения **сохранятся**.\n\n```\nfunc (u *User) SetAge(newAge int) {\n    u.Age = newAge\n}\n\nfunc main() {\n    bob := User{Name: \"Bob\", Age: 25}\n    bob.SetAge(100)\n    fmt.Println(bob.Age) // 100\n}\n```\n\n### Когда что использовать?\n\n**Правило**: Если сомневаетесь — используйте Pointer Receiver **\\*User**. Вот почему:\n1. Он позволяет менять данные.\n2. Он быстрее для больших структур (не нужно копировать все поля).\n3. **Консистентность**: Если хотя бы один метод использует **\\*User**, делайте все методы с **\\*User**.\n\n## Конструкторы\n\nВ Go нет встроенных конструкторов. Вместо них пишут обычные функции с префиксом **New**.\n\n```\nfunc NewUser(name, email string) *User {\n    return &User{\n        Name:  name,\n        Email: email,\n        Age:   18,\n    }\n}\n\nfunc main() {\n    user := NewUser(\"John\", \"john@mail.com\")\n    fmt.Println(user.Name) // John\n    fmt.Println(user.Age)  // 18\n}\n```\n\nКонструктор возвращает **\\*User** (указатель), чтобы:\n1. Не копировать структуру при возврате.\n2. Методы с Pointer Receiver работали сразу.\n\n## Итог\n\n1. **Структура** — это набор полей (данные).\n2. **Методы** — функции, привязанные к структуре (поведение).\n3. Если метод меняет данные — используйте **Pointer Receiver** **(u \\*User)**.\n4. Конструктор — это обычная функция **NewТип()**.\n"}