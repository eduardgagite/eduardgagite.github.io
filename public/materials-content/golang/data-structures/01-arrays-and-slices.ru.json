{"content":"\nКогда нам нужно хранить список данных (имена пользователей, цены товаров, результаты запросов), мы используем коллекции. В Go для этого есть два типа: **массивы** (Array) и **срезы** (Slice).\n\nГлавное правило: **в 99% случаев вы будете использовать срезы**. Массивы — это низкоуровневая деталь, на которой срезы построены.\n\n## Массив (Array)\n\nМассив — это коробка фиксированного размера. Вы сразу говорите: \"Мне нужно место ровно для 5 элементов\". Ни больше, ни меньше.\n\n```go\n// Массив из 5 целых чисел\nvar arr [5]int\n\narr[0] = 100\narr[1] = 200\nfmt.Println(arr) // [100 200 0 0 0]\n```\n\n### Почему массивы неудобны\n\n1. **Размер зашит в тип**. `[5]int` и `[10]int` — это **разные** типы данных. Вы не можете передать `[5]int` туда, где ожидается `[10]int`.\n2. **Нельзя добавить элемент**. Коробка не растягивается. Если вам нужен 6-й элемент — создавайте новый массив побольше и копируйте данные.\n3. **Копирование**. Когда вы передаете массив в функцию, он **полностью копируется**. Для массива из миллиона элементов это медленно и расточительно.\n\n## Срез (Slice)\n\nСрез — это \"умная обертка\" над массивом. Он умеет расти, уменьшаться и работает как динамический список (аналог `ArrayList` в Java, `list` в Python, `Array` в JS).\n\n### Создание среза\n\nОбратите внимание: в квадратных скобках **пусто** `[]`. Это отличает срез от массива `[5]`.\n\n```go\n// 1. Литерал (сразу с данными)\nusers := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\n// 2. Пустой срез через make\n// make([]тип, длина)\nnumbers := make([]int, 5) // [0 0 0 0 0]\n\n// 3. Пустой срез через make с емкостью\n// make([]тип, длина, емкость)\nbuffer := make([]int, 0, 100) // Длина 0, но место зарезервировано под 100\n```\n\nЗачем третий вариант? Если вы знаете примерный размер данных, можно сразу выделить память. Это ускоряет работу, потому что Go не будет пересоздавать массив при каждом `append`.\n\n### Добавление элементов (append)\n\n```go\nvar tasks []string\n\ntasks = append(tasks, \"Купить хлеб\")\ntasks = append(tasks, \"Помыть кота\", \"Выучить Go\") // Можно сразу несколько\n\nfmt.Println(tasks) // [Купить хлеб Помыть кота Выучить Go]\nfmt.Println(len(tasks)) // 3 (длина — сколько элементов)\nfmt.Println(cap(tasks)) // 4 (емкость — сколько Go выделил про запас)\n```\n\n**Важно**: `append` возвращает **новый** срез. Всегда присваивайте результат: `tasks = append(tasks, ...)`. Если забудете `tasks =`, элемент потеряется.\n\n### Перебор (range)\n\n```go\nnames := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\nfor i, name := range names {\n    fmt.Printf(\"%d: %s\\n\", i, name)\n}\n// 0: Alice\n// 1: Bob\n// 2: Charlie\n\n// Если индекс не нужен\nfor _, name := range names {\n    fmt.Println(name)\n}\n```\n\n### Взятие части среза (Slicing)\n\nВы можете \"вырезать\" кусок. Синтаксис: `slice[start:end]`.\n- `start` — начало (включительно).\n- `end` — конец (**не** включительно).\n\n```go\nalphabet := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\npart := alphabet[1:3]  // [\"b\", \"c\"]\nfirst := alphabet[:2]  // [\"a\", \"b\"] (от начала)\nlast := alphabet[2:]   // [\"c\", \"d\", \"e\"] (до конца)\n```\n\n### Удаление элемента\n\nВ Go нет встроенной функции \"удалить элемент из среза\". Это делается через append и slicing.\n\n```go\ns := []string{\"a\", \"b\", \"c\", \"d\"}\n\n// Удаляем элемент с индексом 2 (\"c\")\ns = append(s[:2], s[3:]...)\nfmt.Println(s) // [\"a\", \"b\", \"d\"]\n```\n\n## Как устроен срез внутри\n\nСрез — это не сами данные. Это маленькая структура из трёх полей:\n1. **Указатель** на скрытый массив, где лежат данные.\n2. **Длина** (`len`): сколько элементов мы используем.\n3. **Ёмкость** (`cap`): сколько места в скрытом массиве.\n\nКогда вы вызываете `append`, а места в скрытом массиве нет, Go:\n1. Создает новый массив в 2 раза больше.\n2. Копирует старые данные туда.\n3. Возвращает срез, указывающий на новый массив.\n\n### Ловушка: Общая память\n\nКогда вы делаете подсрез `b := a[1:3]`, новый срез `b` **смотрит на тот же массив**, что и `a`.\n\n```go\noriginal := []int{10, 20, 30}\nsub := original[0:2] // [10, 20]\n\nsub[0] = 999 // Меняем sub...\n\nfmt.Println(original) // [999 20 30] — ...но оригинал тоже изменился!\n```\n\nЕсли нужна независимая копия:\n\n```go\noriginal := []int{10, 20, 30}\nclone := make([]int, len(original))\ncopy(clone, original) // Теперь clone — отдельная копия\n```\n\n## Итог\n\n1. **Массив** `[5]int`: Размер фиксирован. На практике используется редко.\n2. **Срез** `[]int`: Динамический размер. Используется повсеместно.\n3. Добавляем через `slice = append(slice, val)`.\n4. Помните про общую память при создании подсрезов.\n5. Используйте `make([]T, 0, capacity)`, если знаете примерный размер.\n"}