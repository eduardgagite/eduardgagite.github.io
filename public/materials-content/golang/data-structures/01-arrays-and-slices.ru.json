{"content":"\nКогда нам нужно хранить список данных (имена пользователей, цены товаров, результаты запросов), мы используем коллекции. В Go для этого есть два типа: **массивы** (Array) и **срезы** (Slice).\n\nГлавное правило: **в 99% случаев вы будете использовать срезы**. Массивы — это низкоуровневая деталь, на которой срезы построены.\n\n## Массив (Array)\n\nМассив — это коробка фиксированного размера. Вы сразу говорите: \"Мне нужно место ровно для 5 элементов\". Ни больше, ни меньше.\n\n```\nvar arr [5]int\n\narr[0] = 100\narr[1] = 200\nfmt.Println(arr) // [100 200 0 0 0]\n```\n\n### Почему массивы неудобны\n\n1. **Размер зашит в тип**. **[5]int** и **[10]int** — это **разные** типы данных. Вы не можете передать **[5]int** туда, где ожидается **[10]int**.\n2. **Нельзя добавить элемент**. Коробка не растягивается. Если вам нужен 6-й элемент — создавайте новый массив побольше и копируйте данные.\n3. **Копирование**. Когда вы передаете массив в функцию, он **полностью копируется**. Для массива из миллиона элементов это медленно и расточительно.\n\n## Срез (Slice)\n\nСрез — это \"умная обертка\" над массивом. Он умеет расти, уменьшаться и работает как динамический список (аналог **ArrayList** в Java, **list** в Python, **Array** в JS).\n\n### Создание среза\n\nОбратите внимание: в квадратных скобках **пусто** **[]**. Это отличает срез от массива **[5]**.\n\n```\nusers := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\nnumbers := make([]int, 5) // [0 0 0 0 0]\n\nbuffer := make([]int, 0, 100)\n```\n\nЗачем третий вариант? Если вы знаете примерный размер данных, можно сразу выделить память. Это ускоряет работу, потому что Go не будет пересоздавать массив при каждом **append**.\n\n### Добавление элементов (append)\n\n```\nvar tasks []string\n\ntasks = append(tasks, \"Купить хлеб\")\ntasks = append(tasks, \"Помыть кота\", \"Выучить Go\")\n\nfmt.Println(tasks) // [Купить хлеб Помыть кота Выучить Go]\nfmt.Println(len(tasks)) // 3\nfmt.Println(cap(tasks)) // 4\n```\n\n**Важно**: **append** возвращает **новый** срез. Всегда присваивайте результат: **tasks = append(tasks, ...)**. Если забудете **tasks =**, элемент потеряется.\n\n### Перебор (range)\n\n```\nnames := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\nfor i, name := range names {\n    fmt.Printf(\"%d: %s\\n\", i, name)\n}\n// 0: Alice\n// 1: Bob\n// 2: Charlie\n\nfor _, name := range names {\n    fmt.Println(name)\n}\n```\n\n### Взятие части среза (Slicing)\n\nВы можете \"вырезать\" кусок. Синтаксис: **slice[start:end]**.\n- **start** — начало (включительно).\n- **end** — конец (**не** включительно).\n\n```\nalphabet := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\npart := alphabet[1:3]  // [\"b\", \"c\"]\nfirst := alphabet[:2]  // [\"a\", \"b\"]\nlast := alphabet[2:]   // [\"c\", \"d\", \"e\"]\n```\n\n### Удаление элемента\n\nВ Go нет встроенной функции \"удалить элемент из среза\". Это делается через append и slicing.\n\n```\ns := []string{\"a\", \"b\", \"c\", \"d\"}\n\ns = append(s[:2], s[3:]...)\nfmt.Println(s) // [\"a\", \"b\", \"d\"]\n```\n\n## Как устроен срез внутри\n\nСрез — это не сами данные. Это маленькая структура из трёх полей:\n1. **Указатель** на скрытый массив, где лежат данные.\n2. **Длина** (**len**): сколько элементов мы используем.\n3. **Ёмкость** (**cap**): сколько места в скрытом массиве.\n\nКогда вы вызываете **append**, а места в скрытом массиве нет, Go:\n1. Создает новый массив в 2 раза больше.\n2. Копирует старые данные туда.\n3. Возвращает срез, указывающий на новый массив.\n\n### Ловушка: Общая память\n\nКогда вы делаете подсрез **b := a[1:3]**, новый срез **b** **смотрит на тот же массив**, что и **a**.\n\n```\noriginal := []int{10, 20, 30}\nsub := original[0:2] // [10, 20]\n\nsub[0] = 999\n\nfmt.Println(original) // [999 20 30]\n```\n\nЕсли нужна независимая копия:\n\n```\noriginal := []int{10, 20, 30}\nclone := make([]int, len(original))\ncopy(clone, original)\n```\n\n## Итог\n\n1. **Массив** **[5]int**: Размер фиксирован. На практике используется редко.\n2. **Срез** **[]int**: Динамический размер. Используется повсеместно.\n3. Добавляем через **slice = append(slice, val)**.\n4. Помните про общую память при создании подсрезов.\n5. Используйте **make([]T, 0, capacity)**, если знаете примерный размер.\n"}