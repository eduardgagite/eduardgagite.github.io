{"content":"\nКарта (map) — это структура данных, которая хранит пары **\"Ключ — Значение\"**. Другие названия: словарь (dict в Python), хеш-таблица, ассоциативный массив.\n\nВ отличие от среза, где доступ идет по индексу (0, 1, 2...), в карте вы достаете данные по ключу (по имени, ID, email — чему угодно).\n\nПример из жизни: телефонная книга. Ключ — имя человека, значение — номер телефона.\n\n## Создание карты\n\n### Через make (пустая карта)\n\n```go\n// map[ТипКлюча]ТипЗначения\nprices := make(map[string]int)\n\nprices[\"apple\"] = 100\nprices[\"banana\"] = 200\n\nfmt.Println(prices) // map[apple:100 banana:200]\n```\n\n### Через литерал (сразу с данными)\n\n```go\nroles := map[string]string{\n    \"admin\":  \"Super User\",\n    \"editor\": \"Content Manager\",\n    \"viewer\": \"Read Only\",\n}\n```\n\n### Важно: nil карта\n\nЕсли объявить карту без `make`, она будет `nil`. Читать из неё можно (вернутся нулевые значения), но **запись вызовет панику**.\n\n```go\nvar m map[string]int\nfmt.Println(m[\"key\"]) // 0 — ок, читать можно\n\nm[\"key\"] = 1 // PANIC: assignment to entry in nil map\n```\n\nВывод: **всегда инициализируйте карту** через `make` или литерал.\n\n## Основные операции\n\n### Запись и чтение\n\n```go\nusers := make(map[int]string)\n\n// Запись\nusers[1] = \"Alice\"\nusers[2] = \"Bob\"\n\n// Чтение\nname := users[1] // \"Alice\"\n```\n\n### Проверка: есть ключ или нет? (ok-идиома)\n\nЕсли ключа нет, карта вернет нулевое значение типа (0 для int, \"\" для string). Но как отличить \"значение действительно 0\" от \"ключа нет\"?\n\nИспользуйте вторую переменную `ok`.\n\n```go\nprices := map[string]int{\n    \"apple\":  100,\n    \"banana\": 0, // Бесплатный банан!\n}\n\nval, ok := prices[\"banana\"]\nfmt.Println(val, ok) // 0, true — ключ есть, цена просто 0\n\nval, ok = prices[\"cherry\"]\nfmt.Println(val, ok) // 0, false — ключа нет вообще\n```\n\nЧастый паттерн:\n\n```go\nif price, ok := prices[\"apple\"]; ok {\n    fmt.Println(\"Цена яблока:\", price)\n} else {\n    fmt.Println(\"Яблок нет в наличии\")\n}\n```\n\n### Удаление\n\nВстроенная функция `delete`. Безопасна: если ключа нет, ничего не произойдет.\n\n```go\ndelete(prices, \"apple\")\ndelete(prices, \"nonexistent\") // Ошибки не будет\n```\n\n### Количество элементов\n\n```go\nfmt.Println(len(prices)) // Количество пар ключ-значение\n```\n\n## Перебор карты\n\n```go\nfor key, value := range prices {\n    fmt.Printf(\"%s: %d руб.\\n\", key, value)\n}\n```\n\n**Важно**: Порядок перебора — **случайный**. Каждый раз он может быть разным. Это сделано специально, чтобы вы не зависели от порядка. Если нужна сортировка — сначала соберите ключи в срез и отсортируйте.\n\n```go\n// Если нужен стабильный порядок\nkeys := make([]string, 0, len(prices))\nfor k := range prices {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\n\nfor _, k := range keys {\n    fmt.Printf(\"%s: %d\\n\", k, prices[k])\n}\n```\n\n## Карта как множество (Set)\n\nВ Go нет встроенного типа \"множество\" (Set). Но его легко сымитировать картой с `bool` значениями.\n\n```go\n// Множество уникальных тегов\ntags := map[string]bool{\n    \"go\":     true,\n    \"docker\": true,\n}\n\n// Проверка принадлежности\nif tags[\"go\"] {\n    fmt.Println(\"Тег 'go' есть\")\n}\n\n// Добавление\ntags[\"kubernetes\"] = true\n```\n\n## Ограничения ключей\n\nКлючом может быть любой тип, который поддерживает операцию `==`:\n- Строки, числа, булевы значения.\n- Структуры (если все их поля сравнимы).\n\n**Не могут** быть ключами:\n- Срезы.\n- Карты.\n- Функции.\n\n## Итог\n\n1. Карта хранит пары `ключ:значение`. Создавайте через `make` или литерал.\n2. Проверяйте наличие ключа через `val, ok := m[key]`.\n3. Порядок перебора — случайный. Если нужна сортировка — сортируйте ключи отдельно.\n4. `map[string]bool` — простой способ сделать множество (Set).\n"}