{"content":"\nКарта (map) — это структура данных, которая хранит пары **\"Ключ — Значение\"**. Другие названия: словарь (dict в Python), хеш-таблица, ассоциативный массив.\n\nВ отличие от среза, где доступ идет по индексу (0, 1, 2...), в карте вы достаете данные по ключу (по имени, ID, email — чему угодно).\n\nПример из жизни: телефонная книга. Ключ — имя человека, значение — номер телефона.\n\n## Создание карты\n\n### Через make (пустая карта)\n\n```\nprices := make(map[string]int)\n\nprices[\"apple\"] = 100\nprices[\"banana\"] = 200\n\nfmt.Println(prices) // map[apple:100 banana:200]\n```\n\n### Через литерал (сразу с данными)\n\n```\nroles := map[string]string{\n    \"admin\":  \"Super User\",\n    \"editor\": \"Content Manager\",\n    \"viewer\": \"Read Only\",\n}\n```\n\n### Важно: nil карта\n\nЕсли объявить карту без **make**, она будет **nil**. Читать из неё можно (вернутся нулевые значения), но **запись вызовет панику**.\n\n```\nvar m map[string]int\nfmt.Println(m[\"key\"]) // 0\n\nm[\"key\"] = 1 // PANIC: assignment to entry in nil map\n```\n\nВывод: **всегда инициализируйте карту** через **make** или литерал.\n\n## Основные операции\n\n### Запись и чтение\n\n```\nusers := make(map[int]string)\n\nusers[1] = \"Alice\"\nusers[2] = \"Bob\"\n\nname := users[1] // \"Alice\"\n```\n\n### Проверка: есть ключ или нет? (ok-идиома)\n\nЕсли ключа нет, карта вернет нулевое значение типа (0 для int, \"\" для string). Но как отличить \"значение действительно 0\" от \"ключа нет\"?\n\nИспользуйте вторую переменную **ok**.\n\n```\nprices := map[string]int{\n    \"apple\":  100,\n    \"banana\": 0,\n}\n\nval, ok := prices[\"banana\"]\nfmt.Println(val, ok) // 0, true\n\nval, ok = prices[\"cherry\"]\nfmt.Println(val, ok) // 0, false\n```\n\nЧастый паттерн:\n\n```\nif price, ok := prices[\"apple\"]; ok {\n    fmt.Println(\"Цена яблока:\", price)\n} else {\n    fmt.Println(\"Яблок нет в наличии\")\n}\n```\n\n### Удаление\n\nВстроенная функция **delete**. Безопасна: если ключа нет, ничего не произойдет.\n\n```\ndelete(prices, \"apple\")\ndelete(prices, \"nonexistent\")\n```\n\n### Количество элементов\n\n```\nfmt.Println(len(prices))\n```\n\n## Перебор карты\n\n```\nfor key, value := range prices {\n    fmt.Printf(\"%s: %d руб.\\n\", key, value)\n}\n```\n\n**Важно**: Порядок перебора — **случайный**. Каждый раз он может быть разным. Это сделано специально, чтобы вы не зависели от порядка. Если нужна сортировка — сначала соберите ключи в срез и отсортируйте.\n\n```\nkeys := make([]string, 0, len(prices))\nfor k := range prices {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\n\nfor _, k := range keys {\n    fmt.Printf(\"%s: %d\\n\", k, prices[k])\n}\n```\n\n## Карта как множество (Set)\n\nВ Go нет встроенного типа \"множество\" (Set). Но его легко сымитировать картой с **bool** значениями.\n\n```\ntags := map[string]bool{\n    \"go\":     true,\n    \"docker\": true,\n}\n\nif tags[\"go\"] {\n    fmt.Println(\"Тег 'go' есть\")\n}\n\ntags[\"kubernetes\"] = true\n```\n\n## Ограничения ключей\n\nКлючом может быть любой тип, который поддерживает операцию **==**:\n- Строки, числа, булевы значения.\n- Структуры (если все их поля сравнимы).\n\n**Не могут** быть ключами:\n- Срезы.\n- Карты.\n- Функции.\n\n## Итог\n\n1. Карта хранит пары **ключ:значение**. Создавайте через **make** или литерал.\n2. Проверяйте наличие ключа через **val, ok := m[key]**.\n3. Порядок перебора — случайный. Если нужна сортировка — сортируйте ключи отдельно.\n4. **map[string]bool** — простой способ сделать множество (Set).\n"}