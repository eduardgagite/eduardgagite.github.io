{"content":"\nДо версии 1.18 в Go не было дженериков (обобщённых типов). Если нужна была функция \"найди минимум\", приходилось писать отдельную версию для **int**, отдельную для **float64**, отдельную для **string**. Или использовать **interface{}** и терять проверку типов на этапе компиляции.\n\nНачиная с Go 1.18, дженерики — часть языка. Они позволяют писать функции и структуры, которые работают с **любым подходящим типом**, сохраняя при этом строгую типизацию.\n\n## Проблема без дженериков\n\nДопустим, нужна функция, возвращающая минимум из двух значений.\n\n```\nfunc MinInt(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc MinFloat(a, b float64) float64 {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\nЛогика одинаковая, но код дублируется. С дженериками — одна функция вместо двух.\n\n## Обобщённые функции\n\nТип-параметр указывается в квадратных скобках после имени функции.\n\n```\nfunc Min[T int | float64 | string](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    fmt.Println(Min(3, 7))               // 3\n    fmt.Println(Min(3.14, 2.71))         // 2.71\n    fmt.Println(Min(\"apple\", \"banana\"))  // \"apple\"\n}\n```\n\n**T** — это тип-параметр. Запись **T int | float64 | string** означает: \"T может быть int, float64 или string\". При вызове Go сам определяет конкретный тип по переданным аргументам.\n\n## Ограничения типов (Type Constraints)\n\nПеречислять типы через **|** в каждой функции неудобно. Для этого создают интерфейсы-ограничения.\n\n```\ntype Number interface {\n    int | int8 | int16 | int32 | int64 |\n    float32 | float64\n}\n\nfunc Sum[T Number](values []T) T {\n    var total T\n    for _, v := range values {\n        total += v\n    }\n    return total\n}\n\nfunc main() {\n    ints := []int{1, 2, 3, 4, 5}\n    fmt.Println(Sum(ints)) // 15\n\n    floats := []float64{1.1, 2.2, 3.3}\n    fmt.Println(Sum(floats)) // 6.6\n}\n```\n\n### Встроенные ограничения\n\nПакет **constraints** (из стандартной библиотеки **golang.org/x/exp** или встроенный **cmp**) предоставляет готовые ограничения, чтобы не перечислять типы вручную.\n\nСамые полезные:\n\n- **comparable** — типы, которые можно сравнивать через **==** и **!=** (встроен в язык).\n- **cmp.Ordered** — типы, которые поддерживают операторы **<**, **>**, **<=**, **>=**.\n\n```\nimport \"cmp\"\n\nfunc Min[T cmp.Ordered](a, b T) T {\n    if a < b {\n        return a\n    }\n    return b\n}\n```\n\nТеперь **Min** работает с любым упорядоченным типом: **int**, **float64**, **string** и их вариациями.\n\n## Обобщённые структуры\n\nДженерики работают и со структурами. Классический пример — стек, который хранит элементы любого типа.\n\n```\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\nfunc main() {\n    intStack := Stack[int]{}\n    intStack.Push(10)\n    intStack.Push(20)\n    val, _ := intStack.Pop()\n    fmt.Println(val) // 20\n\n    strStack := Stack[string]{}\n    strStack.Push(\"hello\")\n}\n```\n\nОграничение **any** означает \"любой тип\". Для стека этого достаточно — мы не сравниваем и не складываем элементы, просто храним.\n\n## Практический пример: фильтрация среза\n\n```\nfunc Filter[T any](items []T, fn func(T) bool) []T {\n    var result []T\n    for _, item := range items {\n        if fn(item) {\n            result = append(result, item)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}\n\n    even := Filter(numbers, func(n int) bool {\n        return n%2 == 0\n    })\n    fmt.Println(even) // [2, 4, 6, 8]\n\n    words := []string{\"Go\", \"is\", \"awesome\", \"language\"}\n    long := Filter(words, func(s string) bool {\n        return len(s) > 2\n    })\n    fmt.Println(long) // [\"awesome\", \"language\"]\n}\n```\n\nОдна функция **Filter** работает и с числами, и со строками, и с любыми другими типами.\n\n## Стандартная библиотека: пакеты slices и maps\n\nНачиная с Go 1.21, в стандартной библиотеке появились обобщённые функции для работы со срезами и картами.\n\n```\nimport \"slices\"\n\nnumbers := []int{3, 1, 4, 1, 5, 9}\nslices.Sort(numbers)             // [1, 1, 3, 4, 5, 9]\nslices.Contains(numbers, 5)      // true\nidx := slices.Index(numbers, 4)  // 2\n```\n\n```\nimport \"maps\"\n\nm := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}\nkeys := maps.Keys(m)\nmaps.DeleteFunc(m, func(k string, v int) bool {\n    return v < 2\n})\n```\n\n## Когда использовать дженерики\n\n**Используйте**, когда:\n- Логика функции одинакова для разных типов (контейнеры, утилиты для срезов, карт).\n- Нужно избежать дублирования кода без потери типобезопасности.\n\n**Не используйте**, когда:\n- Работаете с одним конкретным типом — дженерики только усложнят код.\n- Можно обойтись интерфейсом с методами. Если поведение определяется методами (Reader, Writer), интерфейс — лучший выбор.\n\n## Итог\n\nДженерики позволяют писать функции и структуры, параметризованные типами. Ограничения задают, какие типы допустимы: **any** — любой, **comparable** — сравниваемые, **cmp.Ordered** — упорядоченные. **Используйте дженерики для утилитарного кода (коллекции, фильтры, трансформации), но не превращайте весь проект в абстрактную фабрику абстракций.**\n"}