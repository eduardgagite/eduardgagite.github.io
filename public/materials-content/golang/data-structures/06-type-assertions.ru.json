{"content":"\nИнтерфейсы в Go хранят значения любого типа, реализующего нужный набор методов. Но иногда нужно узнать конкретный тип за интерфейсом и получить доступ к его специфическим методам. Для этого существуют **type assertion** и **type switch**.\n\n## Type assertion — проверка и извлечение типа\n\nЕсли у вас есть значение типа **interface{}** (или любого другого интерфейса) и вы хотите получить конкретный тип, используйте **type assertion**:\n\n```\nvar i interface{} = \"hello\"\n\ns := i.(string)\nfmt.Println(s) // hello\n```\n\nЗапись **i.(string)** означает: \"Я утверждаю, что внутри **i** лежит значение типа **string**. Достань его.\"\n\nЕсли утверждение неверно, программа запаникует:\n\n```\nvar i interface{} = 42\ns := i.(string) // panic: interface conversion: interface {} is int, not string\n```\n\n### Безопасная форма — с двумя возвращаемыми значениями\n\nЧтобы не получить panic, используйте форму с двумя значениями:\n\n```\nvar i interface{} = 42\n\ns, ok := i.(string)\nif !ok {\n    fmt.Println(\"Это не строка\")\n    return\n}\nfmt.Println(s)\n```\n\n**ok** будет **false** если тип не совпадает, а **s** получит нулевое значение для своего типа. Паника не произойдёт. Всегда используйте эту форму при работе с динамическими данными.\n\n## Type switch — удобный выбор по типу\n\nКогда нужно обработать несколько возможных типов, **type switch** удобнее цепочки **if-else**:\n\n```\nfunc describe(i interface{}) string {\n    switch v := i.(type) {\n    case int:\n        return fmt.Sprintf(\"int: %d\", v)\n    case string:\n        return fmt.Sprintf(\"string: %q\", v)\n    case bool:\n        return fmt.Sprintf(\"bool: %t\", v)\n    case []int:\n        return fmt.Sprintf(\"[]int с длиной %d\", len(v))\n    default:\n        return fmt.Sprintf(\"неизвестный тип: %T\", v)\n    }\n}\n```\n\nСинтаксис **switch v := i.(type)** — это специальная форма, которая работает только в **switch**. Переменная **v** внутри каждого кейса имеет именно тот тип, который указан в **case**.\n\n## Практический пример: обработка ошибок по типу\n\nСамый частый use-case — разбор ошибок. В Go ошибки — это интерфейс, и конкретный тип ошибки несёт дополнительную информацию:\n\n```\ntype NotFoundError struct {\n    Resource string\n    ID       int\n}\n\nfunc (e *NotFoundError) Error() string {\n    return fmt.Sprintf(\"%s с ID %d не найден\", e.Resource, e.ID)\n}\n\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"поле %s: %s\", e.Field, e.Message)\n}\n\nfunc handleError(err error) {\n    switch e := err.(type) {\n    case *NotFoundError:\n        fmt.Printf(\"404: %s\\n\", e.Resource)\n    case *ValidationError:\n        fmt.Printf(\"400: некорректное поле %s\\n\", e.Field)\n    default:\n        fmt.Printf(\"500: %v\\n\", err)\n    }\n}\n```\n\n## errors.As — идиоматичный способ в современном Go\n\nНачиная с Go 1.13, для работы с цепочками ошибок (wrapped errors) рекомендуется **errors.As** вместо type assertion:\n\n```\nvar notFound *NotFoundError\n\nif errors.As(err, &notFound) {\n    fmt.Printf(\"Ресурс не найден: %s\\n\", notFound.Resource)\n}\n```\n\n**errors.As** ищет ошибку нужного типа в цепочке обёрток. Это важно, когда ошибка обёрнута через **fmt.Errorf(\"...: %w\", err)**.\n\n## Интерфейс any и пустой интерфейс\n\nВ Go 1.18 появился псевдоним **any** для **interface{}**:\n\n```\nfunc printValue(v any) {\n    switch val := v.(type) {\n    case string:\n        fmt.Println(\"строка:\", val)\n    case int:\n        fmt.Println(\"число:\", val)\n    default:\n        fmt.Printf(\"тип %T: %v\\n\", val, val)\n    }\n}\n```\n\nПредпочитайте **any** вместо **interface{}** в новом коде — это стандарт с Go 1.18.\n\n## Когда использовать, а когда нет\n\nType assertion уместен, когда:\n- Вы работаете с ошибками и нужно достать специфические поля.\n- Вы пишете универсальный код (сериализация, логирование, тесты).\n- Интерфейс намеренно скрывает конкретный тип.\n\nНе нужен, когда:\n- Вы постоянно приводите к конкретному типу — лучше использовать этот тип напрямую.\n- Дженерики решают задачу лучше (с Go 1.18+).\n\n## Итого\n\n**Type assertion** позволяет достать конкретный тип из интерфейса, а **type switch** — элегантно обработать несколько вариантов. **Всегда используйте безопасную форму с ok**, если не уверены в типе. Для ошибок с Go 1.13+ используйте **errors.As** — это правильный идиоматичный способ проверки типа ошибки в цепочке обёрток.\n"}