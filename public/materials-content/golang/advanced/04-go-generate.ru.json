{"content":"\nКодогенерация — написание программ, которые пишут другие программы. В Go это первоклассный инструмент: команда **go generate** запускает генераторы прямо из исходного кода. Сгенерированный код затем компилируется как обычный Go.\n\n## Что такое go generate\n\n**go generate** — не магия. Это просто способ запустить произвольную команду из директивы в исходнике:\n\n```\n//go:generate stringer -type=Direction\n```\n\nКогда вы запускаете **go generate ./...**, Go находит такие комментарии и выполняет указанные команды. Генераторы создают **.go** файлы, которые попадают в компиляцию.\n\nДиректива всегда начинается с **//go:generate** (без пробела) и содержит команду.\n\n## Пример: stringer для читаемого вывода enum\n\nУтилита **stringer** автоматически генерирует метод **String()** для типов с **iota**:\n\n```\ngo install golang.org/x/tools/cmd/stringer@latest\n```\n\nВ файле **direction.go**:\n\n```\npackage main\n\n//go:generate stringer -type=Direction\n\ntype Direction int\n\nconst (\n    North Direction = iota\n    South\n    East\n    West\n)\n```\n\nПосле запуска **go generate** появится файл **direction_string.go**:\n\n```\n// Code generated by stringer -type=Direction; DO NOT EDIT.\n\nfunc (i Direction) String() string {\n    switch i {\n    case North:\n        return \"North\"\n    case South:\n        return \"South\"\n    case East:\n        return \"East\"\n    case West:\n        return \"West\"\n    default:\n        return fmt.Sprintf(\"Direction(%d)\", int(i))\n    }\n}\n```\n\nТеперь **fmt.Println(North)** выведет **\"North\"**, а не **\"0\"**.\n\n## Пример: mockgen для тестовых моков\n\n**mockgen** генерирует мок-реализации интерфейсов для тестов:\n\n```\ngo install go.uber.org/mock/mockgen@latest\n```\n\nДля интерфейса **UserRepository**:\n\n```\n//go:generate mockgen -source=repository.go -destination=mock_repository.go -package=service\ntype UserRepository interface {\n    GetUser(ctx context.Context, id int) (*User, error)\n    CreateUser(ctx context.Context, u *User) error\n}\n```\n\nГенерирует файл с мок-объектом, который используется в тестах без реального подключения к базе.\n\n## Пример: sqlc — генерация Go-кода из SQL\n\n**sqlc** генерирует типобезопасный Go-код из SQL-запросов:\n\n```\ngo install github.com/sqlc-dev/sqlc/cmd/sqlc@latest\n```\n\nВы пишете SQL:\n\n```\n-- name: GetUser :one\nSELECT id, name, email FROM users WHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email FROM users;\n```\n\n**sqlc** генерирует:\n\n```\nfunc (q *Queries) GetUser(ctx context.Context, id int64) (User, error) { ... }\nfunc (q *Queries) ListUsers(ctx context.Context) ([]User, error) { ... }\n```\n\nНикаких **interface{}**, никаких ошибок в именах колонок — всё проверяется на этапе генерации.\n\n## Соглашения\n\nСгенерированные файлы принято помечать заголовком:\n\n```\n// Code generated by <tool>. DO NOT EDIT.\n```\n\nЭто сигнал для разработчиков и инструментов (линтеров, code review) не редактировать файл вручную.\n\nПо соглашению имена сгенерированных файлов часто содержат **_gen.go** или **_string.go** суффиксы.\n\n## Как запускать\n\n```\n# Для текущего пакета\ngo generate\n\n# Для всех пакетов в модуле\ngo generate ./...\n\n# С выводом команд\ngo generate -v ./...\n```\n\n**go generate** не запускается автоматически при **go build** или **go test** — его нужно запускать явно. Обычно это делается в Makefile или в CI перед сборкой.\n\n```\n# Makefile\ngenerate:\n    go generate ./...\n\nbuild: generate\n    go build ./...\n```\n\n## Итого\n\n**go generate** — декларативный способ запускать генераторы кода из исходников. Три самых полезных инструмента: **stringer** для String() методов, **mockgen** для тестовых моков, **sqlc** для типобезопасных SQL-запросов. Сгенерированные файлы коммитятся в репозиторий — это позволяет собирать проект без дополнительных инструментов. **Помечайте их заголовком \"DO NOT EDIT\"** и запускайте генерацию в CI.\n"}