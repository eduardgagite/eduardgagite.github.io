{"content":"\nДо Go 1.16 для встраивания статических файлов в бинарник требовались сторонние инструменты (go-bindata, pkger). С Go 1.16 это встроено в язык через директиву **//go:embed**.\n\nВстраивание позволяет включить файлы (HTML, SQL, конфигурации, шаблоны) прямо в исполняемый файл. Никаких зависимостей от файловой системы при запуске — всё внутри бинарника.\n\n## Встраивание одного файла\n\n```\npackage main\n\nimport (\n    _ \"embed\"\n    \"fmt\"\n)\n\n//go:embed version.txt\nvar version string\n\nfunc main() {\n    fmt.Println(\"Версия:\", version)\n}\n```\n\nСодержимое файла **version.txt** будет встроено в переменную **version** на этапе компиляции. Важно: директива **//go:embed** должна стоять прямо перед объявлением переменной, без пустых строк между ними.\n\nДля бинарных данных используйте **[]byte** вместо **string**:\n\n```\n//go:embed logo.png\nvar logo []byte\n```\n\n## Встраивание нескольких файлов через embed.FS\n\nТип **embed.FS** позволяет встраивать целые директории:\n\n```\nimport \"embed\"\n\n//go:embed templates/*\nvar templates embed.FS\n\n//go:embed static\nvar static embed.FS\n```\n\n**embed.FS** — это виртуальная файловая система только для чтения. Она реализует интерфейс **fs.FS**.\n\n```\n// Прочитать файл из встроенной FS\ndata, err := templates.ReadFile(\"templates/index.html\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(string(data))\n\n// Прочитать директорию\nentries, err := templates.ReadDir(\"templates\")\nfor _, e := range entries {\n    fmt.Println(e.Name())\n}\n```\n\n## Паттерны glob в директиве\n\n```\n//go:embed migrations/*.sql\nvar migrations embed.FS\n\n//go:embed web/static web/templates\nvar webFiles embed.FS\n\n// Встроить несколько директорий/файлов\n//go:embed sql/*.sql\n//go:embed config/default.yaml\nvar assets embed.FS\n```\n\nПо умолчанию файлы с именем, начинающимся с точки или подчёркивания, **не встраиваются**. Для их включения используйте **all:**:\n\n```\n//go:embed all:data\nvar data embed.FS\n```\n\n## HTTP-сервер со статическими файлами\n\nКлассический use-case — раздача статических файлов:\n\n```\npackage main\n\nimport (\n    \"embed\"\n    \"net/http\"\n    \"io/fs\"\n    \"log\"\n)\n\n//go:embed static\nvar staticFiles embed.FS\n\nfunc main() {\n    // Создаём sub-FS без префикса \"static/\"\n    sub, err := fs.Sub(staticFiles, \"static\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    http.Handle(\"/\", http.FileServer(http.FS(sub)))\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\nТеперь файлы из директории **static/** будут доступны по URL **/**. При сборке всё попадает в один бинарник — никаких внешних файлов.\n\n## HTML-шаблоны\n\n```\nimport (\n    \"embed\"\n    \"html/template\"\n    \"net/http\"\n)\n\n//go:embed templates/*.html\nvar templateFiles embed.FS\n\nvar tmpl = template.Must(template.ParseFS(templateFiles, \"templates/*.html\"))\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    data := map[string]string{\"Name\": \"Gopher\"}\n    tmpl.ExecuteTemplate(w, \"index.html\", data)\n}\n```\n\n## SQL-миграции из embed.FS\n\n```\n//go:embed migrations/*.sql\nvar migrationsFS embed.FS\n\nfunc runMigrations(db *sql.DB) error {\n    entries, err := migrationsFS.ReadDir(\"migrations\")\n    if err != nil {\n        return err\n    }\n\n    for _, entry := range entries {\n        content, err := migrationsFS.ReadFile(\"migrations/\" + entry.Name())\n        if err != nil {\n            return err\n        }\n\n        if _, err := db.Exec(string(content)); err != nil {\n            return fmt.Errorf(\"migration %s: %w\", entry.Name(), err)\n        }\n    }\n    return nil\n}\n```\n\n## Ограничения\n\n- Встроенные файлы доступны только для чтения — изменить их в runtime нельзя.\n- Директива работает только в пакетах, не в функциях.\n- Пути в директиве **//go:embed** — относительные, от файла с исходным кодом.\n- Нельзя встраивать файлы вне модуля или выше по дереву директорий.\n\n## Итого\n\n**go:embed** — встроенный способ упаковать статические файлы в бинарник без сторонних инструментов. **embed.FS** реализует **fs.FS** и совместима с **http.FileServer**, **template.ParseFS** и другими стандартными функциями. Это делает деплой проще: один бинарник содержит всё приложение — статику, шаблоны, миграции.\n"}