{"content":"\nПакет **unsafe** — это официальный способ обойти систему типов Go. Он позволяет работать с памятью напрямую: получать адреса, конвертировать указатели между несовместимыми типами, вычислять смещения полей.\n\nНесмотря на пугающее название, **unsafe** используется в стандартной библиотеке и известных пакетах — там, где нужна максимальная производительность. Важно понять: когда это уместно, а когда опасно.\n\n## Основные инструменты\n\n### unsafe.Sizeof — размер типа в байтах\n\n```\nfmt.Println(unsafe.Sizeof(int(0)))      // 8 (на 64-битной системе)\nfmt.Println(unsafe.Sizeof(int32(0)))    // 4\nfmt.Println(unsafe.Sizeof(bool(false))) // 1\nfmt.Println(unsafe.Sizeof(float64(0))) // 8\n\ntype Point struct {\n    X, Y float64\n}\nfmt.Println(unsafe.Sizeof(Point{})) // 16\n```\n\n### unsafe.Alignof — выравнивание типа\n\n```\nfmt.Println(unsafe.Alignof(int64(0)))   // 8\nfmt.Println(unsafe.Alignof(bool(false))) // 1\n```\n\n### unsafe.Offsetof — смещение поля структуры\n\n```\ntype Header struct {\n    Magic   uint32\n    Version uint16\n    Flags   uint16\n    Size    uint64\n}\n\nfmt.Println(unsafe.Offsetof(Header{}.Magic))   // 0\nfmt.Println(unsafe.Offsetof(Header{}.Version)) // 4\nfmt.Println(unsafe.Offsetof(Header{}.Flags))   // 6\nfmt.Println(unsafe.Offsetof(Header{}.Size))    // 8\nfmt.Println(unsafe.Sizeof(Header{}))           // 16\n```\n\nЭто полезно при работе с бинарными протоколами, где нужно точно знать раскладку структуры в памяти.\n\n## unsafe.Pointer — указатель без типа\n\n**unsafe.Pointer** — аналог **void\\*** в C. Можно конвертировать в него любой указатель и обратно:\n\n```\nx := int64(42)\np := unsafe.Pointer(&x)        // *int64 → unsafe.Pointer\nq := (*float64)(p)              // unsafe.Pointer → *float64\n\nfmt.Println(*q) // 42.0 — те же биты, другой тип\n```\n\n## Быстрое преобразование []byte ↔ string без копирования\n\nСамый распространённый use-case **unsafe** в production-коде:\n\n```\n// string → []byte без копирования\nfunc unsafeStringToBytes(s string) []byte {\n    return unsafe.Slice(unsafe.StringData(s), len(s))\n}\n\n// []byte → string без копирования\nfunc unsafeBytesToString(b []byte) string {\n    return unsafe.String(unsafe.SliceData(b), len(b))\n}\n```\n\n**unsafe.String** и **unsafe.SliceData** появились в Go 1.20 и это официальный способ для такой конвертации. Их безопаснее использовать, чем предыдущий подход через **reflect.StringHeader**.\n\n**Критически важно**: нельзя изменять байты, полученные из строки через **unsafe** — строки в Go неизменяемы, и нарушение этого приведёт к неопределённому поведению.\n\n## uintptr и арифметика указателей\n\nДля арифметики с указателями нужен **uintptr** — числовое представление адреса:\n\n```\ntype Point struct {\n    X int\n    Y int\n}\n\np := &Point{X: 1, Y: 2}\n\n// Получить указатель на поле Y через арифметику\nyPtr := (*int)(unsafe.Pointer(\n    uintptr(unsafe.Pointer(p)) + unsafe.Offsetof(p.Y),\n))\nfmt.Println(*yPtr) // 2\n```\n\n**Важное правило**: никогда не храните **uintptr** в переменной между операциями — GC может переместить объект, и адрес станет недействительным. Всё арифметические выражения должны быть в одной строке (одном выражении).\n\n## Когда unsafe уместен\n\nИспользуйте **unsafe** только если:\n1. Нужна максимальная производительность в горячем пути (hot path), и профилировщик подтвердил проблему.\n2. Вы работаете с бинарными протоколами или низкоуровневыми API.\n3. Вы пишете системную библиотеку, а не бизнес-логику.\n\nВ остальных случаях — не используйте. Преимущества Go (типобезопасность, GC, простота) существуют именно потому, что вы не работаете с памятью вручную.\n\n## Итого\n\n**unsafe** — это инструмент для крайних случаев, не повседневного кода. Основные применения: **измерение размеров и смещений** структур, **конвертация string ↔ []byte без копирования** (Go 1.20+), работа с бинарными протоколами. **uintptr** нельзя хранить между операциями — GC не знает о нём и может переместить данные в памяти.\n"}