{"content":"\nРефлексия позволяет программе изучать и изменять свою структуру во время выполнения. В Go это реализовано через пакет **reflect**. Он используется в стандартной библиотеке повсюду — в **fmt**, **encoding/json**, **database/sql** — но в прикладном коде нужен редко.\n\n## Два ключевых типа: Type и Value\n\nПакет **reflect** строится вокруг двух типов:\n- **reflect.Type** — описывает тип переменной.\n- **reflect.Value** — содержит само значение и позволяет с ним работать.\n\n```\nx := 42\nt := reflect.TypeOf(x)\nv := reflect.ValueOf(x)\n\nfmt.Println(t)          // int\nfmt.Println(t.Kind())   // int\nfmt.Println(v)          // 42\nfmt.Println(v.Int())    // 42\n```\n\n**Kind** — это более грубая классификация типа: **int**, **string**, **struct**, **ptr**, **slice**, **map** и т.д. **Type** — точный тип, например **time.Duration** (который на уровне Kind тоже **int64**).\n\n## Изучение структуры\n\n```\ntype User struct {\n    Name  string `json:\"name\"`\n    Age   int    `json:\"age,omitempty\"`\n    email string // неэкспортированное поле\n}\n\nu := User{Name: \"Alice\", Age: 30}\nt := reflect.TypeOf(u)\n\nfmt.Println(t.Name())   // User\nfmt.Println(t.NumField()) // 3\n\nfor i := 0; i < t.NumField(); i++ {\n    field := t.Field(i)\n    fmt.Printf(\"Поле: %s, тип: %s, тег: %s\\n\",\n        field.Name, field.Type, field.Tag.Get(\"json\"))\n}\n// Поле: Name, тип: string, тег: name\n// Поле: Age, тип: int, тег: age,omitempty\n// Поле: email, тип: string, тег:\n```\n\nЧтение тегов структуры — это то, как **encoding/json** знает, какой JSON-ключ соответствует какому полю.\n\n## Чтение и изменение значений\n\nЧтобы изменить значение через рефлексию, нужно передать **указатель**:\n\n```\nu := User{Name: \"Alice\", Age: 30}\nv := reflect.ValueOf(&u).Elem() // Elem() разыменовывает указатель\n\n// Чтение\nnameField := v.FieldByName(\"Name\")\nfmt.Println(nameField.String()) // Alice\n\n// Запись (только для экспортированных полей)\nif nameField.CanSet() {\n    nameField.SetString(\"Bob\")\n}\nfmt.Println(u.Name) // Bob\n```\n\n**CanSet** возвращает **false** для неэкспортированных полей — их нельзя изменить через рефлексию.\n\n## Вызов методов\n\n```\ntype Greeter struct {\n    Name string\n}\n\nfunc (g Greeter) Hello(greeting string) string {\n    return fmt.Sprintf(\"%s, %s!\", greeting, g.Name)\n}\n\ng := Greeter{Name: \"World\"}\nv := reflect.ValueOf(g)\n\nmethod := v.MethodByName(\"Hello\")\nargs := []reflect.Value{reflect.ValueOf(\"Hello\")}\nresult := method.Call(args)\n\nfmt.Println(result[0].String()) // Hello, World!\n```\n\n## Практический пример: универсальный принтер структур\n\n```\nfunc printStruct(v interface{}) {\n    t := reflect.TypeOf(v)\n    val := reflect.ValueOf(v)\n\n    if t.Kind() == reflect.Ptr {\n        t = t.Elem()\n        val = val.Elem()\n    }\n\n    if t.Kind() != reflect.Struct {\n        fmt.Printf(\"%v\\n\", v)\n        return\n    }\n\n    fmt.Printf(\"Тип: %s\\n\", t.Name())\n    for i := 0; i < t.NumField(); i++ {\n        field := t.Field(i)\n        value := val.Field(i)\n        if field.IsExported() {\n            fmt.Printf(\"  %s: %v\\n\", field.Name, value.Interface())\n        }\n    }\n}\n```\n\n## Когда использовать рефлексию\n\nРефлексия уместна в:\n- Библиотеках сериализации (JSON, YAML, XML).\n- ORM-библиотеках для маппинга структур на таблицы.\n- Тестовых утилитах (deep equal, генерация тестовых данных).\n- Dependency injection фреймворках.\n\nВ прикладном коде рефлексия — признак что-то пошло не так. Если вы пишете рефлексию в бизнес-логике, скорее всего задачу лучше решить через интерфейсы или дженерики.\n\n## Производительность\n\nРефлексия медленная — в 10-100 раз медленнее прямых вызовов. Если вам нужна высокая производительность при работе со структурами, рассмотрите:\n- **Кодогенерацию** (go generate) — генерируете обычный код.\n- **Unsafe** — для очень специфических случаев.\n- **Дженерики** (Go 1.18+) — решают многие задачи без рефлексии.\n\n## Итого\n\nПакет **reflect** даёт полный доступ к типам и значениям во время выполнения. Он лежит в основе JSON, ORM и других библиотек. **В прикладном коде используйте его с осторожностью** — рефлексия медленная и делает код труднее для понимания. Для новых задач сначала оцените, решают ли проблему дженерики или интерфейсы.\n"}