{"content":"\nВ Go есть три встроенных механизма, которые управляют потоком выполнения в нестандартных ситуациях: **defer** откладывает вызов функции до завершения текущей, **panic** аварийно останавливает программу, а **recover** перехватывает панику и позволяет продолжить работу.\n\n## Defer — отложенный вызов\n\nКлючевое слово **defer** говорит: \"Выполни эту функцию, но не сейчас, а когда текущая функция завершится\". Неважно, как она завершится — нормально или из-за ошибки.\n\n```\nfunc main() {\n    fmt.Println(\"Начало\")\n    defer fmt.Println(\"Это выполнится последним\")\n    fmt.Println(\"Конец\")\n}\n```\n\nВывод:\n\n```\nНачало\nКонец\nЭто выполнится последним\n```\n\n### Главное применение — освобождение ресурсов\n\nОткрыли файл — нужно закрыть. Открыли соединение с базой — нужно закрыть. **defer** гарантирует, что ресурс будет освобождён, даже если в середине функции произойдёт ошибка.\n\n```\nfunc readConfig(path string) ([]byte, error) {\n    f, err := os.Open(path)\n    if err != nil {\n        return nil, err\n    }\n    defer f.Close()\n\n    data, err := io.ReadAll(f)\n    if err != nil {\n        return nil, err\n    }\n    return data, nil\n}\n```\n\nБез **defer** пришлось бы вызывать **f.Close()** перед каждым **return**. С **defer** — один раз, сразу после открытия.\n\n### Порядок выполнения: LIFO\n\nЕсли в функции несколько **defer**, они выполняются в обратном порядке — последний отложенный вызов выполнится первым (стек).\n\n```\nfunc main() {\n    defer fmt.Println(\"первый defer\")\n    defer fmt.Println(\"второй defer\")\n    defer fmt.Println(\"третий defer\")\n}\n```\n\nВывод:\n\n```\nтретий defer\nвторой defer\nпервый defer\n```\n\nЭто логично: если вы открыли ресурс A, потом ресурс B (который зависит от A), закрывать нужно сначала B, потом A.\n\n### Аргументы вычисляются сразу\n\nВажный нюанс: аргументы отложенной функции вычисляются в момент вызова **defer**, а не в момент выполнения.\n\n```\nfunc main() {\n    x := 10\n    defer fmt.Println(\"x =\", x)\n    x = 20\n}\n```\n\nВывод: **x = 10**, а не 20. Если нужно захватить актуальное значение, используйте замыкание:\n\n```\ndefer func() {\n    fmt.Println(\"x =\", x)\n}()\n```\n\n## Panic — аварийная остановка\n\n**panic** — это аварийное завершение текущей горутины. Используется, когда произошло что-то, из чего невозможно восстановиться: нарушена внутренняя логика программы, обнаружен баг.\n\n```\nfunc divide(a, b int) int {\n    if b == 0 {\n        panic(\"деление на ноль\")\n    }\n    return a / b\n}\n```\n\nКогда вызывается **panic**:\n1. Текущая функция останавливается.\n2. Выполняются все **defer** в текущей функции.\n3. Управление возвращается вызывающей функции, и она тоже останавливается (со своими defer).\n4. Так вверх по стеку, пока горутина не завершится.\n\n### Когда использовать panic\n\n**Используйте panic** только в ситуациях, которые говорят о баге в коде:\n- Нарушение инварианта (невозможное состояние).\n- Ошибка инициализации, без которой программа не может работать.\n\n**Не используйте panic** для ожидаемых ошибок (файл не найден, сетевой сбой, неверный ввод пользователя). Для этого существует возврат **error**.\n\n```\nfunc mustParseURL(raw string) *url.URL {\n    u, err := url.Parse(raw)\n    if err != nil {\n        panic(fmt.Sprintf(\"невалидный URL: %s\", raw))\n    }\n    return u\n}\n```\n\nФункции с префиксом **must** в Go-сообществе — соглашение: \"эта функция паникует вместо возврата ошибки\". Применяйте их только при инициализации, когда ошибка означает \"программу нельзя запустить\".\n\n## Recover — перехват паники\n\n**recover** — это встроенная функция, которая \"ловит\" панику и позволяет программе продолжить работу. Она работает **только внутри defer**.\n\n```\nfunc safeDiv(a, b int) (result int, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"перехвачена паника: %v\", r)\n        }\n    }()\n\n    return a / b, nil\n}\n\nfunc main() {\n    result, err := safeDiv(10, 0)\n    if err != nil {\n        fmt.Println(\"Ошибка:\", err) // \"перехвачена паника: runtime error: integer divide by zero\"\n    } else {\n        fmt.Println(\"Результат:\", result)\n    }\n}\n```\n\n### Где recover реально нужен\n\nНа практике **recover** используется в двух местах:\n\n1. **HTTP-сервер** — чтобы паника в одном обработчике не убила весь сервер. Стандартный HTTP-сервер Go делает это автоматически.\n\n2. **Middleware для перехвата паник** — во фреймворках и библиотеках.\n\n```\nfunc recoveryMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"паника в обработчике: %v\", err)\n                http.Error(w, \"Internal Server Error\", 500)\n            }\n        }()\n        next.ServeHTTP(w, r)\n    })\n}\n```\n\nНе используйте **recover** как замену нормальной обработке ошибок через **error**. Это инструмент последней линии обороны.\n\n## Итог\n\n**defer** — для гарантированного освобождения ресурсов (файлы, соединения, мьютексы). **panic** — для невосстановимых ситуаций, сигнализирующих о баге. **recover** — для перехвата паник на границах системы (HTTP-обработчики, воркеры). В повседневном коде вы будете использовать **defer** постоянно, **panic** — редко, а **recover** — почти никогда.\n"}