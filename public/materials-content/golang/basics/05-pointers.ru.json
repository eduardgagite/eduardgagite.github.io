{"content":"\nКогда вы передаёте переменную в функцию, Go по умолчанию создаёт **копию** значения. Функция работает с копией, а оригинал остаётся нетронутым. Это безопасно, но иногда нужно изменить именно оригинал. Для этого существуют указатели.\n\nУказатель — это переменная, которая хранит не само значение, а **адрес в памяти**, где это значение лежит. Как записка с адресом дома вместо самого дома.\n\n## Синтаксис\n\nДва оператора — всё, что нужно знать:\n\n- **&** (амперсанд) — \"дай мне адрес этой переменной\".\n- **\\*** (звёздочка) — \"дай мне значение по этому адресу\" (разыменование).\n\n```\nfunc main() {\n    age := 25\n\n    ptr := &age\n    fmt.Println(ptr)  // 0xc0000b6010\n    fmt.Println(*ptr) // 25\n\n    *ptr = 30\n    fmt.Println(age) // 30\n}\n```\n\nТип указателя записывается как **\\*T**, где **T** — тип значения. Указатель на **int** имеет тип **\\*int**, указатель на **string** — **\\*string**.\n\n## Зачем нужны указатели\n\n### Изменение значения в функции\n\nБез указателя функция работает с копией и не может изменить оригинал.\n\n```\nfunc doubleValue(n int) {\n    n = n * 2\n}\n\nfunc doublePointer(n *int) {\n    *n = *n * 2\n}\n\nfunc main() {\n    x := 10\n\n    doubleValue(x)\n    fmt.Println(x) // 10\n\n    doublePointer(&x)\n    fmt.Println(x) // 20\n}\n```\n\n### Экономия памяти\n\nЕсли структура большая (десятки полей), копировать её при каждом вызове функции — расточительно. Передача указателя копирует только 8 байт (размер адреса), а не всю структуру.\n\n```\ntype Report struct {\n    Title   string\n    Content string\n    Pages   int\n    // ... ещё 20 полей\n}\n\nfunc process(r *Report) {\n    r.Pages = 42\n}\n```\n\nОбратите внимание: при обращении к полям через указатель на структуру Go не требует писать **(\\*r).Pages**. Запись **r.Pages** работает автоматически — компилятор сам разыменовывает указатель.\n\n## Методы с указателем-получателем\n\nВ разделе о структурах мы создавали методы. Если метод должен изменять поля структуры, получатель должен быть указателем.\n\n```\ntype Counter struct {\n    Value int\n}\n\nfunc (c Counter) IncrementBroken() {\n    c.Value++\n}\n\nfunc (c *Counter) Increment() {\n    c.Value++\n}\n\nfunc main() {\n    counter := Counter{Value: 0}\n\n    counter.IncrementBroken()\n    fmt.Println(counter.Value) // 0\n\n    counter.Increment()\n    fmt.Println(counter.Value) // 1\n}\n```\n\nПрактическое правило: если хотя бы один метод структуры использует указатель-получатель, **все методы** этой структуры должны использовать указатель. Это соглашение Go-сообщества.\n\n## Нулевое значение указателя — nil\n\nУказатель, которому не присвоен адрес, равен **nil**. Попытка разыменовать **nil** вызовет панику (аварийное завершение программы).\n\n```\nvar ptr *int // ptr == nil\n\n// fmt.Println(*ptr) // ПАНИКА: runtime error: invalid memory address\n\nif ptr != nil {\n    fmt.Println(*ptr)\n}\n```\n\nВсегда проверяйте указатель на **nil**, если он мог прийти извне (из другой функции, из параметра).\n\n## Когда использовать указатели, а когда — нет\n\n**Используйте указатели**, когда:\n- Нужно изменить переданное значение.\n- Структура большая и копирование дорого.\n- Нужно выразить \"значения может не быть\" (**nil**).\n\n**Не используйте указатели**, когда:\n- Работаете с маленькими типами (**int**, **bool**, **string**).\n- Функция только читает значение, не изменяя его.\n- Хотите гарантировать, что вызывающий код не повлияет на ваши данные.\n\nСрезы, карты и каналы уже содержат внутренний указатель — передавать **\\*[]int** или **\\*map[string]int** не нужно.\n\n## Итог\n\nУказатель — это адрес значения в памяти. Оператор **&** берёт адрес, оператор **\\*** читает или пишет по адресу. Указатели нужны, чтобы функции могли изменять переданные значения и чтобы не копировать большие структуры. **Всегда проверяйте указатель на nil перед разыменованием.**\n"}