{"content":"\nСтроки в Go — это не массив символов, как в некоторых языках. Строка — это неизменяемая последовательность **байтов**. Это принципиальный момент, который объясняет многие неочевидные вещи в работе с текстом.\n\nGo использует кодировку **UTF-8** по умолчанию. Латинская буква занимает 1 байт, кириллица — 2 байта, а эмодзи — 4 байта. Поэтому длина строки в байтах и количество \"символов\" — это разные вещи.\n\n## Байты vs руны\n\n```\ns := \"Привет\"\n\nfmt.Println(len(s)) // 12\n```\n\nФункция **len** возвращает количество байтов, а не символов. Для подсчёта символов (рун) нужен пакет **unicode/utf8**.\n\n```\nimport \"unicode/utf8\"\n\ns := \"Привет\"\nfmt.Println(utf8.RuneCountInString(s)) // 6\n```\n\n**Руна** (rune) — это тип Go для одного Unicode-символа. Технически это алиас для **int32**, то есть числовой код символа.\n\n```\nvar r rune = 'П'\nfmt.Println(r) // 1055\n```\n\n## Перебор строки\n\n### Побайтово (обычно не то, что нужно)\n\n```\ns := \"Go!\"\nfor i := 0; i < len(s); i++ {\n    fmt.Printf(\"Байт %d: %c\\n\", i, s[i])\n}\n```\n\nДля ASCII-строк это работает. Но если в строке кириллица или другие многобайтовые символы, вы получите \"мусор\" — отдельные байты вместо букв.\n\n### По рунам (правильный способ)\n\nЦикл **for range** по строке автоматически декодирует руны.\n\n```\ns := \"Привет\"\nfor i, r := range s {\n    fmt.Printf(\"Позиция %d: %c\\n\", i, r)\n}\n```\n\nЗдесь **i** — это позиция в байтах (0, 2, 4, 6, 8, 10), а **r** — руна (символ). Позиции идут не подряд, потому что каждая кириллическая буква занимает 2 байта.\n\n## Преобразования\n\n### Строка в срез байтов и обратно\n\nСтроки в Go неизменяемы. Если нужно изменить строку, преобразуйте её в срез байтов, измените и преобразуйте обратно.\n\n```\ns := \"Hello\"\nb := []byte(s)\nb[0] = 'h'\ns2 := string(b)\nfmt.Println(s2) // \"hello\"\n```\n\n### Строка в срез рун\n\nДля работы с многобайтовыми символами безопаснее использовать срез рун.\n\n```\ns := \"Привет\"\nrunes := []rune(s)\nrunes[0] = 'п'\ns2 := string(runes)\nfmt.Println(s2)         // \"привет\"\nfmt.Println(len(runes)) // 6\n```\n\n## Полезные функции пакета strings\n\nПакет **strings** содержит всё необходимое для работы с текстом.\n\n```\nimport \"strings\"\n\nstrings.Contains(\"Hello, World\", \"World\")  // true\nstrings.HasPrefix(\"config.json\", \"config\") // true\nstrings.HasSuffix(\"photo.png\", \".png\")     // true\n\nstrings.ToUpper(\"hello\") // \"HELLO\"\nstrings.ToLower(\"HELLO\") // \"hello\"\n\nstrings.TrimSpace(\"  hello  \")          // \"hello\"\nstrings.Replace(\"aaa\", \"a\", \"b\", 2)     // \"bba\"\nstrings.ReplaceAll(\"aaa\", \"a\", \"b\")     // \"bbb\"\n\nstrings.Split(\"a,b,c\", \",\")             // [\"a\", \"b\", \"c\"]\nstrings.Join([]string{\"a\", \"b\"}, \"-\")   // \"a-b\"\n```\n\n## Конкатенация строк\n\nОператор **+** создаёт новую строку при каждом сложении. Для одного-двух склеиваний это нормально. Но если нужно собрать строку из множества кусков (например, в цикле), используйте **strings.Builder** — он эффективнее, потому что не создаёт промежуточные строки.\n\n```\nvar b strings.Builder\nfor i := 0; i < 1000; i++ {\n    b.WriteString(\"Go\")\n}\nresult := b.String()\n```\n\n## Итог\n\nСтрока в Go — это последовательность байтов, а не символов. Для работы с Unicode используйте **руны** и цикл **for range**. Пакет **strings** покрывает большинство задач по обработке текста. **Если строка содержит не только ASCII, всегда думайте в терминах рун, а не байтов.**\n"}