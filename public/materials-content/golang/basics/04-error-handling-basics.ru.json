{"content":"\nВ программировании что-то постоянно идет не так: файл не открылся, интернет пропал, пользователь ввел букву вместо цифры.\n\nВо многих языках (Java, Python, C#) для этого придумали **исключения** (**try-catch**). Когда случается ошибка, программа бросает всё, перепрыгивает через код и ищет, кто бы её поймал. Это похоже на панику на корабле.\n\nВ Go подход другой. Здесь ошибка — это не катастрофа, а просто **значение**, такое же, как число или строка. Вы просто возвращаете ошибку из функции и спокойно проверяете её. Без паники и прыжков.\n\n## Главное правило: \"Проверь ошибку сразу\"\n\nПочти любая функция в Go, которая может сломаться, возвращает два значения: **результат** и **ошибку**.\n\n```\nfile, err := os.Open(\"config.txt\")\n```\n\nПеременная **err** имеет специальный тип **error**.\n- Если **err == nil** (пусто), значит всё хорошо, ошибок нет.\n- Если **err != nil**, значит что-то случилось, и в **err** лежит описание проблемы.\n\n### Стандартный шаблон\n\nВы будете писать этот код тысячи раз. Это идиома Go.\n\n```\nfile, err := os.Open(\"data.txt\")\n\nif err != nil {\n    fmt.Println(\"Не удалось открыть файл:\", err)\n    return\n}\n\ndefer file.Close()\n```\n\n### Почему так лучше?\n\n1. **Нет скрытых путей**. Читая код, вы сразу видите, где может быть ошибка. Нет такого, что функция внезапно выкинула Exception, о котором вы не знали.\n2. **Контроль**. Вы обязаны решить, что делать с ошибкой. Если вы её проигнорируете, компилятор или линтер вас поругают (за неиспользованную переменную **err**).\n\n## Как создать свою ошибку\n\nДопустим, вы пишете функцию, которая проверяет возраст.\n\n```\nimport \"errors\"\n\nfunc checkAge(age int) error {\n    if age < 0 {\n        return errors.New(\"возраст не может быть отрицательным\")\n    }\n    return nil\n}\n```\n\n### Ошибка с подробностями\n\nЧасто нужно сказать не просто \"ошибка\", а добавить деталей (какой именно ID не найден). Для этого используем **fmt.Errorf**.\n\n```\nfunc getUser(id int) (string, error) {\n    if id == 0 {\n        return \"\", fmt.Errorf(\"пользователь с id %d не найден\", id)\n    }\n    return \"User\", nil\n}\n```\n\n## Panic (Паника) — крайняя мера\n\nВ Go есть свой аналог исключений — **panic**. Но использовать его в обычном коде считается **дурным тоном**.\n\nПаника полностью останавливает программу (крашит её). Её используют только в ситуациях, когда **невозможно** продолжать работу.\n- Пример: программа стартует, а конфигурационного файла нет. Работать бессмысленно -> **panic**.\n- Антипример: пользователь ввел неверный пароль. Это штатная ситуация, просто верните **error**.\n\n```\nif userInput == \"\" {\n    panic(\"пустой ввод\")\n}\n\nif userInput == \"\" {\n    return errors.New(\"пустой ввод\")\n}\n```\n\n## Итог\n\n1. Ошибки в Go — это обычные значения. Не бойтесь их.\n2. Проверяйте **if err != nil** сразу после вызова функции.\n3. Если всё хорошо, возвращайте **nil**.\n4. Забудьте про **panic**, пока не станете сеньором (а тогда вы поймете, что она вам почти не нужна).\n"}