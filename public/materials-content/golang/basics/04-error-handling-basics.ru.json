{"content":"\nВ программировании что-то постоянно идет не так: файл не открылся, интернет пропал, пользователь ввел букву вместо цифры.\n\nВо многих языках (Java, Python, C#) для этого придумали **исключения** (`try-catch`). Когда случается ошибка, программа бросает всё, перепрыгивает через код и ищет, кто бы её поймал. Это похоже на панику на корабле.\n\nВ Go подход другой. Здесь ошибка — это не катастрофа, а просто **значение**, такое же, как число или строка. Вы просто возвращаете ошибку из функции и спокойно проверяете её. Без паники и прыжков.\n\n## Главное правило: \"Проверь ошибку сразу\"\n\nПочти любая функция в Go, которая может сломаться, возвращает два значения: **результат** и **ошибку**.\n\n```go\nfile, err := os.Open(\"config.txt\")\n```\n\nПеременная `err` имеет специальный тип `error`.\n- Если `err == nil` (пусто), значит всё хорошо, ошибок нет.\n- Если `err != nil`, значит что-то случилось, и в `err` лежит описание проблемы.\n\n### Стандартный шаблон\n\nВы будете писать этот код тысячи раз. Это идиома Go.\n\n```go\nfile, err := os.Open(\"data.txt\")\n\nif err != nil {\n    // Ой, что-то пошло не так\n    fmt.Println(\"Не удалось открыть файл:\", err)\n    return // Останавливаем работу функции\n}\n\n// Если мы дошли сюда, значит err был nil. Можно работать с файлом!\ndefer file.Close()\n```\n\n### Почему так лучше?\n\n1. **Нет скрытых путей**. Читая код, вы сразу видите, где может быть ошибка. Нет такого, что функция внезапно выкинула Exception, о котором вы не знали.\n2. **Контроль**. Вы обязаны решить, что делать с ошибкой. Если вы её проигнорируете, компилятор или линтер вас поругают (за неиспользованную переменную `err`).\n\n## Как создать свою ошибку\n\nДопустим, вы пишете функцию, которая проверяет возраст.\n\n```go\nimport \"errors\" // Подключаем стандартный пакет\n\nfunc checkAge(age int) error {\n    if age < 0 {\n        // Создаем новую ошибку с текстом\n        return errors.New(\"возраст не может быть отрицательным\")\n    }\n    // Всё хорошо, возвращаем nil (ошибки нет)\n    return nil\n}\n```\n\n### Ошибка с подробностями\n\nЧасто нужно сказать не просто \"ошибка\", а добавить деталей (какой именно ID не найден). Для этого используем `fmt.Errorf`.\n\n```go\nfunc getUser(id int) (string, error) {\n    if id == 0 {\n        // %d заменится на значение id\n        return \"\", fmt.Errorf(\"пользователь с id %d не найден\", id)\n    }\n    return \"User\", nil\n}\n```\n\n## Panic (Паника) — крайняя мера\n\nВ Go есть свой аналог исключений — `panic`. Но использовать его в обычном коде считается **дурным тоном**.\n\nПаника полностью останавливает программу (крашит её). Её используют только в ситуациях, когда **невозможно** продолжать работу.\n- Пример: программа стартует, а конфигурационного файла нет. Работать бессмысленно -> `panic`.\n- Антипример: пользователь ввел неверный пароль. Это штатная ситуация, просто верните `error`.\n\n```go\n// Так делать НЕ НАДО в обычном коде\nif userInput == \"\" {\n    panic(\"пустой ввод\") \n}\n\n// НАДО делать так\nif userInput == \"\" {\n    return errors.New(\"пустой ввод\")\n}\n```\n\n## Итог\n\n1. Ошибки в Go — это обычные значения. Не бойтесь их.\n2. Проверяйте `if err != nil` сразу после вызова функции.\n3. Если всё хорошо, возвращайте `nil`.\n4. Забудьте про `panic`, пока не станете сеньором (а тогда вы поймете, что она вам почти не нужна).\n"}