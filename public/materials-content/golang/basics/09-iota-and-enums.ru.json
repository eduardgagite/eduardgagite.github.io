{"content":"\nВ Go нет встроенного типа **enum** как в Java или TypeScript. Вместо него используют **iota** — специальный инструмент для создания последовательных констант, который полностью закрывает эту потребность.\n\n## Что такое iota\n\n**iota** — это счётчик, который автоматически увеличивается на 1 в блоке **const**. Начинается с 0 и сбрасывается в начале каждого нового блока.\n\n```\nconst (\n    StatusPending   = iota // 0\n    StatusActive           // 1\n    StatusCompleted        // 2\n    StatusCancelled        // 3\n)\n```\n\nКаждая строка блока — это выражение с **iota**, и оно автоматически вычисляется. Не нужно писать цифры вручную.\n\n## Пользовательские типы для перечислений\n\nПросто числа — это неудобно: ошибиться легко, и компилятор не поможет. Поэтому всегда создают именованный тип:\n\n```\ntype OrderStatus int\n\nconst (\n    StatusPending   OrderStatus = iota // 0\n    StatusActive                       // 1\n    StatusCompleted                    // 2\n    StatusCancelled                    // 3\n)\n```\n\nТеперь функция, принимающая **OrderStatus**, не примет просто число — это отдельный тип:\n\n```\nfunc processOrder(status OrderStatus) {\n    // ...\n}\n\nprocessOrder(StatusActive)    // OK\nprocessOrder(1)               // Ошибка компиляции — нельзя передать int вместо OrderStatus\n```\n\n## Пропуск значений с помощью _\n\nЕсли первое значение должно быть 1, а не 0, или нужно пропустить какое-то значение — используйте **_**:\n\n```\ntype Priority int\n\nconst (\n    _ Priority = iota // 0 — пропускаем (не используем нулевое значение)\n    Low               // 1\n    Medium            // 2\n    High              // 3\n    Critical          // 4\n)\n```\n\nНулевое значение часто означает \"не задано\", поэтому его пропускают — чтобы неинициализированная переменная не притворялась допустимым значением.\n\n## Выражения с iota\n\n**iota** можно использовать в выражениях — множить, сдвигать биты, складывать:\n\n```\n// Степени двойки — удобно для флагов\ntype Permission int\n\nconst (\n    Read    Permission = 1 << iota // 1   (0001)\n    Write                          // 2   (0010)\n    Execute                        // 4   (0100)\n    Admin                          // 8   (1000)\n)\n```\n\nЭто классический паттерн для **битовых флагов**: каждое значение занимает свой бит, и их можно комбинировать через побитовое ИЛИ:\n\n```\nuserPermissions := Read | Write // 3 (0011)\n\nif userPermissions&Read != 0 {\n    fmt.Println(\"Можно читать\")\n}\n```\n\n## Метод String() для читаемого вывода\n\nПо умолчанию при выводе **OrderStatus** в консоль вы увидите просто цифру **2**, а не **\"StatusCompleted\"**. Чтобы это исправить, реализуйте интерфейс **Stringer**:\n\n```\nfunc (s OrderStatus) String() string {\n    switch s {\n    case StatusPending:\n        return \"Pending\"\n    case StatusActive:\n        return \"Active\"\n    case StatusCompleted:\n        return \"Completed\"\n    case StatusCancelled:\n        return \"Cancelled\"\n    default:\n        return \"Unknown\"\n    }\n}\n\nfunc main() {\n    status := StatusActive\n    fmt.Println(status) // Active — а не 1\n}\n```\n\nТеперь **fmt.Println** и **fmt.Sprintf(\"%v\", ...)** автоматически используют ваш метод.\n\n## Валидация значений\n\nХороший паттерн — добавить метод для проверки допустимости значения. Это защищает от случайного использования чисел за пределами диапазона:\n\n```\nfunc (s OrderStatus) IsValid() bool {\n    return s >= StatusPending && s <= StatusCancelled\n}\n```\n\nИ метод для преобразования строки в статус (полезно при чтении из базы данных или JSON):\n\n```\nfunc ParseOrderStatus(s string) (OrderStatus, error) {\n    switch s {\n    case \"Pending\":\n        return StatusPending, nil\n    case \"Active\":\n        return StatusActive, nil\n    case \"Completed\":\n        return StatusCompleted, nil\n    case \"Cancelled\":\n        return StatusCancelled, nil\n    default:\n        return 0, fmt.Errorf(\"unknown status: %s\", s)\n    }\n}\n```\n\n## Итого\n\n**iota** — элегантный способ создавать перечисления в Go без встроенного enum. Всегда создавайте именованный тип для констант — это даёт типобезопасность. **Нулевое значение лучше пропускать или использовать как \"не задано\"**, чтобы неинициализированная переменная не вела себя как допустимое состояние. Метод **String()** делает отладку и логирование значительно удобнее.\n"}