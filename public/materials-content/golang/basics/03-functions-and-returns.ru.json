{"content":"\nФункция — это отдельный блок кода, который делает одну конкретную задачу. Вы даете функции какие-то данные на вход (аргументы), она их обрабатывает и возвращает результат.\n\nВ Go функции — это главные строительные кирпичики программы. Даже сама программа начинается с функции `main`.\n\n## Простое создание функции\n\nЧтобы создать функцию, используем ключевое слово `func`.\n\nСтруктура: `func Имя(параметры) ТипВозврата { тело }`\n\n```go\n// Принимает два числа (x и y), возвращает их сумму (int)\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc main() {\n    result := add(5, 10)\n    fmt.Println(result) // 15\n}\n```\n\n**Лайфхак**: Если параметры одного типа, его можно написать один раз в конце.\n`func add(x, y int)` — это то же самое, что и `func add(x int, y int)`.\n\n## Суперспособность Go: Возврат нескольких значений\n\nВ большинстве языков (C, Java, JS) функция может вернуть только **один** результат. Если нужно вернуть больше, приходится создавать сложные объекты или массивы.\n\nВ Go всё проще: функция может вернуть сколько угодно значений через запятую.\n\n### Зачем это нужно?\n\nСамый частый сценарий: вернуть **результат** и **ошибку**.\n\n```go\n// Возвращает результат деления (float64) И признак успеха (bool)\nfunc divide(a, b float64) (float64, bool) {\n    if b == 0 {\n        // Делить на ноль нельзя.\n        // Возвращаем 0 (как результат) и false (как ошибку)\n        return 0, false \n    }\n    // Всё ок: возвращаем результат и true\n    return a / b, true\n}\n\nfunc main() {\n    res, ok := divide(10, 2)\n    \n    if ok {\n        fmt.Println(\"Ответ:\", res)\n    } else {\n        fmt.Println(\"Ошибка: деление на ноль\")\n    }\n}\n```\n\nЭто делает код очень надежным. Вы сразу видите, удалась операция или нет.\n\n## Пустой идентификатор (игнорирование значений)\n\nИногда функция возвращает несколько значений, но вам нужно только одно из них.\n\nВ Go нельзя просто создать переменную и не использовать её (компилятор не даст). Для этого есть специальный символ `_` (нижнее подчеркивание). Он работает как \"черная дыра\": всё, что туда попадает, исчезает.\n\n```go\n// Нам нужен только результат, на успешность нам плевать\nres, _ := divide(100, 2) \nfmt.Println(res)\n```\n\n## Именованные возвращаемые значения\n\nМожно заранее придумать имена для переменных, которые вернет функция. Они будут созданы автоматически.\n\n```go\n// Мы говорим: функция вернет переменные x и y\nfunc getCoords() (x, y int) {\n    x = 10\n    y = 20\n    // return без аргументов автоматически вернет текущие x и y\n    return \n}\n```\n\nЭто называется \"naked return\" (голый возврат).\n*Совет*: Используйте это только в коротких функциях. В длинных это путает, потому что непонятно, что именно вернулось.\n\n## Функция с переменным числом аргументов\n\nИногда мы не знаем, сколько аргументов передадут. Например, функция `fmt.Println` может принять хоть 1, хоть 10 строк.\n\nДля этого используется троеточие `...`.\n\n```go\n// nums ...int означает: \"прими сюда кучу int-ов и положи их в срез nums\"\nfunc sum(nums ...int) int {\n    total := 0\n    // Перебираем все полученные числа\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\nfunc main() {\n    fmt.Println(sum(1, 2))       // 3\n    fmt.Println(sum(1, 2, 3, 4)) // 10\n}\n```\n\n## Итог\n\n1. Функции объявляются через `func`.\n2. Самая мощная фишка — **множественный возврат** (например, `result, error`).\n3. Если значение не нужно, используйте `_`, чтобы игнорировать его.\n4. Если не знаете количество аргументов, используйте `...`.\n"}