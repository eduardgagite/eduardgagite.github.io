{"content":"\nВ Go функции — полноправные граждане языка. Их можно присваивать переменным, передавать как аргументы и возвращать из других функций. На этом и строятся замыкания.\n\n**Замыкание** (closure) — это функция, которая захватывает переменные из окружающего контекста. Захваченные переменные живут столько, сколько живёт само замыкание.\n\n## Анонимные функции\n\nФункцию можно объявить прямо в коде и сразу же вызвать или сохранить в переменную.\n\n```\ngreet := func(name string) string {\n    return \"Привет, \" + name\n}\n\nfmt.Println(greet(\"Gopher\"))\n```\n\nАнонимную функцию также можно вызвать немедленно — это называется IIFE (Immediately Invoked Function Expression):\n\n```\nresult := func(a, b int) int {\n    return a + b\n}(10, 20)\n\nfmt.Println(result) // 30\n```\n\nЭто часто используется в **goroutine** — чтобы передать контекст прямо при запуске:\n\n```\ngo func(id int) {\n    fmt.Printf(\"Воркер %d запущен\\n\", id)\n}(42)\n```\n\n## Замыкание захватывает переменную, а не её значение\n\nКлючевой момент: замыкание захватывает **ссылку** на переменную, а не её копию. Это значит, что изменения переменной снаружи видны внутри замыкания, и наоборот.\n\n```\nfunc makeCounter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\nfunc main() {\n    counter := makeCounter()\n    fmt.Println(counter()) // 1\n    fmt.Println(counter()) // 2\n    fmt.Println(counter()) // 3\n}\n```\n\nКаждый вызов **counter()** увеличивает **count** на 1. Переменная **count** живёт в памяти, пока существует замыкание **counter**.\n\nЕсли создать два счётчика — у каждого своё независимое состояние:\n\n```\nc1 := makeCounter()\nc2 := makeCounter()\n\nfmt.Println(c1()) // 1\nfmt.Println(c1()) // 2\nfmt.Println(c2()) // 1 — свой независимый счётчик\n```\n\n## Типичная ловушка с горутинами в цикле\n\nОдна из самых распространённых ошибок в Go — запуск горутин в цикле с захватом переменной цикла.\n\n```\n// НЕПРАВИЛЬНО: все горутины напечатают одно и то же значение\nfor i := 0; i < 3; i++ {\n    go func() {\n        fmt.Println(i) // захватывает ссылку на i\n    }()\n}\n```\n\nВсе горутины захватывают одну и ту же переменную **i**. К моменту их запуска цикл может уже завершиться, и **i** будет равно 3.\n\nПравильный способ — передать значение через параметр:\n\n```\n// ПРАВИЛЬНО: каждая горутина получает свою копию\nfor i := 0; i < 3; i++ {\n    go func(id int) {\n        fmt.Println(id)\n    }(i)\n}\n```\n\nИли с Go 1.22+ переменная цикла создаётся заново на каждой итерации, но явная передача параметра всё равно читается понятнее.\n\n## Функции как аргументы: паттерн обратного вызова\n\nЗамыкания отлично работают как коллбэки. Классический пример — функция-фильтр:\n\n```\nfunc filter(nums []int, predicate func(int) bool) []int {\n    var result []int\n    for _, n := range nums {\n        if predicate(n) {\n            result = append(result, n)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    nums := []int{1, 2, 3, 4, 5, 6}\n\n    even := filter(nums, func(n int) bool { return n%2 == 0 })\n    big := filter(nums, func(n int) bool { return n > 3 })\n\n    fmt.Println(even) // [2 4 6]\n    fmt.Println(big)  // [4 5 6]\n}\n```\n\nЛогика фильтрации отделена от логики предиката. Функция **filter** работает с любым условием.\n\n## Замыкание как способ скрыть состояние\n\nИногда удобно создать функцию с \"памятью\", не создавая структуру:\n\n```\nfunc makeRateLimiter(limit int) func() bool {\n    count := 0\n    return func() bool {\n        if count >= limit {\n            return false\n        }\n        count++\n        return true\n    }\n}\n\nfunc main() {\n    allow := makeRateLimiter(3)\n\n    for i := 0; i < 5; i++ {\n        if allow() {\n            fmt.Println(\"Запрос разрешён\")\n        } else {\n            fmt.Println(\"Лимит исчерпан\")\n        }\n    }\n}\n```\n\nПеременная **count** недоступна снаружи, но живёт между вызовами. Это простая альтернатива структуре с методами.\n\n## Итого\n\nАнонимные функции и замыкания — мощный инструмент Go, который делает код компактным и выразительным. **Главное помнить: замыкание захватывает ссылку на переменную, а не её значение** — это источник большинства ошибок. В горутинах всегда передавайте значение явно через параметр.\n"}