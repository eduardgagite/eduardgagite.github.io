{"content":"\nКогда несколько горутин работают с одной переменной одновременно, возникают **гонки данных** (data races). Это одна из самых сложных для отладки ошибок — программа может вести себя неправильно лишь иногда, в зависимости от порядка выполнения горутин.\n\n## Что такое гонка данных\n\nГонка происходит, когда две горутины одновременно обращаются к одной области памяти, и хотя бы одна из них пишет.\n\n```\nvar counter int\n\nfunc increment() {\n    counter++ // НЕ атомарная операция!\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i < 1000; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            increment()\n        }()\n    }\n    wg.Wait()\n    fmt.Println(counter) // Результат непредсказуем: 987, 1000, 956...\n}\n```\n\nОперация **counter++** на самом деле состоит из трёх шагов: прочитать → увеличить → записать. Если две горутины выполняют их одновременно, одно из приращений теряется.\n\n## Race detector — встроенный детектор гонок\n\nGo поставляется с детектором гонок. Просто добавьте флаг **-race** при запуске или тестировании:\n\n```\ngo run -race main.go\ngo test -race ./...\n```\n\nПри обнаружении гонки вы увидите подробный отчёт: какие горутины и в каком файле обратились к одной памяти одновременно.\n\nДетектор работает в режиме инструментации — он отслеживает все обращения к памяти во время выполнения. Это увеличивает потребление памяти и замедляет программу примерно в 2-20 раз, поэтому в production его не используют, но в тестах — обязательно.\n\n**Правило хорошего тона**: всегда запускайте тесты с **-race** в CI.\n\n## sync/atomic — атомарные операции\n\nПакет **sync/atomic** предоставляет операции, которые выполняются атомарно — без возможности прерывания другой горутиной.\n\n```\nimport \"sync/atomic\"\n\nvar counter int64\n\nfunc increment() {\n    atomic.AddInt64(&counter, 1)\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i < 1000; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            increment()\n        }()\n    }\n    wg.Wait()\n    fmt.Println(counter) // Всегда 1000\n}\n```\n\nОсновные операции **sync/atomic**:\n- **atomic.AddInt64(&x, 1)** — прибавить 1 атомарно\n- **atomic.LoadInt64(&x)** — прочитать атомарно\n- **atomic.StoreInt64(&x, 42)** — записать атомарно\n- **atomic.CompareAndSwapInt64(&x, old, new)** — заменить, если значение равно **old**\n- **atomic.SwapInt64(&x, 42)** — заменить и вернуть старое значение\n\n## atomic.Value — атомарное хранение любых значений\n\nЕсли нужно атомарно менять значения произвольного типа (не только числа), используйте **atomic.Value**:\n\n```\nvar config atomic.Value\n\nfunc updateConfig(newCfg *Config) {\n    config.Store(newCfg)\n}\n\nfunc getConfig() *Config {\n    return config.Load().(*Config)\n}\n```\n\nЭто классический паттерн для hot-reload конфигурации: один поток обновляет конфиг, множество горутин читают без блокировок.\n\n## Когда atomic, а когда Mutex\n\n**sync/atomic** подходит, когда:\n- Вы работаете с одним числовым значением (счётчик, флаг).\n- Нужна максимальная производительность.\n- Операция — одиночное чтение или запись.\n\n**sync.Mutex** (или **sync.RWMutex**) нужен, когда:\n- Нужно атомарно изменить несколько переменных одновременно.\n- Логика обновления сложная (не просто add/store).\n- Работаете со структурами или коллекциями.\n\n```\n// atomic — для простого счётчика\nvar hits int64\natomic.AddInt64(&hits, 1)\n\n// Mutex — для обновления нескольких полей структуры\ntype Stats struct {\n    mu       sync.Mutex\n    requests int\n    errors   int\n}\n\nfunc (s *Stats) Record(isError bool) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.requests++\n    if isError {\n        s.errors++\n    }\n}\n```\n\n## Итого\n\nГонки данных — источник хаотичных, труднопроизводимых багов. **Всегда запускайте тесты с флагом -race** — детектор найдёт проблемы до production. Для простых счётчиков и флагов используйте **sync/atomic**: это быстрее мьютекса и явно выражает намерение. Для сложных инвариантов, затрагивающих несколько полей, **sync.Mutex** безопаснее и понятнее.\n"}