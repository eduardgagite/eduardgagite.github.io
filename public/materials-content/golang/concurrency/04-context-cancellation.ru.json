{"content":"\nПакет **context** — это \"нервная система\" Go-приложений. Он связывает все процессы воедино и позволяет управлять ими.\n\nПредставьте ситуацию:\n1. Пользователь делает HTTP запрос к вашему серверу.\n2. Сервер начинает сложный расчет и идет в базу данных.\n3. Пользователь передумал и закрыл вкладку браузера.\n\nБез контекста сервер продолжит считать и грузить базу, хотя результат уже никому не нужен.\nС контекстом сервер узнает об обрыве связи и **мгновенно отменит** все дочерние операции (запросы в БД, расчеты).\n\n## Как это работает\n\nКонтекст — это объект, который передается первым аргументом (**ctx**) во все функции.\n\n```\nfunc DoWork(ctx context.Context) {\n    // ...\n}\n```\n\nОн умеет три вещи:\n1. **Отмена**: Сигнализирует, что пора закругляться.\n2. **Таймаут**: Сигнализирует, что время вышло.\n3. **Значения**: Переносит данные (User ID, Trace ID) сквозь слои приложения.\n\n## Пример 1: Ручная отмена (WithCancel)\n\n```\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println(\"Воркер: Меня остановили!\")\n            return\n        default:\n            fmt.Println(\"Воркер: Работаю...\")\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n\n    go worker(ctx)\n\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Main: Хватит работать!\")\n    cancel()\n    \n    time.Sleep(1 * time.Second)\n}\n```\n\n## Пример 2: Таймаут (WithTimeout)\n\nСамый популярный кейс. Мы даем задаче 2 секунды. Если не успела — убиваем.\n\n```\nfunc longOperation(ctx context.Context) {\n    select {\n    case <-time.After(5 * time.Second):\n        fmt.Println(\"Успех!\")\n    case <-ctx.Done():\n        fmt.Println(\"Ошибка:\", ctx.Err()) // context deadline exceeded\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel()\n\n    longOperation(ctx)\n}\n```\n\n## Контекст в HTTP\n\nВ стандартном веб-сервере Go у каждого запроса (**http.Request**) уже есть контекст. Если клиент разорвет соединение, этот контекст автоматически отменится.\n\n```\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n\n    rows, err := db.QueryContext(ctx, \"SELECT * FROM huge_table\")\n    if err != nil {\n        fmt.Println(\"Запрос прерван:\", err)\n        return\n    }\n}\n```\n\n## Итог\n\n1. **Всегда передавайте ctx первым аргументом** в функции, которые занимаются I/O (сеть, диск, база).\n2. **Проверяйте ctx.Done()**, если делаете долгие вычисления в цикле.\n3. Используйте **WithTimeout**, чтобы ваше приложение не висело вечно, если внешний сервис тупит.\n4. Никогда не храните контекст в структурах. Передавайте его явно через аргументы.\n"}