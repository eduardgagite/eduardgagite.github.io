{"content":"\nПакет `context` — это \"нервная система\" Go-приложений. Он связывает все процессы воедино и позволяет управлять ими.\n\nПредставьте ситуацию:\n1. Пользователь делает HTTP запрос к вашему серверу.\n2. Сервер начинает сложный расчет и идет в базу данных.\n3. Пользователь передумал и закрыл вкладку браузера.\n\nБез контекста сервер продолжит считать и грузить базу, хотя результат уже никому не нужен.\nС контекстом сервер узнает об обрыве связи и **мгновенно отменит** все дочерние операции (запросы в БД, расчеты).\n\n## Как это работает\n\nКонтекст — это объект, который передается первым аргументом (`ctx`) во все функции.\n\n```go\nfunc DoWork(ctx context.Context) {\n    // ...\n}\n```\n\nОн умеет три вещи:\n1. **Отмена**: Сигнализирует, что пора закругляться.\n2. **Таймаут**: Сигнализирует, что время вышло.\n3. **Значения**: Переносит данные (User ID, Trace ID) сквозь слои приложения.\n\n## Пример 1: Ручная отмена (WithCancel)\n\n```go\nfunc worker(ctx context.Context) {\n    for {\n        select {\n        case <-ctx.Done(): // Слушаем сигнал отмены\n            fmt.Println(\"Воркер: Меня остановили!\")\n            return // Выходим из функции\n        default:\n            fmt.Println(\"Воркер: Работаю...\")\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n\nfunc main() {\n    // Создаем контекст с функцией отмены\n    ctx, cancel := context.WithCancel(context.Background())\n\n    go worker(ctx)\n\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Main: Хватит работать!\")\n    cancel() // <-- Нажимаем кнопку СТОП\n    \n    time.Sleep(1 * time.Second) // Даем время на выход\n}\n```\n\n## Пример 2: Таймаут (WithTimeout)\n\nСамый популярный кейс. Мы даем задаче 2 секунды. Если не успела — убиваем.\n\n```go\nfunc longOperation(ctx context.Context) {\n    select {\n    case <-time.After(5 * time.Second): // Работа на 5 секунд\n        fmt.Println(\"Успех!\")\n    case <-ctx.Done(): // Но контекст умрет раньше\n        fmt.Println(\"Ошибка:\", ctx.Err()) // context deadline exceeded\n    }\n}\n\nfunc main() {\n    // Контекст проживет ровно 2 секунды\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel() // Всегда вызывайте cancel, чтобы не было утечек памяти!\n\n    longOperation(ctx)\n}\n```\n\n## Контекст в HTTP\n\nВ стандартном веб-сервере Go у каждого запроса (`http.Request`) уже есть контекст. Если клиент разорвет соединение, этот контекст автоматически отменится.\n\n```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context() // Получаем контекст запроса\n\n    // Передаем этот контекст в базу данных\n    // Если пользователь уйдет, запрос к БД тоже отменится!\n    rows, err := db.QueryContext(ctx, \"SELECT * FROM huge_table\")\n    if err != nil {\n        fmt.Println(\"Запрос прерван:\", err)\n        return\n    }\n}\n```\n\n## Итог\n\n1. **Всегда передавайте ctx первым аргументом** в функции, которые занимаются I/O (сеть, диск, база).\n2. **Проверяйте ctx.Done()**, если делаете долгие вычисления в цикле.\n3. Используйте **WithTimeout**, чтобы ваше приложение не висело вечно, если внешний сервис тупит.\n4. Никогда не храните контекст в структурах. Передавайте его явно через аргументы.\n"}