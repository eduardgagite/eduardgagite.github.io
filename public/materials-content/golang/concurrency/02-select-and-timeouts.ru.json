{"content":"\nВ реальных системах мы часто ждем ответа сразу от нескольких источников.\n- Пример: Мы делаем запрос в быстрый кэш и в медленную базу данных. Кто ответит первым, того и берем.\n- Пример: Мы ждем ответа от сервера, но не хотим ждать дольше 5 секунд.\n\nДля таких ситуаций в Go есть оператор **select**. Он позволяет горутине ждать на нескольких каналах одновременно.\n\n## Как работает select\n\n**select** синтаксически похож на **switch**, но вместо условий в **case** стоят операции с каналами (чтение или запись).\n\n```\nselect {\ncase msg1 := <-ch1:\n    fmt.Println(\"Пришло от ch1:\", msg1)\ncase msg2 := <-ch2:\n    fmt.Println(\"Пришло от ch2:\", msg2)\n}\n```\n\n**Логика работы**:\n1. **select** смотрит на все **case** сразу.\n2. Если **никто не готов** (каналы пусты), он **блокируется** и ждет.\n3. Если **один готов**, он выполняет этот **case** и выходит.\n4. Если **готовы несколько** (пришли сообщения одновременно), он выбирает один из них **случайно**.\n\n## Паттерн: Таймаут (Timeout)\n\nЭто самый частый случай использования **select**. Мы хотим получить данные, но если это занимает слишком много времени — отменить операцию.\n\nДля этого используем функцию **time.After(duration)**. Она возвращает канал, в который \"прилетит\" текущее время через заданный промежуток.\n\n```\nfunc main() {\n    ch := make(chan string)\n\n    go func() {\n        time.Sleep(5 * time.Second)\n        ch <- \"Результат\"\n    }()\n\n    select {\n    case res := <-ch:\n        fmt.Println(\"Успех:\", res)\n    case <-time.After(2 * time.Second):\n        fmt.Println(\"Таймаут! Слишком долго.\")\n    }\n}\n```\n\nВ этом примере через 2 секунды канал от **time.After** станет готов первым. **select** выберет его ветку, напечатает \"Таймаут\" и завершится. Программа не зависнет на 5 секунд.\n\n## Паттерн: Неблокирующее чтение (Non-blocking read)\n\nИногда нам нужно проверить: \"Есть ли что-то в канале прямо сейчас?\". Если нет — мы не хотим ждать, хотим делать другие дела.\n\nДля этого добавляют секцию **default**.\n\n```\nselect {\ncase msg := <-ch:\n    fmt.Println(\"Получено:\", msg)\ndefault:\n    fmt.Println(\"В канале пусто, иду работать дальше\")\n}\n```\n\n## Паттерн: Завершение (Quit channel)\n\nКак аккуратно остановить горутину, которая крутится в бесконечном цикле? Послать ей сигнал в специальный канал **done** или **quit**.\n\n```\nfunc worker(done chan bool) {\n    for {\n        select {\n        case <-done:\n            fmt.Println(\"Получен сигнал стоп. Выхожу.\")\n            return\n        default:\n            fmt.Println(\"Работаю...\")\n            time.Sleep(500 * time.Millisecond)\n        }\n    }\n}\n\nfunc main() {\n    done := make(chan bool)\n    go worker(done)\n\n    time.Sleep(2 * time.Second)\n    done <- true\n    time.Sleep(100 * time.Millisecond)\n}\n```\n\n## Итог\n\n1. **select** — это диспетчер каналов. Он ждет, кто первый ответит.\n2. Используйте **time.After** внутри **select**, чтобы не зависать навечно.\n3. Используйте **default**, чтобы не блокироваться, если данных нет.\n"}