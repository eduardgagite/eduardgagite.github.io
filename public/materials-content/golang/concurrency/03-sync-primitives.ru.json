{"content":"\nКаналы — это здорово, но это не единственный способ писать параллельный код. Иногда нам нужно просто защитить переменную от одновременной записи или подождать группу задач.\n\nДля этого в Go есть пакет `sync`. Это классические инструменты, которые вы могли видеть в Java или C++.\n\n## Проблема: Состояние гонки (Race Condition)\n\nПредставьте счетчик лайков.\n\n```go\ncount := 0\nfor i := 0; i < 1000; i++ {\n    go func() {\n        count++ // ОПАСНО!\n    }()\n}\n```\n\nЕсли запустить этот код, `count` никогда не будет 1000. Он будет 950, 998 или 800.\nПочему? Потому что операция `count++` на самом деле состоит из трёх шагов:\n1. Прочитать `count` (например, 5).\n2. Прибавить 1 (получилось 6).\n3. Записать 6 обратно.\n\nДве горутины могут прочитать \"5\" одновременно, обе прибавят 1, и обе запишут \"6\". Одно увеличение потерялось.\n\n## Решение 1: Mutex (Мьютекс)\n\n`sync.Mutex` — это замок. Он гарантирует, что кусок кода выполняется **только одной** горутиной в один момент времени.\n\n```go\nimport \"sync\"\n\ntype SafeCounter struct {\n    mu    sync.Mutex\n    count int\n}\n\nfunc (c *SafeCounter) Inc() {\n    c.mu.Lock()   // <-- Закрываем дверь. Другие ждут здесь.\n    c.count++     // <-- Безопасно меняем\n    c.mu.Unlock() // <-- Открываем дверь. Следующий!\n}\n```\n\n**Золотое правило**: Всегда используйте `defer`, чтобы разблокировать мьютекс, даже если случится паника.\n\n```go\nfunc (c *SafeCounter) Inc() {\n    c.mu.Lock()\n    defer c.mu.Unlock() // Гарантированно выполнится в конце\n    \n    c.count++\n}\n```\n\n### RWMutex (Read-Write)\n\nЕсли у вас данные часто читают (1000 раз/сек), но редко пишут (1 раз/час), обычный `Mutex` будет всех тормозить.\n`sync.RWMutex` позволяет:\n- **Многим** читать одновременно (`RLock`).\n- Но только **одному** писать (`Lock`), выгоняя всех читателей.\n\n## Решение 2: WaitGroup (Группа ожидания)\n\nКак подождать завершения 10 горутин? `time.Sleep` — это плохой способ. Правильный способ — `sync.WaitGroup`.\n\nЭто как счетчик задач:\n1. `Add(1)` — добавили задачу.\n2. `Done()` — задача выполнена (вычитает 1).\n3. `Wait()` — стоим и ждем, пока счетчик не станет 0.\n\n```go\nfunc main() {\n    var wg sync.WaitGroup\n\n    for i := 1; i <= 5; i++ {\n        wg.Add(1) // +1 задача\n        \n        go func(id int) {\n            defer wg.Done() // -1 задача (в конце)\n            fmt.Printf(\"Воркер %d работает...\\n\", id)\n        }(i)\n    }\n\n    wg.Wait() // Ждем, пока все закончат\n    fmt.Println(\"Все готово\")\n}\n```\n\n## Решение 3: Once (Единожды)\n\nИногда нужно сделать что-то ровно один раз. Например, подключиться к базе данных при первом запросе (Lazy Initialization).\n\nДаже если 100 горутин вызовут `once.Do` одновременно, функция внутри выполнится только один раз.\n\n```go\nvar once sync.Once\nvar db *Database\n\nfunc GetDB() *Database {\n    once.Do(func() {\n        fmt.Println(\"Подключаюсь к БД... (только 1 раз)\")\n        db = connect()\n    })\n    return db\n}\n```\n\n## Итог\n\n1. Если данные меняют из разных горутин — нужен `Mutex`.\n2. Если нужно дождаться окончания пачки горутин — `WaitGroup`.\n3. Если нужно инициализировать что-то лениво и безопасно — `Once`.\n4. Используйте `go run -race main.go`, чтобы Go сам проверил ваш код на наличие гонок!\n"}