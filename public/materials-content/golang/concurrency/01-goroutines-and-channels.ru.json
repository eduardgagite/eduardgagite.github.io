{"content":"\nКонкурентность (Concurrency) — это способность программы справляться с множеством задач одновременно. Не обязательно выполнять их в один момент времени (это параллелизм), но быть готовой переключаться между ними.\n\nGo прославился именно своей моделью конкурентности, которая встроена в язык, а не добавлена библиотеками.\n\n## Проблема потоков в других языках\n\nВ классических языках (Java, C++, Python) каждый поток (Thread) — это тяжелый ресурс операционной системы.\n1. Он занимает много памяти (обычно 1-2 МБ на стек).\n2. Его создание и переключение занимает время (Context Switch).\n3. Если вы запустите 100 000 потоков, ваш сервер \"умрет\" от нехватки памяти.\n\n## Решение Go: Горутины (Goroutines)\n\nГорутина — это **легковесный поток**, управляемый самим Go Runtime, а не операционной системой.\n\n- **Память**: Занимает всего ~2 КБ при старте (растягивается при необходимости).\n- **Цена**: Переключение между ними почти мгновенное.\n- **Масштаб**: Можно запустить **миллионы** горутин на обычном ноутбуке.\n\n### Как запустить горутину\n\nДостаточно добавить слово `go` перед вызовом любой функции.\n\n```go\nfunc worker(id int) {\n    fmt.Printf(\"Воркер %d начал работу\\n\", id)\n    time.Sleep(time.Second) // Симуляция работы\n    fmt.Printf(\"Воркер %d закончил\\n\", id)\n}\n\nfunc main() {\n    // Запускаем 3 задачи параллельно\n    go worker(1)\n    go worker(2)\n    go worker(3)\n\n    // ВАЖНО: Если main завершится, все горутины будут убиты!\n    // Нам нужно подождать их. Пока используем \"грязный хак\" со сном.\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Программа завершена\")\n}\n```\n\nВ консоли вы увидите, что воркеры начали работу почти одновременно, а не по очереди.\n\n---\n\n## Каналы (Channels)\n\nКогда у вас много горутин, возникает проблема: как им обмениваться данными и не мешать друг другу?\n\nВ других языках используют общую память (Shared Memory) и замки (Mutex), чтобы две функции не писали в одну переменную одновременно. Это сложно, опасно (Deadlocks) и чревато ошибками.\n\nФилософия Go:\n> **\"Не общайтесь через общую память; используйте каналы, чтобы пересылать память\"**.\n\nКанал — это \"труба\", соединяющая горутины. Одна кладет данные с одного конца, другая забирает с другого.\n\n### Синтаксис\n\nКаналы строго типизированы.\n- `make(chan int)` — создать канал для чисел.\n- `ch <- 5` — отправить (записать) данные в канал.\n- `val := <-ch` — получить (прочитать) данные из канала.\n\n### Блокировка (Ключевой момент!)\n\nКаналы по умолчанию **небуферизированные**. Это значит, что они обеспечивают **синхронизацию**:\n\n1. **Отправка блокирует**: Если вы пишете `ch <- 5`, горутина остановится и будет ждать, пока кто-нибудь не начнет читать из этого канала.\n2. **Чтение блокирует**: Если вы пишете `val := <-ch`, горутина остановится и будет ждать, пока кто-нибудь что-то туда положит.\n\nЭто как передача эстафетной палочки: бегун не может отдать палочку, если её никто не берет, и не может бежать дальше, пока не отдаст.\n\n```go\nfunc main() {\n    messages := make(chan string)\n\n    go func() {\n        fmt.Println(\"Горутина: Готовлю сообщение...\")\n        time.Sleep(2 * time.Second)\n        messages <- \"Привет, мир!\" // Блокируемся, пока main не прочитает\n        fmt.Println(\"Горутина: Сообщение отправлено\")\n    }()\n\n    fmt.Println(\"Main: Жду сообщения...\")\n    msg := <-messages // Блокируемся и ждем 2 секунды\n    fmt.Println(\"Main: Получил:\", msg)\n}\n```\n\n### Буферизированные каналы\n\nИногда нам не нужна жесткая синхронизация. Мы хотим положить письмо в почтовый ящик и уйти, даже если почтальон его еще не забрал.\n\nДля этого создают канал с **емкостью** (buffer).\n\n```go\n// Канал с буфером на 2 сообщения\nch := make(chan string, 2)\n\nch <- \"сообщение 1\" // Ок, сразу идем дальше\nch <- \"сообщение 2\" // Ок, сразу идем дальше\n\n// ch <- \"сообщение 3\" // СТОП! Буфер полон. Тут мы заблокируемся.\n\nfmt.Println(<-ch) // \"сообщение 1\"\n// Теперь в буфере освободилось одно место\n```\n\n### Закрытие канала\n\nОтправитель может закрыть канал, чтобы сказать: \"Всё, данных больше не будет\".\n\n```go\nclose(ch)\n```\n\nПолучатель может проверить это:\n\n```go\nmsg, ok := <-ch\nif !ok {\n    fmt.Println(\"Канал закрыт и пуст\")\n}\n```\n\nИли читать в цикле `range` (самый удобный способ):\n\n```go\nfor msg := range ch {\n    fmt.Println(msg)\n}\n// Цикл закончится сам, когда канал закроют\n```\n\n## Итог\n\n1. **Горутины** — дешевый способ делать дела параллельно.\n2. **Каналы** — способ безопасного общения между горутинами.\n3. По умолчанию каналы блокируют выполнение (ждут партнера).\n4. Используйте `range` для чтения из канала, пока он не закроется.\n"}