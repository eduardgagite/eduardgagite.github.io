{"content":"\nКогда проект вырастает за пределы одного файла `main.go`, встает вопрос: как всё разложить, чтобы не запутаться?\n\nВ Go есть **стандартный лейаут**, который не является законом, но принят сообществом. Если вы ему следуете, любому Go-разработчику будет легко разобраться в вашем проекте.\n\n## Плоская структура (маленькие проекты)\n\nЕсли у вас микросервис или утилита на 5-15 файлов, **не усложняйте**. Положите всё в корень.\n\n```\nmy-tool/\n├── go.mod\n├── go.sum\n├── main.go        # Точка входа\n├── handler.go     # HTTP обработчики\n├── storage.go     # Работа с БД\n└── config.go      # Конфигурация\n```\n\nЭто нормально и правильно. Не нужно создавать папки ради папок.\n\n## Стандартная структура (средние и большие проекты)\n\nКогда проект растет и в команде больше 2-3 человек, код разделяют на слои.\n\n```\nmy-project/\n├── cmd/                    # Точки входа\n│   ├── api/\n│   │   └── main.go         # Запуск API сервера\n│   └── worker/\n│       └── main.go         # Запуск фонового воркера\n│\n├── internal/               # Приватный код (не виден извне)\n│   ├── user/\n│   │   ├── model.go        # Структуры: User, CreateUserRequest\n│   │   ├── handler.go      # HTTP обработчики для /users\n│   │   ├── service.go      # Бизнес-логика\n│   │   └── repository.go   # Запросы к базе данных\n│   ├── order/\n│   │   ├── model.go\n│   │   └── service.go\n│   └── middleware/\n│       └── auth.go         # Аутентификация\n│\n├── pkg/                    # Публичные библиотеки\n│   └── logger/\n│       └── logger.go       # Можно использовать в других проектах\n│\n├── migrations/             # SQL миграции\n├── configs/                # Конфигурационные файлы\n├── go.mod\n├── go.sum\n└── Makefile\n```\n\n### Разбор папок\n\n### cmd/\n\nЗдесь лежат **точки входа** (файлы с `package main` и `func main()`). Логики тут минимум — только инициализация зависимостей и запуск.\n\nЗачем отдельная папка? Потому что у проекта может быть несколько бинарников: API-сервер, фоновый воркер, CLI-утилита для миграций.\n\n```go\n// cmd/api/main.go\npackage main\n\nfunc main() {\n    cfg := config.Load()\n    db := database.Connect(cfg.DatabaseURL)\n    server := api.NewServer(db)\n    server.Run(cfg.Port)\n}\n```\n\n### internal/\n\nЭто **магическая папка** в Go. Компилятор **запрещает** импортировать код из `internal/` другим модулям. Даже если кто-то напишет `import \"github.com/you/project/internal/user\"` — код не скомпилируется.\n\nЭто ваш способ сказать: \"Это внутренности моего приложения. Не привязывайтесь к ним, я могу всё переделать завтра\".\n\n### pkg/\n\nКод, который вы **не против** дать другим. Например, универсальный логгер или HTTP-клиент.\n\nЕсли сомневаетесь — кладите в `internal/`. Всегда можно перенести в `pkg/` позже, но обратный путь сложнее (кто-то мог уже начать использовать ваш пакет).\n\n## Группировка по фичам vs по слоям\n\n### По слоям (как в Java)\n\n```\ninternal/\n├── models/      # Все модели\n├── handlers/    # Все обработчики\n├── services/    # Вся логика\n└── repositories/ # Все запросы к БД\n```\n\nПроблема: чтобы понять, как работает \"пользователь\", нужно прыгать между 4 папками.\n\n### По фичам (рекомендуется в Go)\n\n```\ninternal/\n├── user/        # Всё про пользователя в одном месте\n├── order/       # Всё про заказ в одном месте\n└── payment/     # Всё про оплату в одном месте\n```\n\nПреимущество: вся логика одной фичи — рядом. Открыл папку `user/` — и видишь полную картину.\n\n## Чего делать НЕ надо\n\n1. **Не создавайте папку src/**. Это привычка из Java. В Go весь код — это уже \"src\".\n2. **Не создавайте пакет utils/**. Это помойка, в которую складывают всё подряд. Лучше назовите пакет по смыслу: `httputil`, `stringutil`.\n3. **Избегайте циклических зависимостей**. Пакет A не может импортировать B, если B уже импортирует A. Если столкнулись с этим — значит, нужно пересмотреть границы пакетов.\n\n## Итог\n\n1. **Начинайте просто**. Один `main.go` в корне — нормально.\n2. Когда растете — создайте `cmd/` и `internal/`.\n3. Группируйте по **фичам**, а не по слоям.\n4. Используйте `internal/`, чтобы защитить внутренности от внешнего использования.\n"}