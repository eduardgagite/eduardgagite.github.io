{"content":"\nКогда проект вырастает за пределы одного файла **main.go**, встает вопрос: как всё разложить, чтобы не запутаться?\n\nВ Go есть **стандартный лейаут**, который не является законом, но принят сообществом. Если вы ему следуете, любому Go-разработчику будет легко разобраться в вашем проекте.\n\n## Плоская структура (маленькие проекты)\n\nЕсли у вас микросервис или утилита на 5-15 файлов, **не усложняйте**. Положите всё в корень.\n\n```\nmy-tool/\n├── go.mod\n├── go.sum\n├── main.go\n├── handler.go\n├── storage.go\n└── config.go\n```\n\nЭто нормально и правильно. Не нужно создавать папки ради папок.\n\n## Стандартная структура (средние и большие проекты)\n\nКогда проект растет и в команде больше 2-3 человек, код разделяют на слои.\n\n```\nmy-project/\n├── cmd/\n│   ├── api/\n│   │   └── main.go\n│   └── worker/\n│       └── main.go\n│\n├── internal/\n│   ├── user/\n│   │   ├── model.go\n│   │   ├── handler.go\n│   │   ├── service.go\n│   │   └── repository.go\n│   ├── order/\n│   │   ├── model.go\n│   │   └── service.go\n│   └── middleware/\n│       └── auth.go\n│\n├── pkg/\n│   └── logger/\n│       └── logger.go\n│\n├── migrations/\n├── configs/\n├── go.mod\n├── go.sum\n└── Makefile\n```\n\n### Разбор папок\n\n### cmd/\n\nЗдесь лежат **точки входа** (файлы с **package main** и **func main()**). Логики тут минимум — только инициализация зависимостей и запуск.\n\nЗачем отдельная папка? Потому что у проекта может быть несколько бинарников: API-сервер, фоновый воркер, CLI-утилита для миграций.\n\n```\npackage main\n\nfunc main() {\n    cfg := config.Load()\n    db := database.Connect(cfg.DatabaseURL)\n    server := api.NewServer(db)\n    server.Run(cfg.Port)\n}\n```\n\n### internal/\n\nЭто **магическая папка** в Go. Компилятор **запрещает** импортировать код из **internal/** другим модулям. Даже если кто-то напишет **import \"github.com/you/project/internal/user\"** — код не скомпилируется.\n\nЭто ваш способ сказать: \"Это внутренности моего приложения. Не привязывайтесь к ним, я могу всё переделать завтра\".\n\n### pkg/\n\nКод, который вы **не против** дать другим. Например, универсальный логгер или HTTP-клиент.\n\nЕсли сомневаетесь — кладите в **internal/**. Всегда можно перенести в **pkg/** позже, но обратный путь сложнее (кто-то мог уже начать использовать ваш пакет).\n\n## Группировка по фичам vs по слоям\n\n### По слоям (как в Java)\n\n```\ninternal/\n├── models/\n├── handlers/\n├── services/\n└── repositories/\n```\n\nПроблема: чтобы понять, как работает \"пользователь\", нужно прыгать между 4 папками.\n\n### По фичам (рекомендуется в Go)\n\n```\ninternal/\n├── user/\n├── order/\n└── payment/\n```\n\nПреимущество: вся логика одной фичи — рядом. Открыл папку user/ — и видишь полную картину.\n\n## Чего делать НЕ надо\n\n1. **Не создавайте папку src/**. Это привычка из Java. В Go весь код — это уже \"src\".\n2. **Не создавайте пакет utils/**. Это помойка, в которую складывают всё подряд. Лучше назовите пакет по смыслу: **httputil**, **stringutil**.\n3. **Избегайте циклических зависимостей**. Пакет A не может импортировать B, если B уже импортирует A. Если столкнулись с этим — значит, нужно пересмотреть границы пакетов.\n\n## Итог\n\n1. **Начинайте просто**. Один **main.go** в корне — нормально.\n2. Когда растете — создайте **cmd/** и **internal/**.\n3. Группируйте по **фичам**, а не по слоям.\n4. Используйте **internal/**, чтобы защитить внутренности от внешнего использования.\n"}