{"content":"\nИногда нужно выполнить несколько SQL-запросов как одну атомарную операцию: либо все выполнились, либо ни один. Например, перевод денег: списать с одного счета и зачислить на другой. Если программа упадет между двумя запросами — деньги пропадут.\n\nДля этого существуют **транзакции**.\n\n## Транзакция (Transaction)\n\nТранзакция гарантирует: если что-то пошло не так, все изменения откатятся назад, как будто ничего не было.\n\n```\nfunc transferMoney(db *sql.DB, from, to int, amount int) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n\n    _, err = tx.Exec(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", amount, from)\n    if err != nil {\n        tx.Rollback()\n        return err\n    }\n\n    _, err = tx.Exec(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", amount, to)\n    if err != nil {\n        tx.Rollback()\n        return err\n    }\n\n    return tx.Commit()\n}\n```\n\n### Паттерн с defer\n\nЧтобы не забыть откатить транзакцию при ошибке:\n\n```\nfunc transferMoney(db *sql.DB, from, to int, amount int) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    if _, err := tx.Exec(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", amount, from); err != nil {\n        return err\n    }\n\n    if _, err := tx.Exec(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", amount, to); err != nil {\n        return err\n    }\n\n    return tx.Commit()\n}\n```\n\n## Подготовленные выражения (Prepared Statements)\n\nЕсли вы выполняете один и тот же запрос много раз (например, вставка 1000 строк), выгоднее \"подготовить\" его один раз, а потом многократно выполнять с разными параметрами.\n\n```\nstmt, err := db.Prepare(\"INSERT INTO users (name, email) VALUES ($1, $2)\")\nif err != nil {\n    panic(err)\n}\ndefer stmt.Close()\n\nusers := []struct{ Name, Email string }{\n    {\"Alice\", \"alice@mail.com\"},\n    {\"Bob\", \"bob@mail.com\"},\n    {\"Charlie\", \"charlie@mail.com\"},\n}\n\nfor _, u := range users {\n    _, err := stmt.Exec(u.Name, u.Email)\n    if err != nil {\n        fmt.Printf(\"Ошибка при вставке %s: %v\\n\", u.Name, err)\n    }\n}\n```\n\n### Зачем это?\n\n1. **Производительность**: БД парсит и оптимизирует запрос один раз, а не тысячу.\n2. **Безопасность**: Параметры автоматически экранируются (защита от SQL-инъекций).\n\n## Сканирование в структуру\n\nНа практике результаты запросов часто сканируют в структуры.\n\n```\ntype User struct {\n    ID    int\n    Name  string\n    Email string\n}\n\nfunc getUserByID(db *sql.DB, id int) (*User, error) {\n    var u User\n    err := db.QueryRow(\n        \"SELECT id, name, email FROM users WHERE id = $1\", id,\n    ).Scan(&u.ID, &u.Name, &u.Email)\n\n    if err == sql.ErrNoRows {\n        return nil, nil\n    }\n    if err != nil {\n        return nil, err\n    }\n    return &u, nil\n}\n```\n\n## Итог\n\n1. **Транзакции** гарантируют атомарность: либо все запросы выполнились, либо ни один.\n2. Используйте **defer tx.Rollback()** сразу после **Begin()**.\n3. **Prepared Statements** ускоряют массовые операции.\n4. Порядок полей в **Scan()** должен совпадать с порядком столбцов в **SELECT**.\n"}