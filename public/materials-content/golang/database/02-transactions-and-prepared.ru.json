{"content":"\nИногда нужно выполнить несколько SQL-запросов как одну атомарную операцию: либо все выполнились, либо ни один. Например, перевод денег: списать с одного счета и зачислить на другой. Если программа упадет между двумя запросами — деньги пропадут.\n\nДля этого существуют **транзакции**.\n\n## Транзакция (Transaction)\n\nТранзакция гарантирует: если что-то пошло не так, все изменения откатятся назад, как будто ничего не было.\n\n```go\nfunc transferMoney(db *sql.DB, from, to int, amount int) error {\n    // Начинаем транзакцию\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n\n    // Списываем деньги\n    _, err = tx.Exec(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", amount, from)\n    if err != nil {\n        tx.Rollback() // Откатываем все изменения\n        return err\n    }\n\n    // Зачисляем деньги\n    _, err = tx.Exec(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", amount, to)\n    if err != nil {\n        tx.Rollback() // Откатываем все изменения\n        return err\n    }\n\n    // Всё прошло хорошо — фиксируем\n    return tx.Commit()\n}\n```\n\n### Паттерн с defer\n\nЧтобы не забыть откатить транзакцию при ошибке:\n\n```go\nfunc transferMoney(db *sql.DB, from, to int, amount int) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return err\n    }\n    // Если мы не дойдем до Commit, откатим всё\n    defer tx.Rollback()\n\n    if _, err := tx.Exec(\"UPDATE accounts SET balance = balance - $1 WHERE id = $2\", amount, from); err != nil {\n        return err\n    }\n\n    if _, err := tx.Exec(\"UPDATE accounts SET balance = balance + $1 WHERE id = $2\", amount, to); err != nil {\n        return err\n    }\n\n    // Если дошли сюда, значит ошибок нет\n    return tx.Commit() // Rollback после Commit — безопасен (ничего не сделает)\n}\n```\n\n## Подготовленные выражения (Prepared Statements)\n\nЕсли вы выполняете один и тот же запрос много раз (например, вставка 1000 строк), выгоднее \"подготовить\" его один раз, а потом многократно выполнять с разными параметрами.\n\n```go\n// Подготавливаем запрос один раз\nstmt, err := db.Prepare(\"INSERT INTO users (name, email) VALUES ($1, $2)\")\nif err != nil {\n    panic(err)\n}\ndefer stmt.Close()\n\n// Выполняем много раз с разными данными\nusers := []struct{ Name, Email string }{\n    {\"Alice\", \"alice@mail.com\"},\n    {\"Bob\", \"bob@mail.com\"},\n    {\"Charlie\", \"charlie@mail.com\"},\n}\n\nfor _, u := range users {\n    _, err := stmt.Exec(u.Name, u.Email)\n    if err != nil {\n        fmt.Printf(\"Ошибка при вставке %s: %v\\n\", u.Name, err)\n    }\n}\n```\n\n### Зачем это?\n\n1. **Производительность**: БД парсит и оптимизирует запрос один раз, а не тысячу.\n2. **Безопасность**: Параметры автоматически экранируются (защита от SQL-инъекций).\n\n## Сканирование в структуру\n\nНа практике результаты запросов часто сканируют в структуры.\n\n```go\ntype User struct {\n    ID    int\n    Name  string\n    Email string\n}\n\nfunc getUserByID(db *sql.DB, id int) (*User, error) {\n    var u User\n    err := db.QueryRow(\n        \"SELECT id, name, email FROM users WHERE id = $1\", id,\n    ).Scan(&u.ID, &u.Name, &u.Email)\n\n    if err == sql.ErrNoRows {\n        return nil, nil // Не найден\n    }\n    if err != nil {\n        return nil, err\n    }\n    return &u, nil\n}\n```\n\n## Итог\n\n1. **Транзакции** гарантируют атомарность: либо все запросы выполнились, либо ни один.\n2. Используйте `defer tx.Rollback()` сразу после `Begin()`.\n3. **Prepared Statements** ускоряют массовые операции.\n4. Порядок полей в `Scan()` должен совпадать с порядком столбцов в `SELECT`.\n"}