{"content":"\nБольшинство бэкендов работают с реляционными базами данных (PostgreSQL, MySQL, SQLite). В Go для этого есть стандартный пакет `database/sql`.\n\nОн не привязан к конкретной БД — это абстракция. Конкретную БД подключает **драйвер** (отдельная библиотека).\n\n## Установка драйвера\n\nДля PostgreSQL:\n\n```bash\ngo get github.com/lib/pq\n```\n\nДля MySQL:\n\n```bash\ngo get github.com/go-sql-driver/mysql\n```\n\n## Подключение\n\n```go\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/lib/pq\" // Импорт через _ — регистрирует драйвер\n)\n\nfunc main() {\n    // Строка подключения\n    connStr := \"host=localhost port=5432 user=myuser password=secret dbname=mydb sslmode=disable\"\n\n    // Открываем пул соединений (это НЕ одно соединение!)\n    db, err := sql.Open(\"postgres\", connStr)\n    if err != nil {\n        panic(err)\n    }\n    defer db.Close()\n\n    // Проверяем, что соединение работает\n    if err := db.Ping(); err != nil {\n        panic(fmt.Sprintf(\"БД недоступна: %v\", err))\n    }\n\n    fmt.Println(\"Подключено к БД!\")\n}\n```\n\n### Важно: sql.Open НЕ подключается к БД\n\n`sql.Open` только создает объект `*sql.DB` — это **пул соединений**. Реальное подключение произойдет при первом запросе (или при вызове `db.Ping()`).\n\n### Настройка пула\n\nПул соединений управляет тем, сколько подключений к БД открыто одновременно.\n\n```go\ndb.SetMaxOpenConns(25)              // Макс. соединений к БД\ndb.SetMaxIdleConns(10)              // Макс. простаивающих соединений\ndb.SetConnMaxLifetime(5 * time.Minute) // Время жизни соединения\n```\n\nБез этих настроек Go будет открывать соединения бесконтрольно, что может перегрузить базу данных.\n\n## Выполнение запросов\n\n### SELECT (одна строка)\n\n```go\nvar name string\nvar age int\n\nerr := db.QueryRow(\"SELECT name, age FROM users WHERE id = $1\", 42).Scan(&name, &age)\n\nif err == sql.ErrNoRows {\n    fmt.Println(\"Пользователь не найден\")\n} else if err != nil {\n    fmt.Println(\"Ошибка:\", err)\n} else {\n    fmt.Printf(\"Имя: %s, Возраст: %d\\n\", name, age)\n}\n```\n\n`$1` — это placeholder (заполнитель). Go автоматически экранирует значения, защищая от SQL-инъекций. **Никогда** не склеивайте запросы через `fmt.Sprintf`!\n\n### SELECT (несколько строк)\n\n```go\nrows, err := db.Query(\"SELECT id, name FROM users WHERE age > $1\", 18)\nif err != nil {\n    panic(err)\n}\ndefer rows.Close() // Обязательно!\n\nfor rows.Next() {\n    var id int\n    var name string\n    if err := rows.Scan(&id, &name); err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"ID: %d, Имя: %s\\n\", id, name)\n}\n\n// Проверяем, не было ли ошибки во время итерации\nif err := rows.Err(); err != nil {\n    panic(err)\n}\n```\n\n### INSERT / UPDATE / DELETE\n\nДля запросов, которые не возвращают строки, используйте `Exec`.\n\n```go\nresult, err := db.Exec(\"INSERT INTO users (name, age) VALUES ($1, $2)\", \"Alice\", 30)\nif err != nil {\n    panic(err)\n}\n\n// Количество затронутых строк\nrowsAffected, _ := result.RowsAffected()\nfmt.Printf(\"Добавлено строк: %d\\n\", rowsAffected)\n\n// ID последней вставленной строки (работает не во всех БД)\nlastID, _ := result.LastInsertId()\nfmt.Printf(\"ID: %d\\n\", lastID)\n```\n\n## Запросы с контекстом\n\nВ продакшене всегда передавайте контекст, чтобы запрос можно было отменить.\n\n```go\nctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\ndefer cancel()\n\nrow := db.QueryRowContext(ctx, \"SELECT name FROM users WHERE id = $1\", 42)\n```\n\nЕсли запрос не выполнится за 3 секунды, он будет отменен.\n\n## Итог\n\n1. `sql.Open` создает **пул соединений**, а не одно соединение.\n2. Настройте пул: `SetMaxOpenConns`, `SetMaxIdleConns`.\n3. Используйте **placeholders** (`$1`, `$2`) для защиты от SQL-инъекций.\n4. Не забывайте `defer rows.Close()` и `defer db.Close()`.\n5. В продакшене передавайте `context` через `QueryContext` / `ExecContext`.\n"}