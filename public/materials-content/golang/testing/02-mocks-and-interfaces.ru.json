{"content":"\nТестировать чистые функции (вход -> выход) легко. Но что если ваш код ходит в базу данных, отправляет HTTP-запросы или пишет в файл? Запускать реальную БД для каждого теста — медленно и ненадежно.\n\nРешение: **подмена зависимостей** через интерфейсы.\n\n## Проблема\n\n```\ntype UserService struct{}\n\nfunc (s *UserService) GetUser(id int) (*User, error) {\n    row := db.QueryRow(\"SELECT name FROM users WHERE id = $1\", id)\n}\n```\n\nЧтобы протестировать **GetUser**, нам нужна работающая БД с данными. Это сложно, медленно и хрупко.\n\n## Решение: Интерфейс + Подмена\n\n### Шаг 1: Выделяем интерфейс\n\nВместо прямого обращения к БД, сервис работает через **интерфейс**.\n\n```\ntype UserRepository interface {\n    FindByID(id int) (*User, error)\n}\n\ntype UserService struct {\n    repo UserRepository\n}\n\nfunc NewUserService(repo UserRepository) *UserService {\n    return &UserService{repo: repo}\n}\n\nfunc (s *UserService) GetUser(id int) (*User, error) {\n    user, err := s.repo.FindByID(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"не удалось найти пользователя: %w\", err)\n    }\n    return user, nil\n}\n```\n\n### Шаг 2: Реальная реализация (для продакшена)\n\n```\ntype PostgresUserRepo struct {\n    db *sql.DB\n}\n\nfunc (r *PostgresUserRepo) FindByID(id int) (*User, error) {\n    row := r.db.QueryRow(\"SELECT name, email FROM users WHERE id = $1\", id)\n    var u User\n    err := row.Scan(&u.Name, &u.Email)\n    return &u, err\n}\n```\n\n### Шаг 3: Фейковая реализация (для тестов)\n\n```\ntype FakeUserRepo struct {\n    users map[int]*User\n}\n\nfunc (r *FakeUserRepo) FindByID(id int) (*User, error) {\n    user, ok := r.users[id]\n    if !ok {\n        return nil, fmt.Errorf(\"user %d not found\", id)\n    }\n    return user, nil\n}\n```\n\n### Шаг 4: Тест\n\n```\nfunc TestGetUser(t *testing.T) {\n    fakeRepo := &FakeUserRepo{\n        users: map[int]*User{\n            1: {Name: \"Alice\", Email: \"alice@mail.com\"},\n        },\n    }\n\n    service := NewUserService(fakeRepo)\n\n    user, err := service.GetUser(1)\n    if err != nil {\n        t.Fatalf(\"неожиданная ошибка: %v\", err)\n    }\n    if user.Name != \"Alice\" {\n        t.Errorf(\"имя = %s; хотели Alice\", user.Name)\n    }\n}\n\nfunc TestGetUser_NotFound(t *testing.T) {\n    fakeRepo := &FakeUserRepo{users: map[int]*User{}}\n    service := NewUserService(fakeRepo)\n\n    _, err := service.GetUser(999)\n    if err == nil {\n        t.Error(\"ожидали ошибку, но получили nil\")\n    }\n}\n```\n\nТесты работают **мгновенно**, без базы данных, без Docker, без сети.\n\n## Тестирование HTTP-обработчиков\n\nСтандартная библиотека Go предоставляет пакет **httptest** для тестирования HTTP без реального сервера.\n\n```\nfunc TestHealthHandler(t *testing.T) {\n    req := httptest.NewRequest(\"GET\", \"/health\", nil)\n    w := httptest.NewRecorder()\n\n    HealthHandler(w, req)\n\n    if w.Code != http.StatusOK {\n        t.Errorf(\"статус = %d; хотели 200\", w.Code)\n    }\n\n    if w.Body.String() != \"ok\" {\n        t.Errorf(\"тело = %s; хотели ok\", w.Body.String())\n    }\n}\n```\n\n## Итог\n\n1. Зависимости (БД, API, файлы) прячьте за **интерфейсами**.\n2. В тестах подставляйте **фейковые** реализации.\n3. Для HTTP-тестов используйте **httptest.NewRecorder**.\n4. Тесты должны быть быстрыми и не зависеть от внешних сервисов.\n"}