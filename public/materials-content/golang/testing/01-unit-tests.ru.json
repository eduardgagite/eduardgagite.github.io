{"content":"\nВ Go тестирование встроено в язык. Не нужно ставить сторонние фреймворки (JUnit, pytest, Jest). Всё есть \"из коробки\" — пакет **testing** и команда **go test**.\n\n## Как написать первый тест\n\nПравила просты:\n1. Файл с тестами заканчивается на **_test.go** (например, **math_test.go**).\n2. Функция теста начинается с **Test** и принимает **\\*testing.T**.\n3. Тест лежит в том же пакете, что и тестируемый код.\n\n### Код, который тестируем\n\n```\n// math.go\npackage math\n\nfunc Add(a, b int) int {\n    return a + b\n}\n```\n\n### Тест\n\n```\n// math_test.go\npackage math\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n    result := Add(2, 3)\n    if result != 5 {\n        t.Errorf(\"Add(2, 3) = %d; хотели 5\", result)\n    }\n}\n```\n\n### Запуск\n\n```\ngo test ./...\n```\n\nФлаг **./...** означает \"запустить тесты во всех пакетах рекурсивно\". Для одного пакета — просто **go test**.\n\n```\ngo test -v ./...\n\ngo test -run TestAdd ./...\n```\n\n## Табличные тесты (Table-Driven Tests)\n\nЭто **главный паттерн** тестирования в Go. Вместо написания отдельной функции для каждого кейса, мы создаем таблицу (срез структур) с входными данными и ожидаемыми результатами.\n\n```\nfunc TestAdd(t *testing.T) {\n    tests := []struct {\n        name     string\n        a, b     int\n        expected int\n    }{\n        {\"positive numbers\", 2, 3, 5},\n        {\"zeros\", 0, 0, 0},\n        {\"negative\", -1, -2, -3},\n        {\"mixed\", -1, 5, 4},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Add(%d, %d) = %d; хотели %d\", tt.a, tt.b, result, tt.expected)\n            }\n        })\n    }\n}\n```\n\n### Почему это круто?\n\n1. Добавить новый кейс — одна строка в таблице.\n2. **t.Run(name, ...)** создает подтест. В выводе видно, какой именно кейс упал.\n3. Код теста не дублируется.\n\nВывод:\n```\n=== RUN   TestAdd\n=== RUN   TestAdd/positive_numbers\n=== RUN   TestAdd/zeros\n=== RUN   TestAdd/negative\n=== RUN   TestAdd/mixed\n--- PASS: TestAdd (0.00s)\n```\n\n## Полезные методы testing.T\n\n- **t.Error(args...)** / **t.Errorf(format, args...)** — пометить тест как проваленный, но продолжить выполнение.\n- **t.Fatal(args...)** / **t.Fatalf(format, args...)** — пометить как проваленный и **остановить** тест немедленно.\n- **t.Skip(reason)** — пропустить тест (например, если нет доступа к внешнему сервису).\n- **t.Parallel()** — разрешить тесту выполняться параллельно с другими.\n\n## Покрытие кода (Coverage)\n\nGo умеет показывать, какие строки кода покрыты тестами.\n\n```\ngo test -cover ./...\n\ngo test -coverprofile=coverage.out ./...\ngo tool cover -html=coverage.out\n```\n\nВ HTML-отчете зеленые строки — покрыты тестами, красные — нет.\n\n## Итог\n\n1. Тесты живут в файлах **\\*_test.go**, функции начинаются с **Test**.\n2. **Табличные тесты** — стандарт Go. Используйте **t.Run** для подтестов.\n3. **go test -v ./...** — запустить все тесты с подробным выводом.\n4. **go test -cover** — проверить покрытие кода.\n"}