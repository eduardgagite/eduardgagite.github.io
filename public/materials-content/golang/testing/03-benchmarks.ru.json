{"content":"\nИногда важно знать не только \"работает ли код?\", но и \"насколько он быстрый?\". Для этого в Go есть встроенные **бенчмарки** — инструмент для измерения производительности.\n\n## Как написать бенчмарк\n\nПравила похожи на тесты:\n1. Файл заканчивается на `_test.go`.\n2. Функция начинается с `Benchmark` (а не `Test`).\n3. Принимает `*testing.B` (а не `*testing.T`).\n\n```go\nfunc BenchmarkAdd(b *testing.B) {\n    // b.N — количество итераций (Go подбирает автоматически)\n    for i := 0; i < b.N; i++ {\n        Add(2, 3)\n    }\n}\n```\n\nGo сам определит, сколько раз нужно вызвать функцию, чтобы получить статистически значимый результат.\n\n### Запуск\n\n```bash\ngo test -bench=. ./...\n```\n\nВывод:\n\n```\nBenchmarkAdd-8    1000000000    0.3187 ns/op\n```\n\nРасшифровка:\n- **BenchmarkAdd-8**: Имя бенчмарка, 8 — количество CPU ядер.\n- **1000000000**: Функция была вызвана миллиард раз.\n- **0.3187 ns/op**: Каждый вызов занял 0.3 наносекунды.\n\n## Сравнение реализаций\n\nБенчмарки идеально подходят, чтобы сравнить два способа решения одной задачи.\n\n```go\n// Способ 1: Конкатенация строк через +\nfunc ConcatPlus(parts []string) string {\n    result := \"\"\n    for _, p := range parts {\n        result += p\n    }\n    return result\n}\n\n// Способ 2: Через strings.Builder\nfunc ConcatBuilder(parts []string) string {\n    var b strings.Builder\n    for _, p := range parts {\n        b.WriteString(p)\n    }\n    return b.String()\n}\n```\n\n```go\nvar parts = []string{\"Hello\", \" \", \"World\", \"!\", \" \", \"Go\", \" \", \"is\", \" \", \"awesome\"}\n\nfunc BenchmarkConcatPlus(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        ConcatPlus(parts)\n    }\n}\n\nfunc BenchmarkConcatBuilder(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        ConcatBuilder(parts)\n    }\n}\n```\n\nРезультат покажет, что `strings.Builder` в разы быстрее для большого количества строк, потому что не создает новую строку при каждой итерации.\n\n## Измерение памяти\n\nДобавьте флаг `-benchmem`, чтобы увидеть, сколько памяти выделяет ваш код.\n\n```bash\ngo test -bench=. -benchmem ./...\n```\n\n```\nBenchmarkConcatPlus-8       500000    3200 ns/op    1024 B/op    10 allocs/op\nBenchmarkConcatBuilder-8   5000000     280 ns/op     128 B/op     2 allocs/op\n```\n\n- **B/op**: Байтов памяти на одну операцию.\n- **allocs/op**: Количество выделений памяти (аллокаций). Чем меньше — тем лучше.\n\n## Итог\n\n1. Бенчмарки начинаются с `Benchmark` и принимают `*testing.B`.\n2. Запуск: `go test -bench=. -benchmem ./...`.\n3. Используйте бенчмарки, чтобы **доказать**, что оптимизация действительно помогла, а не просто \"кажется, что стало быстрее\".\n"}