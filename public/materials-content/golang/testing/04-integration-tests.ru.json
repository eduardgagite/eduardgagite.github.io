{"content":"\nЮнит-тесты проверяют отдельные функции в изоляции. Но реальный код общается с HTTP-серверами, базами данных и внешними API. Интеграционные тесты проверяют, что всё это работает вместе.\n\nGo предоставляет мощные инструменты для интеграционного тестирования прямо в стандартной библиотеке — без сторонних фреймворков.\n\n## Тестирование HTTP-обработчиков (httptest)\n\nПакет **net/http/httptest** позволяет тестировать HTTP-обработчики без запуска реального сервера.\n\n### ResponseRecorder — записываем ответ\n\n```\nfunc handleHealth(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(`{\"status\":\"ok\"}`))\n}\n\nfunc TestHandleHealth(t *testing.T) {\n    req := httptest.NewRequest(\"GET\", \"/health\", nil)\n    rec := httptest.NewRecorder()\n\n    handleHealth(rec, req)\n\n    if rec.Code != http.StatusOK {\n        t.Errorf(\"статус %d, хотели %d\", rec.Code, http.StatusOK)\n    }\n\n    expected := `{\"status\":\"ok\"}`\n    if rec.Body.String() != expected {\n        t.Errorf(\"тело %q, хотели %q\", rec.Body.String(), expected)\n    }\n}\n```\n\n**httptest.NewRequest** создаёт запрос, **httptest.NewRecorder** записывает ответ. Никакого сетевого взаимодействия — всё в памяти.\n\n### Тестирование с JSON-телом\n\n```\nfunc handleCreateUser(w http.ResponseWriter, r *http.Request) {\n    var user struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n    json.NewDecoder(r.Body).Decode(&user)\n\n    if user.Name == \"\" {\n        http.Error(w, \"name required\", http.StatusBadRequest)\n        return\n    }\n\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(map[string]string{\"id\": \"123\", \"name\": user.Name})\n}\n\nfunc TestCreateUser(t *testing.T) {\n    body := strings.NewReader(`{\"name\":\"Alice\",\"email\":\"alice@example.com\"}`)\n    req := httptest.NewRequest(\"POST\", \"/users\", body)\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    rec := httptest.NewRecorder()\n\n    handleCreateUser(rec, req)\n\n    if rec.Code != http.StatusCreated {\n        t.Fatalf(\"статус %d, хотели %d\", rec.Code, http.StatusCreated)\n    }\n\n    var resp map[string]string\n    json.NewDecoder(rec.Body).Decode(&resp)\n\n    if resp[\"name\"] != \"Alice\" {\n        t.Errorf(\"name = %q, хотели Alice\", resp[\"name\"])\n    }\n}\n```\n\n### Табличные тесты для обработчиков\n\nТабличный подход отлично сочетается с HTTP-тестами — можно покрыть десятки сценариев одним тестом.\n\n```\nfunc TestCreateUserValidation(t *testing.T) {\n    tests := []struct {\n        name       string\n        body       string\n        wantStatus int\n    }{\n        {\"valid user\", `{\"name\":\"Alice\",\"email\":\"a@b.com\"}`, http.StatusCreated},\n        {\"empty name\", `{\"name\":\"\",\"email\":\"a@b.com\"}`, http.StatusBadRequest},\n        {\"empty body\", `{}`, http.StatusBadRequest},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            req := httptest.NewRequest(\"POST\", \"/users\", strings.NewReader(tt.body))\n            rec := httptest.NewRecorder()\n\n            handleCreateUser(rec, req)\n\n            if rec.Code != tt.wantStatus {\n                t.Errorf(\"статус %d, хотели %d\", rec.Code, tt.wantStatus)\n            }\n        })\n    }\n}\n```\n\n## Тестовый сервер (httptest.Server)\n\nИногда нужно протестировать HTTP-клиент, который обращается к внешнему API. **httptest.NewServer** поднимает настоящий HTTP-сервер на случайном порту.\n\n```\nfunc TestFetchUserFromAPI(t *testing.T) {\n    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.Write([]byte(`{\"id\":1,\"name\":\"Alice\"}`))\n    }))\n    defer server.Close()\n\n    resp, err := http.Get(server.URL + \"/users/1\")\n    if err != nil {\n        t.Fatalf(\"запрос не удался: %v\", err)\n    }\n    defer resp.Body.Close()\n\n    var user struct {\n        ID   int    `json:\"id\"`\n        Name string `json:\"name\"`\n    }\n    json.NewDecoder(resp.Body).Decode(&user)\n\n    if user.Name != \"Alice\" {\n        t.Errorf(\"name = %q, хотели Alice\", user.Name)\n    }\n}\n```\n\nТестовый сервер удобен, когда в коде URL внешнего сервиса передаётся как параметр — подменяете его на **server.URL** и тестируете без сети.\n\n## Разделение юнит- и интеграционных тестов\n\nИнтеграционные тесты обычно медленнее и могут требовать внешних зависимостей (база данных, Redis). Удобно запускать их отдельно с помощью build tags.\n\n```\n//go:build integration\n\npackage storage\n\nimport \"testing\"\n\nfunc TestPostgresInsert(t *testing.T) {\n    db := connectToTestDB(t)\n    defer db.Close()\n}\n```\n\nЮнит-тесты запускаются как обычно, а для интеграционных нужен флаг **-tags=integration**:\n\n```\ngo test ./...\n\ngo test -tags=integration ./...\n```\n\n## TestMain — настройка окружения\n\nЕсли для интеграционных тестов нужно один раз подготовить среду (поднять базу, накатить миграции), используйте **TestMain**.\n\n```\nfunc TestMain(m *testing.M) {\n    db := setupTestDB()\n\n    code := m.Run()\n\n    db.Close()\n    os.Exit(code)\n}\n```\n\n**TestMain** вызывается один раз для всего пакета, до и после всех тестов. Это аналог setUp/tearDown на уровне пакета.\n\n## t.Cleanup — очистка после теста\n\nДля очистки после каждого отдельного теста используйте **t.Cleanup** вместо defer. Он гарантирует выполнение даже в подтестах.\n\n```\nfunc TestWithTempFile(t *testing.T) {\n    f, err := os.CreateTemp(\"\", \"test-*\")\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    t.Cleanup(func() {\n        os.Remove(f.Name())\n    })\n\n    // Работаем с файлом...\n}\n```\n\n## Итог\n\nПакет **httptest** покрывает большинство задач интеграционного тестирования: **NewRecorder** для тестирования обработчиков, **NewServer** для тестирования клиентов. Build tags разделяют быстрые юнит-тесты и медленные интеграционные. **Хороший проект имеет и те, и другие — юнит-тесты ловят баги в логике, интеграционные — в связках между компонентами.**\n"}