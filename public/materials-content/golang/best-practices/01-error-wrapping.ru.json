{"content":"\nВ разделе \"Базовые конструкции\" мы разобрали основы: `if err != nil`. Но в реальном проекте этого мало. Когда ошибка проходит через 5 слоев (HTTP -> Service -> Repository -> SQL), к моменту логирования нужно понимать, **где** она произошла и **почему**.\n\n## Проблема: Потеря контекста\n\n```go\nfunc GetUser(id int) (*User, error) {\n    user, err := db.FindUser(id)\n    if err != nil {\n        return nil, err // Просто прокидываем ошибку вверх\n    }\n    return user, nil\n}\n```\n\nКогда эта ошибка долетит до логов, вы увидите: `connection refused`. Но к какому сервису? В каком методе? С каким ID?\n\n## Решение: fmt.Errorf с %w\n\nОператор `%w` в `fmt.Errorf` **оборачивает** ошибку: добавляет контекст, но сохраняет оригинал внутри.\n\n```go\nfunc GetUser(id int) (*User, error) {\n    user, err := db.FindUser(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"GetUser(id=%d): %w\", id, err)\n    }\n    return user, nil\n}\n```\n\nТеперь в логах: `GetUser(id=42): connection refused`. Сразу понятно, что случилось и где.\n\n### Цепочка обёрток\n\nКаждый слой добавляет свой контекст:\n\n```go\n// Repository\nfunc (r *Repo) FindUser(id int) (*User, error) {\n    err := r.db.QueryRow(...)\n    if err != nil {\n        return nil, fmt.Errorf(\"FindUser query: %w\", err)\n    }\n}\n\n// Service\nfunc (s *Service) GetUser(id int) (*User, error) {\n    user, err := s.repo.FindUser(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"GetUser(id=%d): %w\", id, err)\n    }\n}\n\n// Handler\nfunc handleGetUser(w http.ResponseWriter, r *http.Request) {\n    user, err := service.GetUser(42)\n    if err != nil {\n        log.Printf(\"handleGetUser: %v\", err)\n        // Лог: handleGetUser: GetUser(id=42): FindUser query: connection refused\n    }\n}\n```\n\n## Проверка типа ошибки (errors.Is, errors.As)\n\nИногда нужно понять, **какая именно** ошибка произошла, несмотря на обёртки.\n\n### errors.Is — проверка на конкретную ошибку\n\n```go\nimport \"errors\"\n\nif errors.Is(err, sql.ErrNoRows) {\n    // Пользователь не найден — это не критическая ошибка\n    http.Error(w, \"Not Found\", 404)\n} else {\n    // Что-то серьезное — логируем\n    log.Printf(\"Ошибка: %v\", err)\n    http.Error(w, \"Internal Error\", 500)\n}\n```\n\n`errors.Is` \"разворачивает\" всю цепочку обёрток и проверяет, есть ли внутри `sql.ErrNoRows`.\n\n### errors.As — извлечение типизированной ошибки\n\n```go\nvar pgErr *pgconn.PgError\nif errors.As(err, &pgErr) {\n    fmt.Println(\"Код ошибки PostgreSQL:\", pgErr.Code)\n}\n```\n\n## Свои типы ошибок\n\nДля сложных проектов полезно создать свои типы ошибок.\n\n```go\ntype NotFoundError struct {\n    Entity string\n    ID     int\n}\n\nfunc (e *NotFoundError) Error() string {\n    return fmt.Sprintf(\"%s с ID %d не найден\", e.Entity, e.ID)\n}\n\n// Использование\nfunc GetUser(id int) (*User, error) {\n    user, err := repo.Find(id)\n    if err != nil {\n        return nil, &NotFoundError{Entity: \"User\", ID: id}\n    }\n    return user, nil\n}\n\n// Проверка\nvar nfErr *NotFoundError\nif errors.As(err, &nfErr) {\n    fmt.Printf(\"%s не найден\\n\", nfErr.Entity)\n}\n```\n\n## Итог\n\n1. **Оборачивайте** ошибки через `fmt.Errorf(\"контекст: %w\", err)`.\n2. Каждый слой добавляет свой контекст (имя функции, параметры).\n3. `errors.Is` — проверка на конкретную ошибку (через цепочку обёрток).\n4. `errors.As` — извлечение типизированной ошибки.\n5. Не оборачивайте ошибки, которые вы обрабатываете на месте (только те, что прокидываете вверх).\n"}