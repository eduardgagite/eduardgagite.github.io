{"content":"\nGo — язык с минималистичной философией. Здесь нет абстрактных фабрик, декораторов и стратегий в классическом виде. Вместо них — простые, идиоматичные паттерны, которые встречаются в стандартной библиотеке и в каждом серьёзном Go-проекте.\n\n## Functional Options — гибкое конфигурирование\n\nЗадача: создать HTTP-сервер с множеством настроек (порт, таймаут, логгер, TLS), но не заставлять пользователя указывать все. Классические подходы (конструктор с 10 параметрами или struct с полями) неудобны.\n\n```\ntype Server struct {\n    port    int\n    timeout time.Duration\n    logger  *slog.Logger\n}\n\ntype Option func(*Server)\n\nfunc WithPort(port int) Option {\n    return func(s *Server) {\n        s.port = port\n    }\n}\n\nfunc WithTimeout(d time.Duration) Option {\n    return func(s *Server) {\n        s.timeout = d\n    }\n}\n\nfunc WithLogger(l *slog.Logger) Option {\n    return func(s *Server) {\n        s.logger = l\n    }\n}\n\nfunc NewServer(opts ...Option) *Server {\n    s := &Server{\n        port:    8080,\n        timeout: 30 * time.Second,\n        logger:  slog.Default(),\n    }\n    for _, opt := range opts {\n        opt(s)\n    }\n    return s\n}\n```\n\nМожно создать сервер с настройками по умолчанию или указать только нужные параметры:\n\n```\nsrv := NewServer()\n\nsrv := NewServer(\n    WithPort(9090),\n    WithTimeout(10 * time.Second),\n)\n```\n\nЭтот паттерн используется в **grpc.NewServer**, **http.Server** и десятках популярных библиотек. Он позволяет добавлять новые опции без изменения сигнатуры конструктора.\n\n## Dependency Injection через интерфейсы\n\nВ Go нет фреймворков для DI (Spring, Dagger). Зависимости передаются явно — через аргументы конструктора. Это проще, прозрачнее и легче тестировать.\n\n```\ntype UserRepository interface {\n    FindByID(ctx context.Context, id int64) (*User, error)\n    Save(ctx context.Context, user *User) error\n}\n\ntype UserService struct {\n    repo   UserRepository\n    cache  Cache\n    logger *slog.Logger\n}\n\nfunc NewUserService(repo UserRepository, cache Cache, logger *slog.Logger) *UserService {\n    return &UserService{\n        repo:   repo,\n        cache:  cache,\n        logger: logger,\n    }\n}\n```\n\nВ **main** собираем граф зависимостей:\n\n```\nfunc main() {\n    db := connectDB()\n    repo := postgres.NewUserRepo(db)\n    cache := redis.NewCache(redisClient)\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n    userService := NewUserService(repo, cache, logger)\n    handler := NewHandler(userService)\n\n    http.ListenAndServe(\":8080\", handler)\n}\n```\n\nВ тестах подставляем моки:\n\n```\nfunc TestUserService(t *testing.T) {\n    repo := &mockRepo{users: map[int64]*User{1: {Name: \"Alice\"}}}\n    cache := &mockCache{}\n    logger := slog.New(slog.NewTextHandler(io.Discard, nil))\n\n    svc := NewUserService(repo, cache, logger)\n    user, err := svc.GetUser(context.Background(), 1)\n    // ...\n}\n```\n\nПравило: зависимости — это интерфейсы, реализации создаются в **main** и передаются вниз по цепочке.\n\n## Graceful Shutdown — корректное завершение\n\nКогда сервер получает сигнал остановки (Ctrl+C, SIGTERM от Kubernetes), он не должен обрывать текущие запросы. Нужно дождаться их завершения, закрыть соединения с базой и только потом выключиться.\n\n```\nfunc main() {\n    srv := &http.Server{Addr: \":8080\", Handler: router}\n\n    go func() {\n        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n            log.Fatalf(\"ошибка сервера: %v\", err)\n        }\n    }()\n\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n    <-quit\n\n    log.Println(\"Завершение: ждём текущие запросы...\")\n\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    if err := srv.Shutdown(ctx); err != nil {\n        log.Fatalf(\"принудительное завершение: %v\", err)\n    }\n\n    db.Close()\n    log.Println(\"Сервер остановлен\")\n}\n```\n\n**srv.Shutdown** перестаёт принимать новые соединения и ждёт завершения текущих. Если за 10 секунд не уложились — контекст отменяется и соединения обрываются принудительно.\n\n## Middleware — цепочка обработчиков\n\nMiddleware — функция, которая оборачивает HTTP-обработчик, добавляя поведение до или после обработки запроса.\n\n```\nfunc loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        next.ServeHTTP(w, r)\n        slog.Info(\"запрос обработан\",\n            \"method\", r.Method,\n            \"path\", r.URL.Path,\n            \"duration\", time.Since(start),\n        )\n    })\n}\n\nfunc authMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        token := r.Header.Get(\"Authorization\")\n        if token == \"\" {\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n        next.ServeHTTP(w, r)\n    })\n}\n```\n\nMiddleware собираются в цепочку:\n\n```\nhandler := loggingMiddleware(authMiddleware(router))\nhttp.ListenAndServe(\":8080\", handler)\n```\n\nКаждый запрос проходит через логирование, потом через проверку авторизации, потом попадает в роутер. Если авторизация не прошла — запрос не дойдёт до роутера.\n\n## Table-Driven конструирование\n\nПаттерн табличных тестов работает не только для тестов. Его можно применить для маршрутизации, маппинга и конфигурации.\n\n```\ntype route struct {\n    method  string\n    path    string\n    handler http.HandlerFunc\n}\n\nfunc setupRoutes(mux *http.ServeMux) {\n    routes := []route{\n        {\"GET\", \"/health\", handleHealth},\n        {\"GET\", \"/users\", handleListUsers},\n        {\"POST\", \"/users\", handleCreateUser},\n        {\"GET\", \"/users/{id}\", handleGetUser},\n    }\n\n    for _, r := range routes {\n        mux.HandleFunc(r.method+\" \"+r.path, r.handler)\n    }\n}\n```\n\nВсе маршруты в одном месте, легко читать, легко добавлять.\n\n## Итог\n\n**Functional Options** — для конструкторов с множеством параметров. **Dependency Injection** — через интерфейсы и явную передачу зависимостей в конструктор. **Graceful Shutdown** — для корректного завершения сервера (обязательно в продакшене). **Middleware** — для общей логики (логирование, авторизация, метрики). Go не нуждается в сложных паттернах проектирования — **простота и явность ценятся выше, чем абстрактность и гибкость.**\n"}