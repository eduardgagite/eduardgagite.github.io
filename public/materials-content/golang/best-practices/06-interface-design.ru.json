{"content":"\nВ Go интерфейсы — основа гибкой и тестируемой архитектуры. Но их легко применить неправильно: сделать слишком большими, определить не в том пакете или создать ради создания. Эти принципы помогут проектировать интерфейсы правильно.\n\n## Принцип: интерфейсы маленькие\n\nОдна из ключевых идей Go — маленькие интерфейсы. Стандартная библиотека демонстрирует это лучше всего:\n\n```\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\ntype Closer interface {\n    Close() error\n}\n```\n\nОдин метод — один интерфейс. При необходимости их компонуют:\n\n```\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype ReadWriteCloser interface {\n    Reader\n    Writer\n    Closer\n}\n```\n\n**Правило**: если в интерфейсе больше 3-4 методов — подумайте, нельзя ли его разбить.\n\n## Принцип: интерфейсы определяются у потребителя\n\nЧастая ошибка — определить интерфейс в том же пакете, где реализация:\n\n```\n// Плохо: пакет storage сам определяет свой интерфейс\npackage storage\n\ntype UserRepository interface {  // Здесь не нужен интерфейс!\n    GetUser(id int) (*User, error)\n    CreateUser(u *User) error\n}\n\ntype PostgresUserRepo struct { ... }\n\nfunc (r *PostgresUserRepo) GetUser(id int) (*User, error) { ... }\nfunc (r *PostgresUserRepo) CreateUser(u *User) error { ... }\n```\n\nПравильно — интерфейс определяет тот, кто его использует:\n\n```\n// Хорошо: пакет service определяет нужный ему интерфейс\npackage service\n\n// Интерфейс описывает то, что нужно service — не больше\ntype UserRepo interface {\n    GetUser(id int) (*User, error)\n    CreateUser(u *User) error\n}\n\ntype UserService struct {\n    repo UserRepo\n}\n```\n\nТеперь **storage** не знает о **service**, зависимость направлена правильно. В тестах можно подставить мок.\n\n## Accept interfaces, return structs\n\nКлассический принцип Go: функции и методы принимают интерфейс, возвращают конкретный тип.\n\n```\n// Хорошо: принимаем io.Reader — работаем с любым источником данных\nfunc ParseConfig(r io.Reader) (*Config, error) {\n    // ...\n}\n\n// Плохо: принимаем конкретный тип — привязка к реализации\nfunc ParseConfig(f *os.File) (*Config, error) {\n    // ...\n}\n```\n\nЕсли возвращать интерфейс — вы скрываете информацию о типе от вызывающего кода, и он не сможет получить доступ к дополнительным методам конкретного типа.\n\nИсключение: **error** — это интерфейс, и возвращать его правильно.\n\n## Не создавайте интерфейс без причины\n\nИнтерфейс нужен, когда:\n1. Есть несколько реализаций (PostgreSQL, MySQL, in-memory для тестов).\n2. Нужна возможность подменить зависимость в тестах.\n3. Поведение может меняться в зависимости от конфигурации.\n\nНе нужен, когда:\n1. Есть только одна реализация, и другой не предвидится.\n2. Это просто структура с данными.\n3. Вы создаёте интерфейс \"на будущее\".\n\n```\n// Лишний интерфейс — есть одна реализация, и она не меняется\ntype ConfigLoader interface {\n    Load() (*Config, error)\n}\n\ntype fileConfigLoader struct { ... }\n\n// Лучше напрямую:\nfunc LoadConfig(path string) (*Config, error) { ... }\n```\n\n## Проверка реализации интерфейса на этапе компиляции\n\nДобавьте эту строку, чтобы компилятор проверял реализацию:\n\n```\n// Убеждаемся, что *PostgresUserRepo реализует UserRepo\nvar _ UserRepo = (*PostgresUserRepo)(nil)\n```\n\nЕсли вы забыли реализовать какой-то метод — получите ошибку компиляции, а не панику в runtime. Это стандартная практика в больших пакетах.\n\n## Интерфейсы и nil — распространённая ловушка\n\nИнтерфейс в Go содержит два поля: тип и указатель. Он равен **nil** только если оба поля **nil**:\n\n```\nfunc getError() error {\n    var err *MyError = nil\n    return err // НЕ nil! Интерфейс содержит тип *MyError\n}\n\nfunc main() {\n    err := getError()\n    if err != nil { // Всегда true!\n        fmt.Println(\"Ошибка:\", err)\n    }\n}\n```\n\nПравило: **никогда не возвращайте типизированный nil через интерфейс**. Возвращайте просто **nil**:\n\n```\nfunc getError() error {\n    // ...\n    return nil // Правильно: nil без типа\n}\n```\n\n## Итого\n\nХороший интерфейс в Go — маленький, определённый у потребителя, существующий по конкретной причине. **Лучший интерфейс — это один метод**. Принимайте интерфейсы в параметрах, возвращайте конкретные типы. И всегда добавляйте проверку `var _ Interface = (*Impl)(nil)` — это бесплатная страховка от ошибок рефакторинга.\n"}