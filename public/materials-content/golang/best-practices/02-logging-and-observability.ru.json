{"content":"\nКогда приложение работает в продакшене, вы не можете подключиться к нему отладчиком и поставить breakpoint. Единственный способ понять, что происходит — **логи**.\n\nХорошие логи экономят часы при поиске багов. Плохие — создают шум и не помогают.\n\n## Стандартный пакет log\n\nGo поставляется с пакетом `log`. Он простой, но ограниченный.\n\n```go\nimport \"log\"\n\nfunc main() {\n    log.Println(\"Сервер запущен\")\n    log.Printf(\"Порт: %d\", 8080)\n    \n    // Fatal = Print + os.Exit(1)\n    log.Fatal(\"Критическая ошибка, выключаюсь\")\n}\n```\n\nВывод:\n```\n2025/01/28 14:30:00 Сервер запущен\n2025/01/28 14:30:00 Порт: 8080\n```\n\n## Структурированное логирование (slog)\n\nНачиная с Go 1.21, в стандартной библиотеке появился пакет `log/slog` — современный логгер со структурированным выводом.\n\n### Почему структурированные логи лучше?\n\nОбычный лог:\n```\n2025-01-28 14:30:00 Ошибка при получении пользователя: connection refused\n```\n\nСтруктурированный лог (JSON):\n```json\n{\"time\":\"2025-01-28T14:30:00Z\",\"level\":\"ERROR\",\"msg\":\"Ошибка при получении пользователя\",\"user_id\":42,\"error\":\"connection refused\"}\n```\n\nВторой вариант легко парсить, фильтровать и искать в системах мониторинга (Grafana, Kibana, Datadog).\n\n### Использование slog\n\n```go\nimport \"log/slog\"\n\nfunc main() {\n    // Текстовый формат (для разработки)\n    slog.Info(\"Сервер запущен\", \"port\", 8080)\n    // 2025/01/28 14:30:00 INFO Сервер запущен port=8080\n\n    // Предупреждение\n    slog.Warn(\"Медленный запрос\", \"duration_ms\", 1500, \"path\", \"/api/users\")\n\n    // Ошибка\n    slog.Error(\"Не удалось подключиться к БД\", \"error\", err, \"host\", \"db.example.com\")\n}\n```\n\n### JSON-формат (для продакшена)\n\n```go\nlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\nslog.SetDefault(logger)\n\nslog.Info(\"Запрос обработан\", \"method\", \"GET\", \"path\", \"/users\", \"status\", 200)\n// {\"time\":\"...\",\"level\":\"INFO\",\"msg\":\"Запрос обработан\",\"method\":\"GET\",\"path\":\"/users\",\"status\":200}\n```\n\n## Уровни логирования\n\nИспользуйте правильные уровни:\n\n- **Debug**: Детали для разработки. Не включайте в продакшене.\n- **Info**: Важные события: \"Сервер запущен\", \"Миграции применены\".\n- **Warn**: Что-то подозрительное, но работа продолжается: \"Медленный запрос\".\n- **Error**: Что-то сломалось: \"Не удалось подключиться к БД\".\n\n### Фильтрация по уровню\n\n```go\n// В продакшене показываем только Warn и Error\nopts := &slog.HandlerOptions{Level: slog.LevelWarn}\nlogger := slog.New(slog.NewJSONHandler(os.Stdout, opts))\n```\n\n## Что логировать\n\n**Логируйте**:\n- Старт и остановку сервера.\n- Входящие запросы (метод, путь, время выполнения, статус).\n- Ошибки с контекстом (ID пользователя, параметры запроса).\n- Подключение/отключение от внешних сервисов.\n\n**Не логируйте**:\n- Пароли, токены, персональные данные.\n- Каждую итерацию цикла (забьете диск за минуты).\n- Успешные проверки (логируйте только отклонения).\n\n## Итог\n\n1. Используйте `log/slog` для структурированного логирования.\n2. В разработке — текстовый формат. В продакшене — JSON.\n3. Добавляйте контекст к логам: `\"user_id\", 42, \"method\", \"GET\"`.\n4. Никогда не логируйте секреты (пароли, токены, ключи API).\n"}