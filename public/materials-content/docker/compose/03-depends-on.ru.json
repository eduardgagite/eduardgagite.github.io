{"content":"\nЧастая проблема: ваше приложение (**web**) стартует быстрее, чем база данных (**db**).\nПриложение пытается подключиться, базы еще нет, приложение падает с ошибкой **Connection refused**.\n\n## depends_on\n\nБазовое решение — инструкция **depends_on**.\n\n```\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n  db:\n    image: postgres\n```\n\nЧто это дает?\n1. **docker compose up** гарантированно запустит **db** **перед** тем, как запускать **web**.\n2. **docker compose up web** автоматически запустит и **db** тоже.\n\n## Проблема «Готовности»\n\n**depends_on** ждет только того момента, когда контейнер с базой запустится (статус **Running**).\nНо база данных может запускаться еще 10-30 секунд **внутри** контейнера (инициализация файлов, создание таблиц).\nDocker не знает, что происходит внутри процесса. Поэтому **web** запустится, а база всё еще не готова принимать соединения.\n\n## Решение: Healthcheck (Проверка здоровья)\n\nМы можем научить Docker проверять, жива ли база по-настоящему.\n\n```\nservices:\n  db:\n    image: postgres\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n  \n  web:\n    build: .\n    depends_on:\n      db:\n        condition: service_healthy\n```\n\nТеперь **web** не запустится до тех пор, пока утилита **pg_isready** внутри контейнера **db** не вернет успех. Это самый надежный способ синхронизации запуска.\n\n## Итого\n\nПросто **depends_on** контролирует только порядок старта контейнеров.\n**depends_on** + **condition: service_healthy** контролирует **готовность** сервиса к работе.\n"}