{"content":"\nПредставьте, что вы пишете на Go, Java или TypeScript.\nВам нужны компиляторы (`go build`, `tsc`, `maven`) для сборки приложения. Но для **запуска** готового бинарника или JS-файлов эти инструменты не нужны!\n\nЕсли оставить их в финальном образе, он будет весить 500 МБ вместо 20 МБ.\nРешение: **Multi-stage builds** (многоэтапная сборка).\n\n## Как это работает\n\nМы используем несколько инструкций `FROM` в одном Dockerfile. Каждый `FROM` начинает новый этап. Мы можем копировать файлы (артефакты) из предыдущего этапа в текущий.\n\n## Пример (для статического сайта на Nginx)\n\nДопустим, у нас React-приложение. Его нужно собрать (`npm run build`), а потом просто раздавать статику через Nginx. Node.js в продакшене нам не нужен.\n\n```dockerfile\n# --- Этап 1: Сборка (Builder) ---\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n# Теперь в папке /app/dist лежит готовый сайт\n\n# --- Этап 2: Продакшен (Production) ---\nFROM nginx:alpine\n# Копируем ТОЛЬКО папку dist из этапа builder\nCOPY --from=builder /app/dist /usr/share/nginx/html\n\n# Нам не нужен Node.js, npm и исходники. \n# В итоговом образе только Nginx и HTML/JS файлы.\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n## Преимущества\n\n1. **Минимальный размер:** Итоговый образ содержит только то, что нужно для работы (Runtime). Все инструменты сборки (Build tools) отбрасываются.\n2. **Безопасность:** В продакшен не едут исходные коды, компиляторы и dev-зависимости.\n3. **Удобство:** Единый Dockerfile описывает весь процесс: и сборку, и упаковку. Не нужны внешние CI-скрипты.\n\n## Итого\n\nMulti-stage — это стандарт для компилируемых языков (Go, Java, C++) и фронтенда (React, Vue).\nИспользуйте конструкцию `COPY --from=...` чтобы переносить только готовые артефакты.\n\n"}