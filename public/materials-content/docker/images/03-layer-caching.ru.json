{"content":"\nСборка Docker-образа работает послойно. Каждая инструкция в Dockerfile (**RUN**, **COPY**) создает новый слой.\nDocker очень умен: он **кеширует** каждый слой. Если вы ничего не меняли в инструкции и файлах, которые она трогает, Docker мгновенно возьмет готовый слой из кеша, вместо того чтобы выполнять команду заново.\n\nЭто критически важно для скорости сборки (CI/CD).\n\n## Правильный порядок: от редкого к частому\n\nПосмотрите на этот \"плохой\" Dockerfile, где весь код копируется одной командой до установки зависимостей:\n\n```\nFROM node:18\nWORKDIR /app\nCOPY . .\nRUN npm install\nCMD [\"node\", \"index.js\"]\n```\n\nПочему это плохо?\nЕсли вы измените хоть одну запятую в коде (**index.js**), инструкция **COPY . .** изменится (так как изменилась чексумма файлов).\nЗначит, Docker сбросит кеш для этого слоя и **всех последующих**.\nСледовательно, **RUN npm install** будет выполняться заново при каждом изменении кода!\n\n## Оптимизированный вариант\n\nМы разделяем копирование зависимостей и кода. Сначала копируем только файлы описания зависимостей и устанавливаем их — этот слой закешируется и не будет пересобираться, пока не изменится **package.json**. И только потом копируем исходный код:\n\n```\nFROM node:18\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm install\nCOPY . .\nCMD [\"node\", \"index.js\"]\n```\n\n**Результат:**\nВы меняете код приложения 100 раз в день. Docker использует кеш для **npm install** (тяжелая операция) и просто быстро перекопирует легкие исходники. Сборка занимает 1 секунду вместо 2 минут.\n\n## Правило\n\nРасполагайте инструкции в порядке **от наименее часто изменяемых к наиболее часто изменяемым**.\n\n1. Установка системных пакетов (**apt install**).\n2. Установка зависимостей проекта (**npm install**, **pip install**).\n3. Копирование исходного кода.\n4. Команда запуска.\n\n## Итого\n\nИспользуйте механизм слоев себе на пользу. Правильный порядок команд в Dockerfile может ускорить сборку в десятки раз.\n"}