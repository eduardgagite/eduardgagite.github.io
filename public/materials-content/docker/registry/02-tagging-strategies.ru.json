{"content":"\nКак правильно называть версии образов?\nЕсли вы всегда используете `latest`, вы стреляете себе в ногу.\n\n## Проблема тега `latest`\n\n`latest` — это просто тег по умолчанию. Это **НЕ** \"самая свежая версия\". Это просто строка \"latest\".\nЕсли вы обновили код, собрали образ, но забыли перевесить тег `latest`, то `docker pull my-app:latest` скачает старый код.\n\nКроме того, если в продакшене вы используете `image: my-app:latest`, вы не знаете, какая именно версия кода там сейчас работает. Откатиться на предыдущую невозможно (ведь она тоже была `latest`, вы просто перезаписали её).\n\n## Стратегия 1: Semantic Versioning (SemVer)\n\nВыпускаете релизы, как в npm или git tag: `v1.0.0`, `v1.0.1`, `v1.1.0`.\n\n```bash\ndocker build -t my-app:v1.0.1 .\n```\n\n**Плюсы:** Понятно людям. Легко откатиться (`v1.0.1` сломалась -> запустили `v1.0.0`).\n**Минусы:** Нужно вручную следить за версиями.\n\n## Стратегия 2: Git Commit SHA\n\nАвтоматическая генерация тега на основе хеша коммита.\n\n```bash\n# В CI/CD пайплайне\ndocker build -t my-app:$(git rev-parse --short HEAD) .\n# Создаст образ my-app:a1b2c3d\n```\n\n**Плюсы:** Железобетонная связка \"Код в Git\" <-> \"Образ в Docker\". Вы точно знаете, из какого коммита собран этот образ. Идеально для CI/CD.\n**Минусы:** Теги выглядят как набор букв (`a1b2c3d`), сложно понять, какой новее, без просмотра истории git.\n\n## Лучшая практика (Комбинированный подход)\n\nПри релизе вешать сразу несколько тегов на один и тот же образ:\n\n1. Точный хеш: `my-app:a1b2c3d` (для роботов и точного отката).\n2. Версия: `my-app:v1.2` (для людей).\n3. Плавающий тег: `my-app:latest` (для удобства локального запуска).\n\nВ Docker один и тот же Image ID может иметь сколько угодно тегов. Это бесплатно (место на диске не дублируется).\n\n## Итого\n\nВ продакшене **никогда** не используйте `latest`. Всегда фиксируйте версию (`v1.2.3`) или хеш коммита. Это единственный способ обеспечить предсказуемость и возможность отката (Rollback).\n\n"}