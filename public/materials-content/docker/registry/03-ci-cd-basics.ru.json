{"content":"\nКак автоматизировать доставку кода?\nDocker идеально вписывается в пайплайны CI/CD (GitHub Actions, GitLab CI).\n\nРассмотрим типичный процесс **Build -> Push -> Deploy**.\n\n## 1. Build (Сборка)\n\nНа сервере сборки (CI Runner):\n1. Клонируем код из Git.\n2. Логинимся в реестр:\n   ```bash\n   echo $REGISTRY_PASSWORD | docker login -u $REGISTRY_USER --password-stdin\n   ```\n3. Собираем образ с тегом (хеш коммита):\n   ```bash\n   COMMIT_SHA=$(git rev-parse --short HEAD)\n   docker build -t myorg/myapp:$COMMIT_SHA .\n   ```\n\n## 2. Push (Отправка)\n\nЗагружаем собранный образ в реестр:\n```bash\ndocker push myorg/myapp:$COMMIT_SHA\n```\n\n## 3. Deploy (Развертывание)\n\nЗдесь есть два пути.\n\n### Путь А: SSH (простой)\nCI подключается к боевому серверу по SSH и выполняет команды:\n```bash\nssh user@production-server \"\n  docker pull myorg/myapp:$COMMIT_SHA && \\\n  docker stop myapp || true && \\\n  docker rm myapp || true && \\\n  docker run -d --name myapp -p 80:3000 myorg/myapp:$COMMIT_SHA\n\"\n```\n*Примечание: Если используете docker-compose, просто обновляете версию в файле .env и делаете `docker compose up -d`.*\n\n### Путь Б: Watchtower (автоматический)\nНа сервере запущен специальный контейнер **Watchtower**. Он раз в минуту проверяет, не обновился ли образ в реестре. Если обновился — он сам скачивает новый, гасит старый и запускает новый с теми же параметрами.\n\n## Итого\n\nDocker превращает деплой в простую замену одного кирпичика на другой. Вам не нужно настраивать сервер, ставить зависимости и копировать файлы. Вы просто говорите серверу: \"Запусти вот этот новый образ\".\n\n"}