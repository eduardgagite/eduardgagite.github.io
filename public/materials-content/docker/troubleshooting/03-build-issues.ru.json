{"content":"\nКогда **docker build** идет не по плану.\n\n## 1. Сборка идет очень долго (Sending build context)\n\n**Симптом:**\nВы запускаете билд, и видите:\n```\nSending build context to Docker daemon  500MB\n```\nИ только через минуту начинается реальная работа.\n\n**Причина:**\nВы не добавили **.dockerignore**. Docker копирует вашу папку **node_modules**, **.git**, видео с котиками и всё остальное демону перед началом сборки.\n\n**Решение:**\nСоздайте **.dockerignore** и исключите всё лишнее.\n\n## 2. npm install выполняется каждый раз\n\n**Симптом:**\nВы поменяли одну строчку в коде, а Docker заново качает весь интернет (**npm install**), тратя 5 минут.\n\n**Причина:**\nНеправильный порядок слоев. Вы скопировали **COPY . .** **до** **RUN npm install**. Любое изменение кода сбрасывает кеш для установки пакетов.\n\n**Решение:**\nСначала **COPY package.json**, потом **RUN npm install**, потом **COPY . .**.\n\n## 3. \"Файл не найден\" при COPY\n\n**Симптом:**\n**COPY ./config/app.conf /app/** падает с ошибкой **file not found**.\n\n**Причина:**\nВы думаете, что путь относительный от Dockerfile, но на самом деле он от **контекста сборки**.\nОбычно контекст — это точка в конце команды: **docker build .**.\n\nЕсли вы запускаете билд из другой папки: **docker build -f ./backend/Dockerfile .**, то контекст — текущая папка, а Dockerfile ищет файлы внутри **backend**.\n\n**Решение:**\nВсегда запускайте билд из корня проекта, или внимательно следите за путями.\n\n## 4. Windows Line Endings (CRLF)\n\n**Симптом:**\nБаш-скрипт внутри контейнера падает с ошибкой: **/bin/sh^M: bad interpreter**.\n\n**Причина:**\nВы редактировали файл **entrypoint.sh** в Windows (Notepad), и он сохранился с окончаниями строк **CRLF** (Carriage Return + Line Feed). Linux понимает только **LF**.\n\n**Решение:**\nПересохраните файл с LF (в VS Code: справа снизу кнопка \"CRLF\" -> переключить на \"LF\"). Или настройте git **core.autocrlf**.\n\n## Итого\n\nСледите за контекстом, кешем и окончаниями строк. И не забывайте про **.dockerignore**.\n"}