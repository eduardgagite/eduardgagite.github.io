{"content":"\nРабота с ключами в Redis важна не меньше, чем выбор структуры данных. От того, как называются ключи, зависит удобство отладки, простота поиска и риск случайно удалить или перезаписать чужие данные.\n\n## Что такое ключ в Redis\n\nКлюч в Redis — это строка, по которой сервер находит значение. В одном экземпляре Redis все ключи лежат в общем пространстве. Никаких таблиц или схем, как в классических базах, здесь нет.\n\nПростейший пример записи значения по ключу:\n\n```\nSET user:1 \"Alice\"\nGET user:1\n```\n\nКлючи могут быть любыми строками, но на практике используют понятные имена, которые отражают назначение данных.\n\n## Пространства имён через разделитель\n\nТак как формальных схем нет, пространство имён организуют самим названием ключа. Часто используют двоеточие как разделитель.\n\nПример ключей для пользователей:\n\n```\nSET user:1:name \"Alice\"\nSET user:1:email \"alice@example.com\"\nSET user:2:name \"Bob\"\n```\n\nЗдесь user — логическая группа, число после двоеточия — идентификатор, а последнее слово — поле или тип данных.\n\nЕщё один пример для сессий и кэша:\n\n```\nSET session:token:abc123 \"user:1\"\nSET cache:article:42 \"html...\"\n```\n\nТакой подход помогает:\n\n**Визуально группировать данные.** По ключу сразу видно, к чему относится запись.\n\n**Избегать конфликтов.** Ключи разных подсистем не пересекаются: session:..., cache:..., user:....\n\n**Удобно искать и чистить.** Можно выбрать группу ключей по шаблону.\n\n## Поиск и обход ключей\n\nДля поиска ключей по шаблону есть несколько команд. В учебных примерах часто используют KEYS, но в реальных проектах её лучше избегать: она может блокировать сервер, если ключей много.\n\nПример KEYS для понимания работы шаблонов:\n\n```\nKEYS user:*\n```\n\nБолее безопасный вариант для продакшена — команда SCAN. Она обходит ключи постепенно и не блокирует сервер.\n\nПример выборки сессий по шаблону:\n\n```\nSCAN 0 MATCH session:* COUNT 100\n```\n\nКлиент вызывает SCAN несколько раз, пока не обойдёт все подходящие ключи.\n\n## Тип ключа и удаление\n\nИногда важно понять, какое значение лежит по ключу. Для этого есть команда TYPE.\n\n```\nTYPE user:1\n```\n\nОтвет покажет тип: string, hash, list, set и так далее.\n\nУдалить ключ можно простой командой:\n\n```\nDEL user:1\n```\n\nЕсли ключ крупный и его много, иногда используют UNLINK. Эта команда помечает данные на удаление и возвращается быстрее, чем DEL.\n\n```\nUNLINK big:list\n```\n\nКакую бы команду ни использовать, важно аккуратно выбирать ключи. Ошибка в шаблоне или названии может удалить лишние данные.\n\n## Практические схемы именования\n\nНесколько типичных вариантов, которые хорошо приживаются в проектах.\n\nПользователи:\n\n```\nuser:42\nuser:42:name\nuser:42:settings\n```\n\nСессии и авторизация:\n\n```\nsession:token:abc123\nsession:user:42\n```\n\nКэш:\n\n```\ncache:article:10\ncache:profile:42\n```\n\nСчётчики и метрики:\n\n```\nmetrics:views:article:10\nmetrics:logins:2025-11-20\n```\n\nГлавная идея простая: один логический блок — один префикс. Так ключи остаются читаемыми, их легко искать и удалять по шаблону, а риск конфликтов между разными частями системы заметно снижается.\n"}