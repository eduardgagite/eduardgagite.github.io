{"content":"\n**Redis** — это не просто хранилище строк. Его особенность в том, что данные могут быть представлены разными структурами, и каждая из них подходит под определённые задачи. В отличие от обычной базы данных, где обычно работают с таблицами и строками, здесь используются более простые и быстрые модели: списки, наборы, хеши, упорядоченные коллекции и потоки. Благодаря этому многие задачи решаются естественно и без сложных запросов.\n\n![Структуры данных Redis](images/structures.jpg)\n\n## Строки\n\n**Строка** — самая базовая форма данных. Это просто значение, связанное с ключом. Внутри строки может лежать что угодно: текст, число, JSON в виде текста. Такой тип чаще всего используют там, где нужно хранить простые значения — например, токен, число, небольшую структуру или результат вычисления.\n\n**Пример данных:**  \n\"hello world\"\n\n**Пример команды:**  \n```\nSET message \"hello world\"\n```\n\n**Когда использовать:**  \nКогда нужно хранить простое значение: текст, число, флаг, токен, JSON в виде строки.\n\n## Хеши\n\n**Хеш** похож на маленький объект или словарь. У одного ключа Redis может быть несколько полей, у каждого — своё значение. Это удобный вариант, когда нужно хранить сущность с несколькими свойствами: профиль пользователя, настройки, краткую информацию о товаре. Хеши позволяют получать или менять отдельные поля без перезаписи всей структуры.\n\n**Пример данных:**  \n{a: \"hello\", b: \"world\"}\n\n**Пример команды:**  \n```\nHSET user name \"Alice\" age 25\n```\n\n**Когда использовать:**  \nКогда требуется небольшая сущность с несколькими полями, обновляемыми отдельно.\n\n## Списки\n\n**Списки** ведут себя как обычная очередь или стек. В начало и конец можно быстро добавлять элементы, извлекать их, просматривать нужные участки. Это хорошее решение для задач, где важен порядок: хранение последних действий пользователя, формирование очередей задач, временные журналы событий.\n\n**Пример данных:**  \n[A > B > C]\n\n**Пример команды:**  \n```\nLPUSH logs \"event1\"\n```\n\n**Когда использовать:**  \nКогда важен порядок: очереди задач, последние записи, журналы действий.\n\n## Множества\n\n**Множество** — коллекция уникальных значений. Здесь нельзя хранить дубликаты, и порядок элементов не важен. Такой тип помогает решать задачи вроде хранения уникальных ID, отслеживания пользователей, которые выполнили действие, или быстрого определения, находится ли элемент в наборе.\n\n**Пример данных:**  \n{A, B, C}\n\n**Пример команды:**  \n```\nSADD online_users \"user1\"\n```\n\n**Когда использовать:**  \nКогда нужен набор уникальных значений без повторов.\n\n## Упорядоченные множества\n\n**Упорядоченные множества** отличаются от обычных тем, что каждый элемент имеет числовой «вес», по которому Redis сортирует коллекцию. Этот тип хорошо подходит для рейтингов, лидбордов, статистики, где важно быстро узнать позиции элементов или взять часть списка по определённому диапазону.\n\n**Пример данных:**  \n{A:1, B:2, C:3}\n\n**Пример команды:**  \n```\nZADD rating 100 \"player1\"\n```\n\n**Когда использовать:**  \nКогда нужен рейтинг, сортировка или выборка по диапазону числовых значений.\n\n## Bitmaps\n\n**Bitmaps** позволяют хранить и изменять данные на уровне отдельных битов. Это даёт возможность создавать компактные структуры для отметок присутствия/отсутствия. Часто используется в аналитике, когда нужно отслеживать активность пользователей по дням или отмечать события в большом массиве данных без большого расхода памяти.\n\n**Пример данных:**  \n01101101 01101111 01101101\n\n**Пример команды:**  \n```\nSETBIT days 5 1\n```\n\n**Когда использовать:**  \nКогда нужно отмечать состояния по битам: активности по дням, флаги, быстрые отметки.\n\n## HyperLogLog\n\n**HyperLogLog** — структура для приближённого подсчёта количества уникальных значений. Она не хранит сами элементы, зато позволяет оценить, сколько уникальных записей прошло через систему. Подходит для огромных массивов данных, где точность важна меньше, чем компактность и скорость (например, количество уникальных посетителей).\n\n**Пример данных:**  \n010110101 011011111 01101101\n\n**Пример команды:**  \n```\nPFADD visitors \"user123\"\n```\n\n**Когда использовать:**  \nКогда требуется приблизительно посчитать количество уникальных значений в большом потоке данных.\n\n## Streams\n\n**Streams** — структура для обработки последовательных событий. Каждый элемент имеет автоинкрементный идентификатор и набор полей. Это природный способ создавать очереди событий, собирать логи, обмениваться сообщениями между сервисами. В отличие от списков, потоки умеют работать с группами потребителей и гарантируют доставку данных тем, кто их обрабатывает.\n\n**Пример данных:**  \n{id1 = time.seq { a: \"foo\", b: \"bar\" }}\n\n**Пример команды:**  \n```\nXADD mystream * message \"hello\"\n```\n\n**Когда использовать:**  \nКогда нужно работать с последовательными событиями, логами или очередями с группами потребителей.\n\n## Зачем столько типов?\n\n**Каждая структура** существует не ради разнообразия, а чтобы решать конкретные задачи максимально быстро. Где-то важен порядок, где-то уникальность, где-то возможность работать с огромными потоками данных без потери производительности. Понимание различий помогает выбирать правильный инструмент и строить более эффективные решения.\n\n**Redis выигрывает именно за счёт того, что позволяет использовать разные структуры там, где они логичнее и быстрее всего.**\n"}