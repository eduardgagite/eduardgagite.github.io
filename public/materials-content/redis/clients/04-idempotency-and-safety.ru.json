{"content":"\nКогда появляются ретраи, сетевые сбои и сложная логика, легко дважды выполнить одну и ту же операцию. Если команда не идемпотентна, это приводит к удвоенным списаниям, дубликатам задач или странным состояниям в очередях.\n\nИдемпотентность — это свойство операции давать тот же результат при повторном выполнении. В связке с Redis это можно и нужно использовать осознанно.\n\n## Простейшие идемпотентные операции\n\nМногие команды Redis по сути уже идемпотентны:\n\n- SET с одним и тем же значением для ключа;\n- EXPIRE и PEXPIRE с одинаковым временем;\n- записи, где значение полностью определено содержимым команды.\n\nПример:\n\n```\nSET user:42:name \"Alice\"\nSET user:42:name \"Alice\"\n```\n\nПовтор второй команды не меняет состояние. Если операция реализована именно как установка значения, а не как сложная последовательность шагов, ретраи становятся безопаснее.\n\n## Использование SETNX и атомарных операций\n\nДля сценариев «сделать что‑то один раз» помогают команды **SETNX** и атомарные инкременты.\n\nПример: один раз выполнить инициализацию для пользователя.\n\n```\nSETNX user:42:initialized 1\n```\n\nЕсли ключ уже существует, команда вернёт 0, и повторный вызов не изменит состояние. Аналогично, атомарные операции вроде INCR и HINCRBY гарантируют корректный результат даже при параллельных вызовах.\n\n## Идемпотентность на уровне бизнес‑идентификаторов\n\nЧасто удобнее считать идемпотентной не отдельную команду Redis, а всю бизнес‑операцию с собственным идентификатором.\n\nПример: обработка платежа с идентификатором операции.\n\nШаги:\n\n1. До начала логики проверить, обрабатывался ли уже этот **payment_id**.\n2. Если да — просто вернуть сохранённый результат.\n3. Если нет — выполнить бизнес‑логику и пометить операцию как завершённую.\n\nХранение статуса:\n\n```\nSETNX payment:op:12345 \"processed\"\n```\n\nЕсли SETNX вернул 1, мы считаем, что именно этот инстанс сервиса «выиграл гонку» и будет обрабатывать операцию. Остальные при повторе увидят, что статус уже есть.\n\n## Lua-скрипты для сложных идемпотентных операций\n\nКогда нужно сделать несколько шагов атомарно и при этом сохранить идемпотентность, выручает Lua.\n\nИдея:\n\n- перед выполнением основной логики проверить специальный ключ с идентификатором операции;\n- если ключ уже существует — вернуть сохранённый результат или код;\n- если нет — выполнить логику и записать маркер выполнения.\n\nПростейший шаблон:\n\n```\nEVAL \"\n  local status = redis.call('GET', KEYS[1])\n  if status then\n    return status\n  end\n  redis.call('SET', KEYS[1], ARGV[1])\n  return ARGV[1]\n\" 1 op:12345 \"done\"\n```\n\nОдин и тот же скрипт можно безопасно вызывать несколько раз — результат будет предсказуемым.\n\n## Итог\n\nИдемпотентность в связке с **Redis** достигается за счёт простых и атомарных команд, аккуратного использования SETNX и INCR, а при необходимости — Lua‑скриптов, которые проверяют и помечают выполнение операций.\n\nЕсли проектировать ключи и операции так, чтобы повторный вызов не ломал данные, можно смело использовать ретраи и не бояться случайных дубликатов и двойных списаний.\n\n\n"}