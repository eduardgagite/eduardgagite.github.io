{"content":"\n**Redis** обычно держит все данные в памяти. Если её не хватает, поведение сервера зависит от настроек: он либо начнёт вытеснять старые ключи, либо просто перестанет принимать записи с ошибкой. За это отвечает связка **maxmemory** и **maxmemory-policy**.\n\nЧтобы не получить неожиданный отказ от записи в продакшене, важно понимать, какие есть политики и в каких сценариях какую выбирать.\n\n## Лимит памяти maxmemory\n\nСначала задаётся общий лимит, сколько памяти **Redis** может использовать под данные.\n\nПосмотреть текущий лимит:\n\n```\nCONFIG GET maxmemory\n```\n\nУстановить, например, 1 гигабайт:\n\n```\nCONFIG SET maxmemory 1gb\n```\n\nПосле достижения лимита начинает работать политика вытеснения. Если лимит не задан (0), Redis будет пытаться использовать всю доступную память процесса и операционной системы — в продакшене это почти всегда плохая идея.\n\nОбычно лимит фиксируют на уровне, который удобно мониторить и под который рассчитан сервер.\n\n## Основные политики вытеснения\n\nПолитику можно узнать так:\n\n```\nCONFIG GET maxmemory-policy\n```\n\nИ поменять:\n\n```\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\nРаспространённые варианты:\n\n- **noeviction** — новая запись при нехватке памяти завершится ошибкой. Подходит для сценариев, где нельзя терять данные и есть внешний контроль за объёмом.\n- **volatile-lru** — выталкивать по принципу LRU только те ключи, у которых есть **TTL**.\n- **allkeys-lru** — выталкивать по LRU любые ключи. Часто используется для кэша.\n- **volatile-ttl** — удалять в первую очередь ключи с минимальным оставшимся **TTL**.\n- **allkeys-random** и **volatile-random** — выбирать ключи для удаления случайно.\n\nВ новых версиях есть также варианты на основе **LFU** (частоты использования): **allkeys-lfu** и **volatile-lfu**.\n\n## Практические сценарии выбора политики\n\nДля чистого кэша, где данные всегда можно восстановить из основной базы, чаще всего выбирают:\n\n```\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\nСценарий: хранение ключей вида **cache:article:42**, **cache:profile:10** без строгих гарантий сохранности. Redis сам будет удалять давно неиспользуемые записи, чтобы укладываться в заданный лимит.\n\nЕсли в Redis лежит не только кэш, но и важные данные, и при этом у временных ключей всегда есть **TTL**, уместен вариант:\n\n```\nCONFIG SET maxmemory-policy volatile-lru\n```\n\nТогда при нехватке памяти будут удаляться только ключи с временем жизни, а постоянные данные останутся нетронутыми. Важно следить, чтобы все «одноразовые» и кэширующие ключи действительно имели TTL.\n\n## Типичные ошибки при настройке\n\nЧастые проблемы:\n\n- лимит **maxmemory** не задан, Redis занимает всю память сервера;\n- выбрана политика **noeviction**, а приложение не умеет обрабатывать ошибку записи;\n- политика требует **TTL**, но ключи кэша и сессий создаются без явного времени жизни;\n- разные типы данных смешаны в одном инстансе Redis: и кэш, и критичные данные, и очереди.\n\nПрактичный подход — разделять назначения по разным инстансам: один Redis только под кэш с политикой **allkeys-lru**, другой — под сессии и очереди с аккуратной работой с TTL и без агрессивного вытеснения.\n\n## Итог\n\nПолитики вытеснения в **Redis** определяют, что произойдёт, когда сервер упрётся в лимит памяти: какие ключи будут удаляться и будут ли операции записи вообще успешны.\n\nГрамотный выбор **maxmemory** и **maxmemory-policy** под конкретный сценарий (кэш, сессии, очереди, критичные данные) помогает избежать неожиданного падения сервиса и контролировать поведение Redis под нагрузкой.\n\n\n"}