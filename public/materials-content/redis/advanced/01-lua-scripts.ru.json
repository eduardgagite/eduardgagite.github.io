{"content":"\nИногда одной команды Redis недостаточно: нужно сделать несколько проверок, обновить пару ключей и при этом сохранить атомарность. В таких случаях выручает встроенная поддержка **Lua-скриптов**: небольшой скрипт выполняется целиком как одна команда, без гонок между конкурентными клиентами.\n\nГлавная идея: сложная логика с несколькими шагами переносится в Redis и выполняется там, где лежат данные.\n\n## Запуск простого Lua-скрипта\n\nБазовая команда — **EVAL**. Внутри скрипта доступны массивы **KEYS** и **ARGV**: первые используются для имён ключей, вторые — для произвольных аргументов.\n\nПример: атомарно увеличить счётчик только если он меньше порога.\n\n```\nEVAL \"\n  local current = tonumber(redis.call('GET', KEYS[1]) or '0')\n  if current >= tonumber(ARGV[1]) then\n    return current\n  end\n  current = current + 1\n  redis.call('SET', KEYS[1], current)\n  return current\n\" 1 metrics:actions 100\n```\n\nЧто происходит:\n\n- скрипт читает значение **metrics:actions**;\n- если значение достигло порога **100**, просто возвращает его;\n- иначе увеличивает и сохраняет обратно;\n- вся логика выполняется как одна атомарная операция.\n\n## Использование SHA и кэширование скриптов\n\nКаждый скрипт можно загрузить в Redis и вызывать по SHA‑хэшу. Это уменьшает накладные расходы при частом запуске.\n\nЗагрузка:\n\n```\nSCRIPT LOAD \"\n  return redis.call('INCRBY', KEYS[1], tonumber(ARGV[1]))\n\"\n```\n\nRedis вернёт SHA скрипта, например:\n\n```\n\"f2b3c0...\"\n```\n\nВызов по SHA:\n\n```\nEVALSHA f2b3c0... 1 metrics:views 10\n```\n\nЕсли скрипт уже загружен, Redis сразу выполнит его, минуя повторный разбор текста.\n\n## Ограничения и практические рекомендации\n\nВажно помнить:\n\n- скрипты выполняются в одном потоке и блокируют выполнение других команд до завершения;\n- нельзя вызывать команды, которые требуют пользовательского ввода или делают блокировки;\n- скрипты должны быть быстрыми и предусказуемыми по времени выполнения.\n\nПрактичные советы:\n\n- выносить в Lua только логику, где критична атомарность и несколько шагов;\n- не загонять в скрипт огромные циклы по тысячам ключей;\n- держать код скриптов в репозитории, а не писать случайный текст прямо в консоли.\n\n## Итог\n\n**Lua-скрипты** позволяют реализовывать сложные атомарные операции прямо в Redis, без гонок и дополнительных сетевых запросов.\n\nЕсли использовать их точечно — для проверки и обновления нескольких ключей за один шаг — можно заметно упростить код приложения и повысить надёжность критичных операций.\n\n\n"}