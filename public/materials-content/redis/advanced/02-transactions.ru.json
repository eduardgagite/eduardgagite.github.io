{"content":"\nВ **Redis** нет привычных транзакций с изоляцией и откатом, как в классических СУБД, но есть механизм **MULTI/EXEC** и оптимистичные блокировки через **WATCH**. Вместе они позволяют группировать несколько команд в одну «мультикоманду» и атомарно применять изменения, если никто не успел вмешаться.\n\nВажно понимать, что транзакции в Redis — это скорее последовательное выполнение команд без прерывания, чем полноценная ACID‑модель.\n\n## MULTI/EXEC — группировка команд\n\nБазовый паттерн:\n\n1. Открываем транзакцию командой **MULTI**.\n2. Отправляем несколько команд — они не выполняются сразу, а попадают в очередь.\n3. Фиксируем изменения через **EXEC**.\n\nПример: инкремент двух счётчиков как одной операции.\n\n```\nMULTI\nINCR metrics:views\nINCR metrics:clicks\nEXEC\n```\n\nЗдесь:\n\n- обе команды попадут в очередь;\n- при EXEC Redis выполнит их последовательно, без вмешательства других клиентов между ними;\n- отката при ошибке одной команды нет — ответственность на приложении.\n\n## WATCH — оптимистичная блокировка\n\nЕсли важно убедиться, что данные не менялись между чтением и записью, используют **WATCH**. Он помечает один или несколько ключей как наблюдаемые; если какой‑то из них изменится до EXEC, транзакция не выполнится.\n\nПример: безопасное списание баланса.\n\n```\nWATCH user:42:balance\nGET user:42:balance\nMULTI\nDECRBY user:42:balance 100\nEXEC\n```\n\nСценарий:\n\n- после WATCH и GET приложение решает, достаточно ли средств;\n- если в это время другой клиент изменит **user:42:balance**, EXEC вернёт nil — транзакция не применится;\n- приложение может повторить попытку или сообщить об ошибке.\n\nТакой подход называют оптимистичной блокировкой: нет тяжёлых лочков, но есть проверка на конкурентные изменения.\n\n## Пайплайны против транзакций\n\nВажно не путать:\n\n- транзакции (**MULTI/EXEC**) — про атомарность группы команд;\n- пайплайны — про уменьшение сетевых задержек за счёт отправки нескольких команд одним пакетом.\n\nМногие клиентские библиотеки позволяют отправлять пачку команд без ожидания ответов по очереди. Это ускоряет работу, но не даёт никаких гарантий атомарности.\n\nКомбинировать подходы можно: внутри пайплайна использовать MULTI/EXEC, если нужна и скорость, и атомарность.\n\n## Итог\n\nТранзакции в **Redis** через **MULTI/EXEC** и **WATCH** помогают группировать команды и защищаться от гонок при конкурентных изменениях.\n\nЕсли правильно использовать оптимистичные блокировки и помнить об отсутствии автоматического отката, можно реализовать надёжные сценарии обновления нескольких ключей без излишнего усложнения архитектуры.\n\n\n"}