{"content":"\nДаже зная разницу между **RDB** и **AOF**, легко запутаться в реальных настройках: как часто делать snapshot, какой режим **appendfsync** выбрать, куда складывать файлы и как организовать бэкапы.\n\nЗадача этого раздела — дать практичные схемы настройки персистентности под разные сценарии и показать простые приёмы резервного копирования Redis.\n\n## Базовые настройки персистентности\n\nПроверить текущие параметры можно так:\n\n```\nCONFIG GET save\nCONFIG GET appendonly\nCONFIG GET appendfsync\nCONFIG GET dir\nCONFIG GET dbfilename\nCONFIG GET appendfilename\n```\n\nЭти команды показывают:\n\n- расписание snapshot (**save**);\n- включён ли AOF (**appendonly**);\n- частоту fsync для AOF (**appendfsync**);\n- каталог и имена файлов для RDB и AOF.\n\nМенять настройки на лету можно через **CONFIG SET**, но для долгосрочных конфигураций лучше фиксировать их в redis.conf и держать под контролем через систему управления конфигурациями.\n\n## Сценарий: Redis как кэш\n\nЕсли Redis используется только как кэш, основной источник данных находится в другой базе, а потеря содержимого Redis не критична.\n\nПрактичная схема:\n\n- отключить snapshot и AOF;\n- настроить лимит памяти и политику вытеснения.\n\nПример:\n\n```\nCONFIG SET save \"\"\nCONFIG SET appendonly no\n\nCONFIG SET maxmemory 2gb\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\nВ этом режиме Redis не делает дисковые записи ради персистентности, работает максимально быстро, а восстановление после перезапуска сводится к прогреву кэша из основного хранилища.\n\n## Сценарий: Redis хранит важные данные\n\nЕсли Redis хранит сессии, очереди задач или бизнес‑данные, которые терять нельзя, имеет смысл включить и RDB, и AOF.\n\nПример настроек:\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n\nappendonly yes\nappendfilename \"appendonly.aof\"\nappendfsync everysec\n```\n\nВажные моменты:\n\n- **appendfsync everysec** даёт баланс между скоростью и надёжностью;\n- snapshot по **save** создают регулярные RDB‑файлы, удобные для бэкапов;\n- лог AOF позволяет восстановиться почти до момента сбоя.\n\nДополнительно стоит включить репликацию на резервный инстанс и следить за временем выполнения BGSAVE и BGREWRITEAOF по метрикам.\n\n## Простые бэкапы RDB и AOF\n\nБэкап Redis сводится к копированию файлов RDB и, при необходимости, AOF.\n\nАлгоритм для RDB:\n\n1. Убедиться, что snapshot свежий (при необходимости вызвать **BGSAVE**).\n2. Подождать завершения сохранения (по логам или метрикам).\n3. Скопировать файл **dump.rdb** в безопасное хранилище.\n\nПример ручной последовательности:\n\n```\nBGSAVE\n```\n\nпосле завершения:\n\n```\ncp /var/lib/redis/dump.rdb /backups/redis/dump-2025-11-23.rdb\n```\n\nЕсли используется AOF:\n\n1. Убедиться, что нет активного BGREWRITEAOF.\n2. При желании запустить **BGREWRITEAOF**, чтобы получить компактный файл.\n3. Скопировать **appendonly.aof** в хранилище бэкапов.\n\nВ продакшене эти шаги обычно автоматизируют скриптами и кронами или средствами оркестрации.\n\n## Практические советы по персистентности\n\nНесколько правил, которые часто спасают от проблем:\n\n- выбирать режимы персистентности под конкретный сценарий, а не «на всякий случай всё включить»;\n- не запускать **SAVE** на больших базах, использовать только **BGSAVE**;\n- не забывать про влияние RDB и AOF на память и диск при настройке **maxmemory**;\n- регулярно проверять, что файлы RDB и AOF реально попадают в внешние бэкапы;\n- периодически тестировать восстановление на отдельном стенде, а не надеяться, что всё заработает само.\n\n## Итог\n\nНастройки персистентности в **Redis** — это компромисс между скоростью, надёжностью и простотой эксплуатации.\n\nЕсли осознанно выбирать между режимами «только кэш», «критичные данные» и гибридными схемами, а бэкапы делать и проверять регулярно, Redis остаётся предсказуемым и надёжным даже в сложных продакшен‑окружениях.\n\n\n"}