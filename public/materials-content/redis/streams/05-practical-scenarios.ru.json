{"content":"\n**Redis Streams** хорошо раскрываются на живых задачах: когда нужно передать событие между сервисами, организовать фоновые работы или собрать последовательный лог действий пользователей. Ниже — несколько типичных сценариев, которые легко повторить и адаптировать под свои проекты.\n\nКаждый пример опирается на уже знакомые команды **XADD**, **XREAD**, **XGROUP** и **XREADGROUP**.\n\n## Фоновые задачи: отправка писем и уведомлений\n\nКлассика для Streams — вынести отправку писем, пушей и других уведомлений в отдельную очередь, чтобы не блокировать основной HTTP-запрос.\n\nПостановка задач в очередь:\n\n```\nXGROUP CREATE notify:tasks:stream notify-workers $ MKSTREAM\n\nXADD notify:tasks:stream * user_id 123 type \"email\" template \"welcome\"\nXADD notify:tasks:stream * user_id 456 type \"push\" template \"promo\" channel \"mobile\"\n```\n\nВоркеры читают задачи и обрабатывают их:\n\n```\nXREADGROUP GROUP notify-workers worker-1 COUNT 10 STREAMS notify:tasks:stream >\n```\n\nПосле успешной отправки:\n\n```\nXACK notify:tasks:stream notify-workers 1698249601-0 1698249602-0\n```\n\nТакое разделение позволяет:\n\n- не держать пользователя в ожидании долгой отправки;\n- масштабировать только воркеры уведомлений при росте нагрузки;\n- гибко управлять повторами при временных ошибках внешних сервисов.\n\n## Лог действий пользователей для аналитики\n\nВместо того чтобы сразу писать каждое действие в тяжёлую базу, можно сначала собрать события в поток, а затем асинхронно выгружать их в хранилище аналитики.\n\nЗапись событий:\n\n```\nXADD analytics:user:activity:stream * user_id 123 action \"view_page\" page \"/products/42\"\nXADD analytics:user:activity:stream * user_id 123 action \"add_to_cart\" product_id 42\nXADD analytics:user:activity:stream * user_id 789 action \"search\" query \"laptop\"\n```\n\nСервис аналитики периодически читает новые записи:\n\n```\nXREAD COUNT 100 STREAMS analytics:user:activity:stream $\n```\n\nЛибо работает через свою группу:\n\n```\nXGROUP CREATE analytics:user:activity:stream analytics-workers $ MKSTREAM\nXREADGROUP GROUP analytics-workers etl-1 COUNT 100 STREAMS analytics:user:activity:stream >\n```\n\nПреимущества:\n\n- события не теряются, даже если аналитическое хранилище временно недоступно;\n- можно повторно прогнать историю для отладки или перерасчёта метрик;\n- нагрузка на основную базу снижается, так как запись идёт батчами.\n\n## Шина событий между микросервисами\n\nStreams удобно использовать как простую шину событий: один сервис публикует бизнес-события, остальные подписываются на них через свои группы.\n\nПродюсер заказов пишет в поток:\n\n```\nXADD events:orders:stream * event \"order_created\" order_id 501 user_id 123 amount 1500\nXADD events:orders:stream * event \"order_cancelled\" order_id 502 user_id 456 reason \"payment_failed\"\n```\n\nСервис биллинга создаёт свою группу и реагирует только на нужные события:\n\n```\nXGROUP CREATE events:orders:stream billing-subscribers $ MKSTREAM\nXREADGROUP GROUP billing-subscribers billing-1 COUNT 10 STREAMS events:orders:stream >\n```\n\nСервис уведомлений делает то же самое, но обрабатывает события по-своему:\n\n```\nXGROUP CREATE events:orders:stream notify-subscribers $ MKSTREAM\nXREADGROUP GROUP notify-subscribers notify-1 COUNT 10 STREAMS events:orders:stream >\n```\n\nКаждая группа видит все события независимо от других и ведёт свой прогресс чтения. Это позволяет легко добавлять новые потребители, не меняя продюсера.\n\n## Ограничение скоростей и «умные» очереди\n\nStreams можно использовать как основу для rate limiting и более сложных схем обработки, когда важно не только выполнить задачи, но и соблюдать ограничения по скорости.\n\nНапример, у нас есть поток задач на внешнее API, где нельзя делать больше 100 запросов в минуту:\n\n```\nXGROUP CREATE external:api:tasks:stream api-workers $ MKSTREAM\n\nXADD external:api:tasks:stream * user_id 123 endpoint \"/profile\" priority \"normal\"\nXADD external:api:tasks:stream * user_id 456 endpoint \"/balance\" priority \"high\"\n```\n\nВоркеры:\n\n- читают задачи через **XREADGROUP**;\n- перед выполнением смотрят счётчик запросов в **rate:external:api**;\n- либо сразу выполняют и инкрементят счётчик, либо откладывают задачу на потом.\n\nКомбинация **Streams** и счётчиков в Redis позволяет строить гибкие схемы ограничения скорости без сложной инфраструктуры.\n\n## Итог\n\n**Redis Streams** хорошо подходят для задач, где есть последовательность событий или задач, которые нужно безопасно передавать между частями системы и обрабатывать асинхронно.\n\nНа их основе можно строить очереди фоновых работ, логи и шины событий для микросервисов, при этом оставаясь в рамках знакомого Redis и не вводя отдельную систему для каждого сценария."}