{"content":"\nВ основе работы с **Redis Streams** лежат три команды: **XADD** для записи сообщений, **XREAD** для чтения и **XGROUP** для создания и управления группами потребителей. На практике этого уже достаточно, чтобы построить простую очередь задач или обработку событий между сервисами.\n\nРазберём, как они работают на реальных примерах: от простого «написать и прочитать» до подготовки потока к использованию с группами.\n\n## XADD — добавление сообщений в поток\n\nКоманда **XADD** добавляет новое сообщение в конец потока. Минимальный вариант:\n\n```\nXADD orders:stream * user_id 123 status \"created\" amount 1000\n```\n\nЧто здесь происходит:\n\n- создаётся поток **orders:stream**, если его ещё нет;\n- символ звёздочки говорит Redis сгенерировать идентификатор автоматически;\n- дальше идут пары поле–значение: **user_id 123**, **status \"created\"**, **amount 1000**.\n\nВ ответ Redis вернёт идентификатор сообщения, например:\n\n```\n\"1698249601-0\"\n```\n\nЕсли нужно ограничивать размер потока, можно сразу включить обрезку:\n\n```\nXADD orders:stream MAXLEN 1000 * user_id 123 status \"created\" amount 1000\n```\n\nВ этом случае в потоке будет храниться примерно 1000 последних записей, более старые Redis будет удалять по мере добавления новых. Это удобно для логов и аналитики, где не нужна бесконечная история.\n\n## XREAD — чтение сообщений из потока\n\nКоманда **XREAD** читает сообщения из одного или нескольких потоков. Простейший пример — прочитать всё с начала:\n\n```\nXREAD COUNT 3 STREAMS orders:stream 0-0\n```\n\nЗдесь:\n\n- **COUNT 3** ограничивает количество возвращаемых сообщений;\n- **STREAMS orders:stream** указывает, из какого потока читать;\n- **0-0** означает «начать с самого начала потока».\n\nОбычно **XREAD** используют для чтения только новых сообщений. Для этого вместо конкретного идентификатора передают доллар:\n\n```\nXREAD BLOCK 5000 STREAMS orders:stream $\n```\n\nВажные детали:\n\n- **$** означает «ждать только новые сообщения, которых ещё нет у клиента»;\n- **BLOCK 5000** говорит: подождать до 5 секунд появления новых данных, затем вернуть управление даже если сообщений нет.\n\nТак клиент может держать соединение с Redis и получать события почти в реальном времени, не опрашивая сервер в цикле.\n\nЕсли поток не существует, **XREAD** просто вернёт пустой результат. Ошибки не будет — это нужно учитывать в приложении и, при необходимости, создавать поток через **XADD** заранее.\n\n## XGROUP — подготовка потока для групп потребителей\n\nГруппы потребителей — это ключевая возможность **Streams**, которая позволяет нескольким воркерам обрабатывать поток, не дублируя работу. Чтобы использовать группы, поток сначала нужно подготовить командой **XGROUP CREATE**.\n\nСоздадим поток задач на отправку писем и группу обработчиков:\n\n```\nXGROUP CREATE email:tasks:stream email-workers 0-0 MKSTREAM\n```\n\nЗдесь:\n\n- **email:tasks:stream** — ключ потока;\n- **email-workers** — имя группы;\n- **0-0** — с какого идентификатора считать сообщения доступными группе;\n- **MKSTREAM** говорит Redis создать поток, если его ещё нет.\n\nЧаще на практике используют специальное значение доллара:\n\n```\nXGROUP CREATE email:tasks:stream email-workers $ MKSTREAM\n```\n\nТак группа начнёт работу только с новыми сообщениями, которые появятся после создания, не затрагивая старую историю.\n\nЕсли попытаться создать группу повторно с теми же именами потока и группы, Redis вернёт ошибку. Поэтому в автоматических скриптах часто используют вариант с игнорированием ошибки на создание или проверяют наличие группы заранее.\n\n## Связка XADD, XREAD и XGROUP в живой системе\n\nРеальная схема обычно выглядит так:\n\n1. Один или несколько сервисов добавляют задачи в поток с помощью **XADD**.\n2. Поток один раз подготавливается под группы с помощью **XGROUP CREATE**.\n3. Воркеры читают сообщения уже не через **XREAD**, а через **XREADGROUP** (об этом подробно в следующем разделе).\n\nПример — постановка задач на отправку писем:\n\nСоздание группы:\n\n```\nXGROUP CREATE email:tasks:stream email-workers $ MKSTREAM\n```\n\nДобавление задач:\n\n```\nXADD email:tasks:stream * user_id 123 template \"welcome\"\nXADD email:tasks:stream * user_id 456 template \"reset_password\"\n```\n\nЧтение новых задач без групп (для простого потребителя или отладки):\n\n```\nXREAD COUNT 10 STREAMS email:tasks:stream 0-0\n```\n\nВ боевом варианте вместо этого используют чтение через **XREADGROUP**, чтобы распределять задачи между несколькими воркерами и подтверждать успешную обработку.\n\n## Итог\n\nКоманды **XADD**, **XREAD** и **XGROUP** формируют базовый набор для работы с **Redis Streams**: первая пишет события, вторая читает их, третья готовит поток к распределённой обработке через группы потребителей.\n\nПонимание этих команд позволяет уже на этом уровне построить простую, но рабочую систему очередей и логов. В следующем разделе мы углубимся в **Consumer Groups** и посмотрим, как организовать надёжную обработку сообщений несколькими воркерами с подтверждением и повторными попытками."}