{"content":"\n**Redis Streams** — это способ работать с событиями как с непрерывной лентой записей. Вместо того чтобы просто хранить значение по ключу, мы получаем упорядоченный поток сообщений, к которому можно подключаться, читать новые элементы и обрабатывать их как очередь задач или лог событий.\n\nГлавная идея проста: в поток постоянно добавляются новые события, каждое получает уникальный идентификатор и набор полей. Клиенты могут читать эти события с нужного места, не теряя порядок, и строить вокруг этого надёжную обработку.\n\n## Поток как лог событий\n\nУ обычных структур данных в Redis мы работаем с текущим состоянием: значение ключа, содержимое списка, хеша или множества. В **Streams** мы работаем с историей изменений — каждое событие добавляется в конец потока и остаётся там, пока мы его явно не удалим или не обрежем.\n\nПредставим поток событий заказов:\n\n```\nXADD orders:stream * user_id 123 status \"created\" amount 1000\nXADD orders:stream * user_id 456 status \"paid\" amount 500\nXADD orders:stream * user_id 123 status \"shipped\" amount 1000\n```\n\nКаждый вызов **XADD** добавляет запись в конец **orders:stream** и возвращает её идентификатор вида время-последовательность, например:\n\n```\n1698249572-0\n1698249573-0\n1698249574-0\n```\n\nБазовая модель простая:\n\n- поток — это упорядоченная лента событий;\n- каждое событие имеет уникальный идентификатор;\n- данные события — это набор полей и значений.\n\nТакой подход удобно использовать для логов, журналов действий пользователей, бизнес-событий между сервисами.\n\n## Структура записи в потоке\n\nКаждое сообщение в **Streams** — это пара: идентификатор и набор полей. Полей может быть сколько угодно, главное — соблюдать разумную схему.\n\nТипичная запись для логирования действий пользователя:\n\n```\nXADD user:activity:stream * user_id 123 action \"login\" ip \"10.0.0.5\"\nXADD user:activity:stream * user_id 123 action \"view_page\" page \"/products/42\"\nXADD user:activity:stream * user_id 789 action \"logout\" reason \"timeout\"\n```\n\nЗдесь есть несколько важных моментов:\n\n- ключ потока **user:activity:stream** явно говорит о назначении;\n- поле **user_id** позволяет связать события с конкретным пользователем;\n- поля **action**, **page**, **ip**, **reason** дают контекст для аналитики и отладки.\n\nКогда позже мы будем читать поток, эти же поля используются для разбора сообщения и принятия решения, что с ним делать.\n\n## Идентификаторы сообщений и порядок\n\nИдентификатор в **Streams** обычно генерируется автоматически с помощью звёздочки:\n\n```\nXADD metrics:payments:stream * status \"ok\" amount 150\n```\n\nRedis подставляет текущее время и счётчик, формируя значение вида время-последовательность. Это обеспечивает строгий порядок: новые сообщения всегда идут после старых.\n\nИдентификаторы используются:\n\n- чтобы читать поток начиная с нужного места;\n- чтобы не пропускать сообщения при повторных чтениях;\n- чтобы понимать, какие события уже были обработаны.\n\nБазовое чтение потока выглядит так:\n\n```\nXREAD COUNT 2 STREAMS orders:stream 0-0\n```\n\nКоманда вернёт первые две записи из **orders:stream**, начиная с самого начала. Специальный идентификатор 0-0 означает «читать с начала потока». Если вместо него подставить последний прочитанный идентификатор, можно продолжить чтение с нужного места.\n\n## Когда Streams подходят, а когда нет\n\n**Streams** логичнее всего использовать там, где есть последовательность событий, которые нужно обрабатывать по порядку или раздавать нескольким потребителям:\n\n- логирование действий пользователей;\n- события от микросервисов;\n- очереди задач с подтверждением обработки;\n- аналитические события для последующей агрегации.\n\nЕсли задача — просто хранить последнее состояние объекта, например текущий баланс или актуальный профиль пользователя, **Streams** будут излишни. В таких случаях проще и дешевле по памяти использовать строки или хеши.\n\nВажно понимать, что поток сам по себе не очищается. Если не использовать обрезку, он будет расти бесконечно. В разделах про команды и очереди сообщений мы разберём, как управлять размером потока и не давать ему разрастаться.\n\n## Итог\n\n**Redis Streams** дают удобную модель лога событий: каждая запись добавляется в конец потока, получает уникальный идентификатор и остаётся доступной для чтения и повторной обработки.\n\nЭта структура идеально подходит для задач, где важна история и порядок событий, а не только текущее состояние. Главное — сразу продумать схему ключей, поля сообщений и политику очистки, чтобы поток оставался управляемым и полезным."}