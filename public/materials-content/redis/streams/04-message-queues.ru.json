{"content":"\nС помощью **Redis Streams** можно строить надёжные очереди сообщений: один или несколько сервисов кладут задачи в поток, а группа воркеров забирает их, обрабатывает и подтверждает выполнение. В отличие от простых списков, здесь есть подтверждение обработки, повторная выдача задач при сбоях и возможность масштабировать потребителей.\n\nРазберём, как собрать рабочую очередь пошагово: от постановки задач до обработки и очистки.\n\n## Очередь задач на одном потоке\n\nБазовая модель очереди — один поток для задач и одна группа потребителей.\n\nСоздадим поток и группу для воркеров, которые рассылают письма:\n\n```\nXGROUP CREATE email:tasks:stream email-workers $ MKSTREAM\n```\n\nТеперь любой сервис может положить задачу в очередь:\n\n```\nXADD email:tasks:stream * user_id 123 template \"welcome\"\nXADD email:tasks:stream * user_id 456 template \"reset_password\"\n```\n\nВоркеры читают задачи из группы:\n\n```\nXREADGROUP GROUP email-workers worker-1 COUNT 5 STREAMS email:tasks:stream >\n```\n\nКаждый воркер:\n\n- получает набор задач;\n- обрабатывает каждую (например, отправляет письмо);\n- подтверждает обработку через **XACK**:\n\n```\nXACK email:tasks:stream email-workers 1698249601-0 1698249602-0\n```\n\nТак формируется классическая очередь: задачи приходят в поток, распределяются по воркерам и отмечаются как выполненные.\n\n## Масштабирование: несколько воркеров и балансировка\n\nЧтобы увеличить пропускную способность, достаточно добавить ещё воркеры с разными именами потребителей в той же группе:\n\n```\nXREADGROUP GROUP email-workers worker-2 COUNT 5 STREAMS email:tasks:stream >\nXREADGROUP GROUP email-workers worker-3 COUNT 5 STREAMS email:tasks:stream >\n```\n\nRedis сам будет раздавать новые сообщения между **worker-1**, **worker-2**, **worker-3**. Сообщение попадает только одному потребителю, поэтому работа не дублируется.\n\nЕсли один из воркеров падает, его незавершённые сообщения остаются в PEL. Их можно:\n\n- либо автоматически переобрабатывать тем же воркером после перезапуска;\n- либо вручную перераспределить через **XPENDING** и **XCLAIM**, как описано в разделе про Consumer Groups.\n\nТаким образом, очередь остаётся живой даже при частичных сбоях.\n\n## Ограничение размера очереди и очистка\n\nЕсли в очередь постоянно добавляются новые задачи, важно не дать потоку вырасти бесконечно. Для этого используют обрезку через **MAXLEN** в **XADD**:\n\n```\nXADD email:tasks:stream MAXLEN 10000 * user_id 123 template \"welcome\"\n```\n\nЗдесь в потоке в среднем будет примерно 10000 последних задач. Старые записи удаляются. Для обычных рабочих очередей этого достаточно: нас интересуют только актуальные задачи.\n\nИногда нужно жёстко ограничить размер, чтобы контролировать память. Тогда используют опцию **MAXLEN ~** или без тильды — чем строже ограничение, тем чаще Redis будет тратить ресурсы на поддержание длины.\n\nЕсли требуется полностью очистить очередь, можно удалить поток:\n\n```\nDEL email:tasks:stream\n```\n\nПосле этого при первом **XADD** поток создастся заново, но группы потребителей тоже исчезнут. В боевых системах чаще регулируют длину и периодически чистят старые данные, не удаляя поток полностью.\n\n## Разделение очередей по типам задач\n\nВ реальных системах удобно делить очереди по типам работ:\n\n- **email:tasks:stream** — отправка писем;\n- **billing:tasks:stream** — операции с оплатами;\n- **reports:tasks:stream** — генерация отчётов.\n\nКаждая очередь получает свою группу потребителей и набор воркеров. Например, для биллинга создадим отдельную группу:\n\n```\nXGROUP CREATE billing:tasks:stream billing-workers $ MKSTREAM\n```\n\nПостановка задачи:\n\n```\nXADD billing:tasks:stream * user_id 999 type \"invoice\" amount 2500\n```\n\nОбработка:\n\n```\nXREADGROUP GROUP billing-workers billing-1 COUNT 5 STREAMS billing:tasks:stream >\n```\n\nТак можно независимо масштабировать только те очереди, которые действительно нагружены, не трогая остальные.\n\n## Итог\n\n**Redis Streams** позволяют строить очереди сообщений с подтверждением обработки, перераспределением «зависших» задач и масштабированием воркеров через Consumer Groups.\n\nПри грамотной схеме ключей, ограничении длины потока и аккуратной работе с подтверждениями получается гибкий и надёжный механизм фоновой обработки задач, который легко вписывается в микросервисную архитектуру."}