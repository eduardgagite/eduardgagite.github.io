{"content":"\n**Consumer Groups** в **Redis Streams** позволяют нескольким воркерам безопасно обрабатывать один и тот же поток сообщений, не дублируя работу и не теряя события. Каждый воркер входит в группу, получает свою порцию задач и подтверждает обработку, чтобы Redis мог переотдать незавершённые сообщения при сбоях.\n\nЕсли смотреть на это практическими глазами, Consumer Groups — это способ построить пул воркеров поверх одного потока: сколько бы экземпляров сервиса ни работало, каждое сообщение будет обработано ровно одним из них.\n\n## Базовая схема работы группы\n\nПредставим поток задач на обработку заказов:\n\n```\nXGROUP CREATE orders:stream orders-workers $ MKSTREAM\n```\n\nДальше в приложении поднимаются несколько воркеров, каждый со своим именем потребителя внутри группы:\n\n```\nXREADGROUP GROUP orders-workers worker-1 COUNT 10 STREAMS orders:stream >\nXREADGROUP GROUP orders-workers worker-2 COUNT 10 STREAMS orders:stream >\n```\n\nВажные детали:\n\n- **orders-workers** — имя группы потребителей;\n- **worker-1** и **worker-2** — имена конкретных потребителей (экземпляров сервиса);\n- символ **>** говорит «дай мне только новые сообщения, которые ещё никому не назначены».\n\nRedis раздаёт новые сообщения между потребителями внутри группы. Если воркеров несколько, задачи распределяются по ним, как в очереди.\n\n## Подтверждение обработки: XACK и PEL\n\nКогда воркер прочитал сообщение через **XREADGROUP** и успешно его обработал, он обязан подтвердить это командой **XACK**:\n\n```\nXACK orders:stream orders-workers 1698249601-0\n```\n\nЗдесь:\n\n- **orders:stream** — поток;\n- **orders-workers** — группа;\n- **1698249601-0** — идентификатор обработанного сообщения.\n\nПока подтверждения нет, сообщение считается «висящим» в специальном списке PEL (Pending Entries List). Посмотреть такие сообщения можно через **XPENDING**:\n\n```\nXPENDING orders:stream orders-workers\n```\n\nВ ответ Redis покажет:\n\n- сколько сообщений «в работе»;\n- минимальный и максимальный идентификаторы;\n- примеры по потребителям.\n\nЭто особенно полезно, когда один из воркеров упал и не успел подтвердить обработку. Сообщения не пропадают, их можно перераспределить.\n\n## Повторная выдача сообщений другим воркерам\n\nЕсли потребитель перестал отвечать, сообщения, которые числятся за ним в PEL, можно вручную или программно передать другому воркеру. Для этого используется команда **XCLAIM**.\n\nПример: за **worker-1** «зависли» сообщения, которые висят дольше 60 секунд. Мы хотим передать их **worker-2**:\n\nСначала смотрим, какие сообщения зависли у **worker-1**:\n\n```\nXPENDING orders:stream orders-workers - + 10 worker-1\n```\n\nДопустим, среди них есть **1698249601-0**. Тогда:\n\n```\nXCLAIM orders:stream orders-workers worker-2 60000 1698249601-0\n```\n\nЗдесь:\n\n- **worker-2** забирает себе сообщение;\n- **60000** — минимальное время в миллисекундах, которое сообщение должно провести в PEL, прежде чем его можно будет «забрать».\n\nПосле успешной обработки новый воркер так же делает **XACK**, и сообщение окончательно считается завершённым.\n\n## Типичный цикл жизни сообщения в группе\n\nЕсли собрать всё вместе, жизнь одной записи в **Streams** с Consumer Groups выглядит так:\n\n1. Продюсер добавляет запись в поток через **XADD**.\n2. Группа уже создана командой **XGROUP CREATE**.\n3. Один из воркеров читает запись через **XREADGROUP** с маркером **>**.\n4. Redis назначает сообщение этому потребителю и помещает его в PEL.\n5. Воркер обрабатывает задачу и вызывает **XACK**.\n6. Сообщение остаётся в потоке как часть истории, но больше не считается «висящим» в группе.\n\nЕсли воркер падает между шагами 3 и 5, сообщение остаётся в PEL и может быть перераспределено через **XPENDING** и **XCLAIM**.\n\n## Когда стоит использовать Consumer Groups\n\nConsumer Groups особенно полезны в сценариях:\n\n- есть поток задач, которые должны быть выполнены ровно один раз;\n- нагрузка плавает, и нужно просто добавлять или убирать воркеры;\n- важно не терять сообщения при падении отдельных экземпляров сервиса;\n- несколько сервисов читают один и тот же поток по-разному — для этого можно создать несколько независимых групп на одном потоке.\n\nЕсли же есть всего один потребитель, который читает поток линейно, можно обойтись обычным **XREAD** и собственным хранением последнего прочитанного идентификатора. Consumer Groups здесь дадут больше сложности, чем пользы.\n\n## Итог\n\n**Consumer Groups** превращают Redis Streams в полноценную основу для распределённых очередей: сообщения раздаются между воркерами, отслеживаются в PEL, подтверждаются и при необходимости перераспределяются.\n\nТакой подход позволяет строить надёжные системы обработки задач без потерь и дублирования, сохраняя при этом всю историю событий в самом потоке."}