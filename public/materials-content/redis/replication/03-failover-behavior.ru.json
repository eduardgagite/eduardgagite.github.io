{"content":"\nРепликация в Redis сама по себе не даёт автоматического переключения при сбоях, но задаёт базовую модель, как система ведёт себя, когда падает master или отваливается сеть. Понимание этого поведения важно, чтобы не потерять данные и правильно строить сценарии аварийного восстановления.\n\nРазберём типичные ситуации: отказ master, потеря связи с replica и ручной перевод роли.\n\n## Если упал master\n\nКогда основной узел недоступен:\n\n- записи на него перестают работать — приложение получает ошибки подключения;\n- реплики продолжают обслуживать запросы на чтение с теми данными, которые у них уже есть;\n- репликация останавливается до восстановления связи.\n\nПриложение может временно переключить чтение на реплики, но записи всё равно придётся куда‑то направлять. Без Sentinel или кластера переключение ролей происходит вручную.\n\nПростой сценарий ручного failover:\n\n1. Убедиться, что master действительно недоступен и не вернётся.\n2. Выбрать одну из реплик как новую основную.\n3. На этой реплике выполнить:\n\n```\nREPLICAOF NO ONE\n```\n\nТеперь узел станет самостоятельным master. Приложение переводит записи на этот адрес.\n\n## Если потерялась связь с репликой\n\nКогда сеть между master и replica рвётся:\n\n- master продолжает работать как обычно;\n- replica перестаёт получать новые данные, но всё ещё обслуживает чтение на своём старом состоянии;\n- в **INFO replication** на master видно, что состояние реплики offline, а offset не растёт.\n\nЕсли реплика используется для чтения, важно понимать, что данные на ней могут отставать на минуту, час или дольше, в зависимости от того, сколько длится проблема с сетью.\n\nКогда связь восстанавливается, Redis пытается сделать частичную синхронизацию. Если это невозможно (слишком большое отставание, переполнен журнал), происходит полная ресинхронизация заново.\n\n## Риск потери данных при принудительном переключении\n\nВ ручном failover есть важная тонкость. Если:\n\n- master успел принять часть записей;\n- эти записи ещё не долетели до replica из‑за задержки или сети;\n- мы переводим replica в master;\n\nто эти «последние» записи на старом master будут потеряны.\n\nПоэтому:\n\n- при возможности стоит использовать Sentinel или кластер, которые учитывают задержки и согласованность;\n- в критичных системах полезно применять команду **WAIT**, чтобы убедиться, что запись дошла до нужного числа реплик:\n\n```\nSET user:42:name \"Alice\"\nWAIT 1 1000\n```\n\nЗдесь Redis вернёт, на сколько реплик запись точно дошла за 1000 миллисекунд. Это не полностью решает проблему, но даёт больше контроля.\n\n## Автоматический failover: куда смотреть дальше\n\nЧистая репликация решает задачу копирования данных, но не управляет ролями master и replica. Для автоматического переключения при сбоях используют:\n\n- **Redis Sentinel** — наблюдает за узлами, голосует о недоступности master и продвигает одну из реплик;\n- **Redis Cluster** — распределяет данные по шартам и имеет встроенный механизм failover.\n\nОсновные принципы остаются прежними, но логика выбора нового master и перенастройки клиентов перекладывается на инфраструктуру.\n\n## Итог\n\nПри сбоях в репликации **Redis** ведёт себя предсказуемо: master остаётся единственной точкой записи, реплики продолжают обслуживать чтение, а переключение ролей нужно делать вручную или через Sentinel и кластер.\n\nЕсли учитывать возможное отставание реплик и аккуратно подходить к ручному failover, можно избежать потери последних записей и построить надёжную схему аварийного восстановления.\n\n\n"}