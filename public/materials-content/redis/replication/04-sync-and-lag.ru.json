{"content":"\nРепликация в Redis асинхронная: master не ждёт, пока все реплики применят изменения, прежде чем ответить клиенту. Это делает систему очень быстрой, но всегда оставляет небольшой риск отставания и потери части последних данных при сбое.\n\nЧтобы управлять этим риском, важно понимать, как работает синхронизация, как измерять задержки и в каких ситуациях имеет смысл ждать подтверждения от реплик.\n\n## Полная и частичная синхронизация\n\nПри первом подключении replica делает полную синхронизацию:\n\n1. master создаёт snapshot и отправляет его реплике;\n2. replica загружает snapshot и применяет его;\n3. после этого replica продолжает принимать поток новых команд.\n\nЕсли соединение временно обрывается, Redis пытается использовать частичную синхронизацию. Для этого он:\n\n- ведёт журнал смещений репликации (offset);\n- хранит недавние команды в буфере.\n\nЕсли отставание реплики укладывается в этот буфер, мастер досылает только недостающие команды. Если нет — запускается новая полная синхронизация.\n\nПонять, что происходит, можно через:\n\n```\nINFO replication\n```\n\nТам видно смещения, состояние связей и отставание по каждой реплике.\n\n## Измерение задержек между master и replica\n\nВ разделе репликации **INFO** показывает показатель **lag** для каждой реплики:\n\n```\nslave0:ip=10.0.0.2,port=6379,state=online,offset=12345,lag=1\n```\n\nПолезные значения:\n\n- **lag** — сколько секунд прошло с момента последнего подтверждения от replica;\n- **offset** — позиция в потоке репликации.\n\nЕсли **lag** растёт и долго держится на больших значениях, это сигнал, что:\n\n- сеть между master и replica нестабильна;\n- ресурсы на реплике не успевают переваривать поток команд;\n- или есть проблемы с диском, если включены тяжёлые режимы персистентности.\n\nТакие ситуации стоит мониторить и настраивать алерты.\n\n## Когда надо ждать подтверждения от реплик (WAIT)\n\nДля операций, которые нельзя потерять, Redis предлагает команду **WAIT**. Она позволяет дождаться, пока данные будут гарантированно записаны на заданное число реплик.\n\nПример:\n\n```\nSET order:501 \"...\"\nWAIT 1 1000\n```\n\nЗдесь:\n\n- первое число — сколько реплик нужно дождаться;\n- второе — таймаут в миллисекундах.\n\nRedis вернёт число реплик, которые подтвердили запись за отведённое время. Если это число меньше ожидаемого, приложение может принять решение:\n\n- повторить операцию позже;\n- зафиксировать факт частичной репликации;\n- временно остановить критичные операции.\n\nВажно помнить, что **WAIT** увеличивает задержку ответа для клиента и не превращает Redis в полностью синхронную систему, но даёт больше контроля для отдельных особо важных операций.\n\n## Практические рекомендации по работе с задержками\n\nНесколько рабочих правил:\n\n- не считать, что replica всегда идеально синхронизирована с master — небольшое отставание нормально;\n- мониторить **lag** и **offset** через **INFO replication**;\n- аккуратно относиться к чтению с реплик там, где нужны строго консистентные данные;\n- использовать **WAIT** только для критичных операций, где допустима дополнительная задержка;\n- следить, чтобы полная синхронизация не запускалась слишком часто — это признак проблем с сетью, памятью или конфигурацией.\n\n## Итог\n\nСинхронизация и задержки в репликации **Redis** — это баланс между скоростью и консистентностью: асинхронная модель делает систему очень быстрой, но требует осознанного отношения к отставанию реплик.\n\nЕсли регулярно смотреть на метрики репликации и точечно использовать инструменты вроде **WAIT**, можно контролировать риск потери данных и при этом не потерять главное преимущество Redis — высокую производительность.\n\n\n"}