{"content":"\n**Шардинг** в Redis — это разбиение ключей по нескольким узлам так, чтобы каждый узел хранил только часть данных. В режиме Redis Cluster шардинг встроен: кластер сам решает, на каком узле должен жить каждый ключ.\n\nЗадача разработчика — понимать, как работает распределение по слотам, и при необходимости управлять тем, какие ключи должны храниться вместе.\n\n## Хэш‑слоты и распределение ключей\n\nВ Redis Cluster пространство ключей разбито на **16384 хэш‑слота**. Каждый ключ попадает в один слот по формуле:\n\n```\nhash_slot = CRC16(key) mod 16384\n```\n\nКаждый мастер в кластере отвечает за подмножество этих слотов. При изменении топологии (добавление/удаление узлов) слоты могут мигрировать между мастерами.\n\nПосмотреть распределение слотов можно через:\n\n```\nCLUSTER SLOTS\n```\n\nОтвет покажет диапазоны слотов и узлы, за которые они отвечают.\n\n## Управление группами ключей через hash tags\n\nИногда нужно, чтобы несколько ключей гарантированно оказались на одном и том же узле — например, для транзакций, Lua‑скриптов или операций с несколькими ключами. Для этого используют **hash tags**.\n\nИдея простая: если в имени ключа есть фигурные скобки, для расчёта слота берётся только содержимое внутри скобок.\n\nПример:\n\n```\nSET user:{42}:profile \"{...}\"\nSET user:{42}:settings \"{...}\"\n```\n\nОба ключа попадут в один и тот же слот, потому что для хеша используется только подстрока **42**. Это позволяет безопасно использовать операции, которые требуют, чтобы все задействованные ключи были на одном мастере.\n\n## Добавление и удаление шардов\n\nКогда нагрузка растёт, в кластер можно добавить новые узлы и распределить слоты заново.\n\nПример добавления нового мастера:\n\n```\nredis-cli --cluster add-node 10.0.0.4:6379 10.0.0.1:6379\n```\n\nПосле этого слоты нужно перенести на новый узел:\n\n```\nredis-cli --cluster reshard 10.0.0.1:6379\n```\n\nИнтерактивно выбирается, сколько слотов и откуда переносить. Кластер во время миграции использует редиректы **ASK**, но для клиентов, поддерживающих Redis Cluster, этот процесс прозрачен.\n\nУдаление шардов работает похоже, только слоты сначала переносятся на другие мастера, а потом узел выбывает из кластера.\n\n## Классический client-side шардинг\n\nПомимо встроенного шардинга кластера, есть старый подход — **client-side шардинг**, когда приложение само решает, на какой Redis отправить ключ.\n\nПример идеи:\n\n- есть три инстанса Redis;\n- приложение считает хеш от ключа и по модулю количества инстансов выбирает нужный.\n\nТакой подход проще на старте, но:\n\n- не умеет автоматически перераспределять данные при изменении числа узлов;\n- не даёт встроенного failover;\n- требует много ручной работы при миграции.\n\nПоэтому для новых проектов чаще выбирают Redis Cluster, а client-side шардинг оставляют для специфических случаев.\n\n## Итог\n\nШардинг в **Redis Cluster** основан на 16384 хэш‑слотах, которые автоматически распределяются между мастер‑узлами и могут мигрировать при изменении топологии.\n\nИспользуя hash tags и штатные команды кластера для добавления и удаления узлов, можно контролировать, какие ключи лежат вместе, и плавно масштабировать систему, не переписывая логику приложения.\n\n\n"}