{"content":"\nRedis хорошо масштабируется вертикально (больше памяти и CPU на одном сервере), но в какой‑то момент этого становится мало. Тогда в игру вступают репликация, Sentinel и Redis Cluster — вместе они позволяют распределять нагрузку по нескольким узлам и переживать рост трафика.\n\nВажно понимать, какие рычаги масштабирования есть и как выбрать подходящий набор под конкретную систему.\n\n## Масштабирование чтения: реплики\n\nСамый простой шаг — разгрузить master, отправив часть чтений на реплики.\n\nПример идеи:\n\n- все записи идут на master;\n- часть чтений (например, отчёты, фоновые выборки) перенаправляется на replica.\n\nВыбор узла на стороне приложения:\n\n- для критичных к консистентности операций (балансы, заказы) читать только с master;\n- для менее критичных (отчёты, статистика, ленты новостей) — использовать реплики.\n\nРепликация настраивается так же, как в разделе про master–replica:\n\n```\nREPLICAOF 10.0.0.1 6379\n```\n\nТак можно постепенно добавлять новые реплики и горизонтально масштабировать чтение.\n\n## Масштабирование записи: кластер и шардинг\n\nЕсли упираемся уже не только в чтение, но и в запись, одного master становится мало. Здесь помогает Redis Cluster:\n\n- данные распределяются по нескольким master‑узлам;\n- каждый мастер обслуживает только свою часть ключей и нагрузку;\n- при необходимости каждому мастер‑узлу добавляются свои реплики.\n\nСоздание кластера:\n\n```\nredis-cli --cluster create \\\n  10.0.0.1:6379 10.0.0.2:6379 10.0.0.3:6379 \\\n  --cluster-replicas 1\n```\n\nДальше масштабирование сводится к добавлению новых шардов и перераспределению слотов. Клиенты, которые понимают Redis Cluster, автоматически разруливают маршрутизацию запросов.\n\n## Горизонтальное масштабирование с Sentinel\n\nSentinel сам по себе не масштабирует Redis по данным, но помогает масштабировать по доступности:\n\n- добавляем несколько master–replica пар для разных подсистем (кэш, сессии, очереди);\n- над каждой парой работает свой набор Sentinel;\n- клиенты знают только имена логических master и не привязаны к конкретным адресам.\n\nТак можно:\n\n- разделить нагрузку по функциям (один Redis под кэш, другой под сессии);\n- независимо масштабировать каждую часть;\n- при сбоях на уровне узла получать автоматический failover без даунтайма.\n\n## Выбор стратегии под задачу\n\nУсловно можно выделить несколько стадий развития:\n\n- один Redis‑узел с репликами для чтения — достаточно для большинства средних проектов;\n- несколько master–replica пар под разные задачи — когда важно изоляция и предсказуемость;\n- Redis Cluster — когда общий объём данных и нагрузка выходят за рамки одного сервера.\n\nПри этом Sentinel обычно присутствует на всех стадиях, где важна высокая доступность: он не масштабирует, но держит систему живой при отказах.\n\n## Итог\n\nМасштабирование по нагрузке в **Redis** строится слоями: сначала реплики для чтения, затем несколько master–replica пар под разные подсистемы и, при необходимости, Redis Cluster для горизонтального шардинга.\n\nЕсли заранее продумать, какие данные где хранятся и как клиенты находят актуальный master, можно плавно наращивать инфраструктуру Redis без резких архитектурных переделок.\n\n\n"}