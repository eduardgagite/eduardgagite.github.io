{"content":"\nРаспределённые блокировки нужны, когда несколько процессов или серверов должны координировать доступ к общему ресурсу. Например, только один воркер должен обрабатывать задачу, только один процесс может обновлять критичные данные, или нужно предотвратить одновременное выполнение дорогой операции.\n\n**Redis** хорошо подходит для таких блокировок, потому что операции атомарны и выполняются быстро.\n\n## Простая блокировка через SET NX\n\nБазовый способ получить блокировку — использовать команду **SET** с опцией **NX** (только если ключ не существует) и временем жизни.\n\nПример получения блокировки:\n\n```\nSET lock:task:42 \"worker-1\" NX EX 30\n```\n\nЧто происходит:\n\n- **lock:task:42** — имя ключа блокировки;\n- **worker-1** — идентификатор того, кто получил блокировку (полезно для отладки);\n- **NX** — создать ключ только если его ещё нет;\n- **EX 30** — ключ автоматически удалится через 30 секунд.\n\nЕсли команда вернула **OK**, блокировка получена. Если вернула пустой ответ, ключ уже существует — кто‑то другой держит блокировку.\n\n## Освобождение блокировки\n\nКогда работа завершена, блокировку нужно освободить. Важно удалять только свою блокировку, чтобы не снять чужую.\n\nПроверка и удаление:\n\n```\nGET lock:task:42\n```\n\nЕсли значение совпадает с идентификатором текущего процесса, можно удалить:\n\n```\nDEL lock:task:42\n```\n\nНо эта схема не атомарна: между GET и DEL другой процесс может успеть взять блокировку. Безопаснее использовать Lua‑скрипт, который проверяет и удаляет за один шаг.\n\n## Атомарное освобождение через Lua\n\nСкрипт проверяет, что значение ключа совпадает с идентификатором, и только тогда удаляет:\n\n```\nEVAL \"\n  if redis.call('GET', KEYS[1]) == ARGV[1] then\n    return redis.call('DEL', KEYS[1])\n  else\n    return 0\n  end\n\" 1 lock:task:42 worker-1\n```\n\nЗдесь:\n\n- **KEYS[1]** — имя ключа блокировки;\n- **ARGV[1]** — идентификатор процесса, который пытается освободить блокировку.\n\nЕсли идентификатор совпал, ключ удаляется и возвращается 1. Если нет — возвращается 0, блокировка не снимается.\n\n## Продление времени жизни блокировки\n\nИногда работа занимает больше времени, чем изначально заданный TTL. В таких случаях блокировку нужно продлить.\n\nПродление тоже лучше делать атомарно через Lua:\n\n```\nEVAL \"\n  if redis.call('GET', KEYS[1]) == ARGV[1] then\n    return redis.call('EXPIRE', KEYS[1], ARGV[2])\n  else\n    return 0\n  end\n\" 1 lock:task:42 worker-1 60\n```\n\nСкрипт проверяет владельца и продлевает TTL только если идентификатор совпадает.\n\n## Типичные сценарии использования\n\n**Обработка задач воркерами.** Только один воркер должен взять задачу из очереди. Блокировка гарантирует, что задача не будет обработана дважды.\n\n```\nSET lock:process:queue:email \"worker-123\" NX EX 300\n```\n\n**Обновление критичных данных.** При изменении баланса или статуса заказа важно, чтобы два процесса не делали это одновременно.\n\n```\nSET lock:order:42:update \"api-server-1\" NX EX 10\n```\n\n**Предотвращение дублирования операций.** Дорогая операция (генерация отчёта, отправка массовой рассылки) должна выполняться только один раз.\n\n```\nSET lock:report:daily \"scheduler\" NX EX 3600\n```\n\n## Выбор времени жизни блокировки\n\nTTL блокировки должен быть достаточно большим, чтобы покрыть время выполнения операции, но не слишком большим, чтобы при сбое процесса блокировка не висела часами.\n\nТипичные значения:\n\n- для быстрых операций — 5–30 секунд;\n- для обработки задач — 1–5 минут;\n- для долгих операций — 10–30 минут с возможностью продления.\n\nЕсли процесс упал и не освободил блокировку, TTL автоматически удалит ключ, и другой процесс сможет взять блокировку.\n\n## Проблемы и ограничения простой блокировки\n\nПростая блокировка на одном Redis работает хорошо, но есть нюансы:\n\n- если Redis упадёт, все блокировки потеряются;\n- при использовании репликации возможны рассинхронизации;\n- в кластере Redis нужно учитывать особенности шардирования.\n\nДля критичных систем, где важна максимальная надёжность, используют алгоритм **Redlock**, который работает с несколькими независимыми инстансами Redis. Но для большинства практических задач простая блокировка через **SET NX EX** вполне достаточна.\n\n## Итого\n\n**Распределённые блокировки в Redis** строятся вокруг команды **SET NX EX**: атомарное создание ключа с временем жизни гарантирует, что только один процесс получит блокировку.\n\nВажно правильно освобождать блокировку (лучше через Lua‑скрипт) и выбирать разумное время жизни, чтобы балансировать между защитой от зависших процессов и риском преждевременного освобождения блокировки.\n\n"}