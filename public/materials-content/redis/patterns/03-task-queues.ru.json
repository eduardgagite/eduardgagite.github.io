{"content":"\n\nОчереди задач помогают вынести тяжёлую или долгую работу из основного потока приложения. Вместо того чтобы делать всё сразу во время HTTP-запроса, задача кладётся в очередь, а отдельный рабочий процесс (worker) забирает её и выполняет в фоне.\n\n## Простой вариант на списках\n\nСамый доступный вариант очереди в Redis — обычный список. Один или несколько производителей кладут задачи в список, а воркеры их забирают.\n\nПример: очередь писем.\n\nПроизводитель кладёт задачу:\n\n```\nLPUSH queue:email \"{\\\"to\\\":\\\"user@example.com\\\",\\\"subject\\\":\\\"Hello\\\"}\"\n```\n\nВоркер забирает задачи с конца списка:\n\n```\nRPOP queue:email\n```\n\nЕсли очередь пустая, RPOP вернёт пустой результат, и воркер может подождать перед следующей попыткой.\n\nЧтобы не опрашивать Redis в цикле, используют блокирующую команду:\n\n```\nBRPOP queue:email 5\n```\n\nКоманда ждёт до 5 секунд, пока не появится новый элемент. Если за это время ничего не пришло, возвращается пустой результат, и можно повторить попытку.\n\n**Плюсы списков:** простая модель, минимум команд, легко начать.\n\n## Несколько очередей и приоритеты\n\nЧасто задач несколько типов: срочные и обычные. Для этого удобно завести несколько списков.\n\nНапример:\n\n```\nLPUSH queue:email:high \"{...}\"\nLPUSH queue:email:default \"{...}\"\n```\n\nВоркер сначала пытается забрать задачу из приоритетной очереди, потом из обычной:\n\n```\nBRPOP queue:email:high queue:email:default 5\n```\n\nRedis сам вернёт задачу из первой непустой очереди.\n\n## Очередь на Streams\n\nСписки просты, но у них есть минус: если воркер забрал задачу и упал до обработки, задача потеряется. Потоки (Streams) дают более надёжную схему.\n\nПример очереди на Streams:\n\nДобавление задачи:\n\n```\nXADD queue:email * to \"user@example.com\" subject \"Hello\"\n```\n\nСоздание группы потребителей (делается один раз):\n\n```\nXGROUP CREATE queue:email workers $ MKSTREAM\n```\n\nЧтение задач воркером из группы:\n\n```\nXREADGROUP GROUP workers worker-1 COUNT 1 STREAMS queue:email >\n```\n\nПосле успешной обработки воркер подтверждает задачу:\n\n```\nXACK queue:email workers <id-записи>\n```\n\nЕсли воркер упал и не успел отправить XACK, запись можно забрать другим воркером из «подвисших» задач через XCLAIM или XPENDING. Так задачи не теряются.\n\n## Что класть в задачу\n\nОбычно в очередь кладут не весь объём данных, а только то, что нужно для повторного поиска:\n\n**Идентификатор.** Например, **user_id**, **order_id**, **notification_id**.\n\n**Тип действия.** Что именно нужно сделать: **send_email**, **rebuild_cache**, **generate_report**.\n\n**Минимальные параметры.** Всё, что нельзя потом достать из основной базы.\n\nПример полезной структуры для задачи:\n\n```\n{\n  \"type\": \"send_email\",\n  \"user_id\": 42,\n  \"template\": \"welcome\"\n}\n```\n\nВоркер по этим данным берёт остальное из основной базы и выполняет нужную операцию.\n\n## Итого\n\n**Очереди задач на Redis** позволяют разгружать основной поток приложения и выполнять тяжёлые операции в фоне. Для простых случаев достаточно списков и команд LPUSH/BRPOP. Когда важно не терять задачи и распределять их между несколькими воркерами, удобнее использовать Streams с группами потребителей."}