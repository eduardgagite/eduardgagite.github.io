{"content":"\nКэширование — одна из самых частых причин использовать Redis. Идея простая: дорогой по времени или ресурсоёмкий результат один раз считается, сохраняется в Redis и потом быстро читается оттуда.\n\n## Простой кэш для тяжёлого запроса\n\nПредставим, что есть запрос к базе данных, который занимает сотни миллисекунд. Вместо того чтобы каждый раз ходить в БД, приложение сначала проверяет Redis.\n\nЛогика на уровне приложения выглядит так:\n\n1. Посмотреть значение в Redis по заранее известному ключу.\n2. Если значение есть — вернуть его.\n3. Если значения нет — взять данные из БД, положить в Redis и вернуть пользователю.\n\nПример работы с ключом cache:article:42:\n\n```\nGET cache:article:42\n```\n\nЕсли ответ пустой, приложение читает статью из базы и записывает результат с временем жизни:\n\n```\nSETEX cache:article:42 60 \"{...json статьи...}\"\n```\n\nКлюч живёт 60 секунд, после чего удаляется. Следующий запрос снова обратится к БД, обновит кэш и цикл продолжится.\n\n**Плюс такого подхода:** кэш не переполнен старыми данными, потому что они автоматически истекают.\n\n## Кэширование страниц и HTTP-ответов\n\nRedis удобно использовать как кэш для целых страниц или фрагментов HTML.\n\nНапример, есть страница товара **/products/10**. Приложение может сформировать HTML один раз и сохранить его в Redis:\n\n```\nSETEX cache:page:/products/10 30 \"<html>...\" \n```\n\nПри следующем запросе к странице сначала проверяется Redis:\n\n```\nGET cache:page:/products/10\n```\n\nЕсли HTML найден, сервер сразу отдаёт его пользователю, не тратя время на повторную сборку страницы.\n\n## Обновление и сброс кэша\n\nКэш всегда связан с исходными данными. Если данные поменялись, старый кэш становится бесполезным.\n\n**Простой подход:** после изменения данных удалить связанный ключ.\n\n```\nDEL cache:article:42\n```\n\nСледующий запрос создаст свежий кэш через SETEX.\n\nИногда кэш обновляют не только при чтении, но и сразу после записи в основное хранилище: как только данные изменились, новое значение кладут в Redis, чтобы не ждать первого запроса.\n\n## Что кэшировать имеет смысл\n\n**Тяжёлые запросы.** То, что долго считается или часто запрашивается.\n\n**Редко меняющиеся данные.** Справочники, популярные статьи, публичные профили.\n\n**Результаты сложных агрегатов.** Статистика, подготовленные выборки.\n\nЧем дороже получение данных без Redis, тем больше выигрывает кэш.\n\n## Чего кэшировать не стоит\n\nДанные, которые меняются каждую секунду и при этом всегда должны быть строго актуальными (например, баланс счёта в банковской системе), плохо подходят для простого кэширования. В таких случаях используют другие механизмы согласованности.\n\nКэширование в Redis не требует сложных схем: достаточно выбрать понятные ключи, задать разумный TTL и обновлять кэш при изменении исходных данных.\n"}