---
title: "Управление секретами и переменными окружения"
category: "docker"
categoryTitle: "Docker"
section: "security"
sectionTitle: "Безопасность"
sectionOrder: 9
order: 3
---

Как мы выяснили, хранить пароли в коде или Dockerfile — нельзя.
Мы используем переменные окружения (`-e DB_PASS=...`). Но есть нюанс.

## Проблема переменных окружения

Любой, кто имеет доступ к серверу и может сделать `docker inspect my-container`, увидит все ваши пароли в открытом виде в секции `Env`.
Кроме того, переменные окружения часто попадают в логи ошибок.

## Docker Secrets (для Docker Swarm / Kubernetes)

Если вы используете оркестраторы, там есть механизм **Secrets**. Секрет монтируется как файл в оперативную память (`/run/secrets/my_db_pass`). Это безопасно.

## Безопасность в обычном Docker (локально / один сервер)

Если вы просто запускаете контейнеры на VPS:
1. Используйте `.env` файл, который добавлен в `.gitignore` (чтобы не утек в репозиторий).
2. Ограничьте доступ к серверу (SSH только по ключам).
3. Ограничьте доступ к докер-сокету (чтобы никто лишний не мог сделать `docker inspect`).

## Не запекайте секреты в образ!

**Плохой Dockerfile:**
```dockerfile
ENV DB_PASSWORD=secret123  <-- ПЛОХО! Останется в истории слоев навсегда.
```

Если вам нужен секрет **во время сборки** (например, токен для скачивания приватных npm-пакетов), используйте **Docker Build Secrets** (BuildKit).

```dockerfile
# В Dockerfile
RUN --mount=type=secret,id=npmrc \
    cp /run/secrets/npmrc .npmrc && npm install
```

Запуск сборки:
```bash
docker build --secret id=npmrc,src=./.npmrc .
```
В этом случае секрет «подмонтируется» только на время выполнения команды `RUN` и не сохранится в итоговом образе.

## Итого

- Пароли в `.env` (не в Dockerfile!).
- Если собираете образ с приватными ключами — используйте `--mount=type=secret`.

