---
title: "Multi-stage сборка"
category: "docker"
categoryTitle: "Docker"
section: "images"
sectionTitle: "Dockerfile и сборка образов"
sectionOrder: 4
order: 6
---

Представьте, что вы пишете на Go, Java или TypeScript.
Вам нужны компиляторы (**go build**, **tsc**, **maven**) для сборки приложения. Но для **запуска** готового бинарника или JS-файлов эти инструменты не нужны!

Если оставить их в финальном образе, он будет весить 500 МБ вместо 20 МБ.
Решение: **Multi-stage builds** (многоэтапная сборка).

## Как это работает

Мы используем несколько инструкций **FROM** в одном Dockerfile. Каждый **FROM** начинает новый этап. Мы можем копировать файлы (артефакты) из предыдущего этапа в текущий.

## Пример (для статического сайта на Nginx)

Допустим, у нас React-приложение. Его нужно собрать (**npm run build**), а потом просто раздавать статику через Nginx. Node.js в продакшене нам не нужен. Первый этап собирает приложение, а второй берёт только готовые файлы из **/app/dist** и кладёт их в Nginx:

```
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## Преимущества

1. **Минимальный размер:** Итоговый образ содержит только то, что нужно для работы (Runtime). Все инструменты сборки (Build tools) отбрасываются.
2. **Безопасность:** В продакшен не едут исходные коды, компиляторы и dev-зависимости.
3. **Удобство:** Единый Dockerfile описывает весь процесс: и сборку, и упаковку. Не нужны внешние CI-скрипты.

## Итого

Multi-stage — это стандарт для компилируемых языков (Go, Java, C++) и фронтенда (React, Vue).
Используйте конструкцию **COPY --from=...** чтобы переносить только готовые артефакты.
