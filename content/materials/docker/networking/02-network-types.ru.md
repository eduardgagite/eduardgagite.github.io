---
title: "Docker network: bridge, host и DNS"
category: "docker"
categoryTitle: "Docker"
section: "networking"
sectionTitle: "Сети"
sectionOrder: 6
order: 2
---

Docker умеет создавать виртуальные сети, чтобы контейнеры могли общаться друг с другом.
Есть три основных типа драйверов сети.

## 1. Bridge (Мост) — По умолчанию

Когда вы просто запускаете контейнер, он попадает в стандартную сеть **bridge**.
Но лучше создавать свои пользовательские сети.

```
docker network create my-net

docker run -d --name db --network my-net mongo
docker run -d --name app --network my-net my-web-app
```

### Магия DNS
В пользовательской сети (**my-net**) работает **автоматический Service Discovery**.
Контейнеры могут обращаться друг к другу **по именам**!

Внутри контейнера **app** вы можете написать:

```
ping db
```

И Docker сам подставит правильный IP-адрес контейнера **db**. Не нужно хардкодить IP-адреса.

## 2. Host (Хост)

Режим полной открытости. Контейнер не получает свой IP, а использует сетевой стек хост-машины.

```
docker run -d --network host nginx
```

В этом режиме флаг **-p** не нужен. Если Nginx слушает порт 80, он сразу откроется на 80-м порту вашего компьютера.

**Плюсы:** Максимальная скорость сети (нет накладных расходов на NAT).
**Минусы:** Порты могут конфликтовать. Работает только на Linux (на Mac/Windows есть особенности реализации).

## 3. None (Нет сети)

Полная изоляция. У контейнера есть только loopback интерфейс (localhost). Выхода в интернет нет.

```
docker run -d --network none alpine
```

Используется для задач с повышенной безопасностью, где не нужна сеть (например, генерация ключей, обработка файлов).

## Итого

- Всегда создавайте свою сеть (**docker network create app-net**) для связки сервисов.
- Обращайтесь к сервисам по именам контейнеров (**mysql**, **redis**), а не по IP.
- Используйте **bridge** для 99% задач. **host** — только для специфичных кейсов производительности.
