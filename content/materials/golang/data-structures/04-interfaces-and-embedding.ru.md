---
title: "Интерфейсы и встраивание"
category: "golang"
categoryTitle: "Go"
section: "data-structures"
sectionTitle: "Структуры данных"
sectionOrder: 3
order: 4
---

В Go нет наследования (extends). Вообще. Создатели языка считают, что наследование создает больше проблем, чем решает (хрупкие иерархии, проблема ромба, тесная связанность).

Вместо него Go предлагает два мощных механизма:
1. **Интерфейсы** — для полиморфизма ("мне не важно что ты, важно что ты умеешь").
2. **Встраивание** — для переиспользования кода (композиция вместо наследования).

## Интерфейсы

Интерфейс — это контракт. Он описывает **набор методов**, но не реализует их.

Ключевая особенность Go: **интерфейсы реализуются неявно**. Вам не нужно писать **implements MyInterface**. Если структура имеет все методы интерфейса — она его реализует автоматически.

Это называется **утиная типизация** (Duck Typing): "Если оно ходит как утка и крякает как утка — это утка".

### Пример

Создаем интерфейс **Speaker** — "тот, кто умеет говорить".

```
type Speaker interface {
    Speak() string
}
```

Любой тип, у которого есть метод **Speak() string**, автоматически является **Speaker**.

```
type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return d.Name + " говорит: Гав!"
}

type Human struct {
    Name string
}

func (h Human) Speak() string {
    return h.Name + " говорит: Привет!"
}
```

Теперь мы можем написать функцию, которая работает с **любым** Speaker.

```
func announce(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    dog := Dog{Name: "Бобик"}
    human := Human{Name: "Алиса"}

    announce(dog)   // "Бобик говорит: Гав!"
    announce(human) // "Алиса говорит: Привет!"
}
```

### Зачем это нужно на практике?

Интерфейсы позволяют писать **гибкий и тестируемый** код.

Представьте: у вас есть сервис, который отправляет уведомления. Сегодня — по email, завтра — через Telegram, послезавтра — через SMS.

```
type Notifier interface {
    Send(message string) error
}

type EmailNotifier struct { /* ... */ }
func (e EmailNotifier) Send(message string) error { /* ... */ }

type TelegramNotifier struct { /* ... */ }
func (t TelegramNotifier) Send(message string) error { /* ... */ }

func NotifyUser(n Notifier, msg string) {
    n.Send(msg)
}
```

А в тестах вы можете подставить фейковый Notifier, который ничего не отправляет, а просто записывает сообщения.

### Маленькие интерфейсы

В Go принято делать интерфейсы **маленькими** (1-2 метода). Стандартная библиотека полна таких примеров:

- **io.Reader** — у кого есть метод **Read()**.
- **io.Writer** — у кого есть метод **Write()**.
- **fmt.Stringer** — у кого есть метод **String()**.
- **error** — у кого есть метод **Error()**.

### Пустой интерфейс (any)

Интерфейс без методов. Ему удовлетворяет **любой** тип.

```
var x any

x = 42
x = "строка"
x = true
x = User{Name: "Alice"}
```

Используется в функциях, которые принимают "что угодно" (например, **fmt.Println**). Но злоупотреблять не стоит — вы теряете проверку типов на этапе компиляции.

## Встраивание (Embedding)

Как переиспользовать код без наследования? Через встраивание одной структуры в другую.

```
type User struct {
    Name  string
    Email string
}

func (u *User) Greet() string {
    return "Привет, " + u.Name
}
```

Хотим создать Admin, который умеет всё то же, что и User, плюс имеет уровень доступа.

```
type Admin struct {
    User
    Level int
}
```

Теперь Admin "наследует" поля и методы User.

```
func main() {
    admin := Admin{
        User:  User{Name: "Иван", Email: "ivan@admin.com"},
        Level: 100,
    }

    fmt.Println(admin.Name)  // "Иван"
    fmt.Println(admin.Email) // "ivan@admin.com"

    fmt.Println(admin.Greet()) // "Привет, Иван"
}
```

### Это не наследование!

Важное отличие: Admin не является "подтипом" User. Вы **не можете** передать Admin туда, где ожидается User. Это именно **композиция** — Admin содержит User внутри себя.

Но если есть интерфейс, который User реализует, то Admin тоже его реализует (потому что у него есть те же методы).

## Итог

1. **Интерфейсы** определяют поведение. Реализуются **неявно** — просто добавьте нужные методы.
2. Делайте интерфейсы **маленькими** (1-2 метода).
3. **Встраивание** заменяет наследование через композицию.
4. **any** (пустой интерфейс) принимает что угодно, но лишает вас проверки типов.
