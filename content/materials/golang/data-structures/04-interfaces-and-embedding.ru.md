---
title: "Интерфейсы и встраивание"
category: "golang"
categoryTitle: "Go"
section: "data-structures"
sectionTitle: "Структуры данных"
sectionOrder: 3
order: 4
---

В Go нет наследования (extends). Вообще. Вместо него используются два механизма: **Интерфейсы** (для полиморфизма) и **Встраивание** (для композиции).

## Интерфейсы

Интерфейс в Go — это контракт. Он говорит: "Я не знаю, кто ты, но я знаю, что ты умеешь делать".

Если структура имеет нужные методы, она **автоматически** реализует интерфейс. Не нужно писать `implements MyInterface`. Это называется "утиная типизация" (Duck Typing).

### Пример

У нас есть интерфейс `Speaker` (ТотКтоГоворит).

```go
type Speaker interface {
    Speak() string
}
```

И две разные структуры: `Dog` и `Human`.

```go
type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}

type Human struct{}

func (h Human) Speak() string {
    return "Hello!"
}
```

Поскольку и собака, и человек имеют метод `Speak()`, они оба — `Speaker`.

```go
func saySomething(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    dog := Dog{}
    human := Human{}

    saySomething(dog)   // Выведет: Woof!
    saySomething(human) // Выведет: Hello!
}
```

### Пустой интерфейс (interface{} или any)

Есть интерфейс, у которого нет методов. Ему удовлетворяет **любой** тип данных (число, строка, структура).

```go
var x interface{} // или var x any (начиная с Go 1.18)

x = 5
x = "string"
x = true
```

Это используется в функциях, которые принимают всё подряд (например, `fmt.Println`). Но злоупотреблять этим не стоит — вы теряете проверку типов.

## Встраивание (Embedding)

Поскольку наследования нет, как нам переиспользовать код? Через встраивание одной структуры в другую.

Допустим, у нас есть `User`.

```go
type User struct {
    Name string
}

func (u *User) SayHello() {
    fmt.Println("Hi, I am", u.Name)
}
```

И мы хотим сделать `Admin`, который умеет всё то же самое, плюс что-то своё.

```go
type Admin struct {
    User  // Встраиваем структуру User (без имени поля!)
    Level int
}
```

Теперь `Admin` "наследует" поля и методы `User`.

```go
func main() {
    admin := Admin{
        User:  User{Name: "Adminovich"},
        Level: 100,
    }

    // Мы можем обращаться к полям User напрямую
    fmt.Println(admin.Name) 
    
    // И вызывать методы User
    admin.SayHello() // "Hi, I am Adminovich"
}
```

Это похоже на наследование, но технически это **композиция**. `Admin` не является подтипом `User`. Он просто содержит его внутри и умеет проксировать вызовы.

## Итог

1. **Интерфейсы** определяют поведение (методы). Реализуются неявно (просто добавьте нужные методы структуре).
2. **Встраивание** заменяет наследование. Вы включаете одну структуру в другую, чтобы использовать её поля и методы.
3. Используйте интерфейсы, чтобы писать гибкие функции, которые работают с разными типами данных.
