---
title: "Массивы и срезы"
category: "golang"
categoryTitle: "Go"
section: "data-structures"
sectionTitle: "Структуры данных"
sectionOrder: 3
order: 1
---

В Go есть два типа для хранения списков данных: **Массивы** (Array) и **Срезы** (Slice).

Новички часто их путают. Запомните главное правило: **в 99% случаев вы будете использовать срезы (slices)**. Массивы в Go — это низкоуровневая деталь, о которой нужно знать, но использовать её напрямую приходится редко.

## Массив (Array)

Массив — это коробка с фиксированным размером. Если вы создали массив на 5 элементов, он всегда будет хранить ровно 5 элементов. Ни больше, ни меньше.

```go
// Массив из 5 целых чисел. 
// Размер [5] — это часть типа! 
// [5]int и [10]int — это два разных типа данных.
var arr [5]int

arr[0] = 100
fmt.Println(arr) // [100 0 0 0 0]
```

Почему это неудобно?
1. Нельзя добавить элемент (коробка не растягивается).
2. При передаче в функцию массив полностью копируется (это медленно).

## Срез (Slice)

Срез (слайс) — это гибкая "обертка" над массивом. Он умеет расти, уменьшаться и вести себя как динамический список (как `ArrayList` в Java или `list` в Python).

### Создание среза

Обратите внимание: в квадратных скобках пусто. Это отличает срез от массива.

```go
// 1. Через литерал (сразу с данными)
users := []string{"Admin", "User", "Guest"}

// 2. Через функцию make (пустой срез нужной длины)
// make([]тип, длина)
numbers := make([]int, 5) // Создаст [0 0 0 0 0]
```

### Добавление элементов (append)

Поскольку срез резиновый, мы можем добавлять в него данные.

```go
var tasks []string

// append возвращает НОВЫЙ срез, поэтому обязательно присваиваем результат
tasks = append(tasks, "Купить хлеб")
tasks = append(tasks, "Помыть кота", "Выучить Go")

fmt.Println(tasks) 
// Вывод: [Купить хлеб Помыть кота Выучить Go]
```

**Важно**: Функция `append` умная. Если в скрытом массиве под срезом кончилось место, `append` создаст новый массив побольше, скопирует туда данные и вернет обновленный срез. Вам не нужно думать о памяти.

### Взятие части среза (Slicing)

Вы можете "отрезать" кусок от среза. Синтаксис: `slice[low : high]`.
- `low`: индекс начала (включительно).
- `high`: индекс конца (**не** включительно).

```go
alphabet := []string{"a", "b", "c", "d", "e"}

// Берем с 1-го по 3-й (не включая 3-й)
part := alphabet[1:3] 
fmt.Println(part) // ["b", "c"]

// Если пропустить low, начнется с 0
firstTwo := alphabet[:2] // ["a", "b"]

// Если пропустить high, пойдет до конца
fromC := alphabet[2:] // ["c", "d", "e"]
```

## Как это устроено внутри? (Важно!)

Срез — это не сами данные. Это маленькая структура, которая содержит:
1. Указатель на массив, где реально лежат данные.
2. Длину (`len`): сколько элементов мы видим.
3. Ёмкость (`cap`): сколько места есть в массиве про запас.

Это значит, что срезы — **очень легкие**. Передать срез в функцию — это дешево (копируются только эти 3 числа), а не весь массив данных.

### Ловушка: Общая память

Когда вы делаете подсрез `b := a[1:3]`, новый срез `b` **смотрит на тот же массив**, что и `a`.

```go
original := []int{10, 20, 30}
sub := original[0:1] // [10]

sub[0] = 999

// В оригинале тоже изменится!
fmt.Println(original) // [999 20 30]
```

Если вам нужен независимый кусок, используйте функцию `copy`.

## Итог

1. **Массив** `[5]int`: Размер фиксирован. Используется редко.
2. **Срез** `[]int`: Размер меняется. Используется везде.
3. Добавляем элементы через `slice = append(slice, val)`.
4. Срез — это просто "окно" на массив. Изменяя срез, вы можете изменить данные в других срезах, смотрящих туда же.
