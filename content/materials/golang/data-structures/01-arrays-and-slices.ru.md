---
title: "Массивы и срезы"
category: "golang"
categoryTitle: "Go"
section: "data-structures"
sectionTitle: "Структуры данных"
sectionOrder: 3
order: 1
---

Когда нам нужно хранить список данных (имена пользователей, цены товаров, результаты запросов), мы используем коллекции. В Go для этого есть два типа: **массивы** (Array) и **срезы** (Slice).

Главное правило: **в 99% случаев вы будете использовать срезы**. Массивы — это низкоуровневая деталь, на которой срезы построены.

## Массив (Array)

Массив — это коробка фиксированного размера. Вы сразу говорите: "Мне нужно место ровно для 5 элементов". Ни больше, ни меньше.

```
var arr [5]int

arr[0] = 100
arr[1] = 200
fmt.Println(arr) // [100 200 0 0 0]
```

### Почему массивы неудобны

1. **Размер зашит в тип**. **[5]int** и **[10]int** — это **разные** типы данных. Вы не можете передать **[5]int** туда, где ожидается **[10]int**.
2. **Нельзя добавить элемент**. Коробка не растягивается. Если вам нужен 6-й элемент — создавайте новый массив побольше и копируйте данные.
3. **Копирование**. Когда вы передаете массив в функцию, он **полностью копируется**. Для массива из миллиона элементов это медленно и расточительно.

## Срез (Slice)

Срез — это "умная обертка" над массивом. Он умеет расти, уменьшаться и работает как динамический список (аналог **ArrayList** в Java, **list** в Python, **Array** в JS).

### Создание среза

Обратите внимание: в квадратных скобках **пусто** **[]**. Это отличает срез от массива **[5]**.

```
users := []string{"Alice", "Bob", "Charlie"}

numbers := make([]int, 5) // [0 0 0 0 0]

buffer := make([]int, 0, 100)
```

Зачем третий вариант? Если вы знаете примерный размер данных, можно сразу выделить память. Это ускоряет работу, потому что Go не будет пересоздавать массив при каждом **append**.

### Добавление элементов (append)

```
var tasks []string

tasks = append(tasks, "Купить хлеб")
tasks = append(tasks, "Помыть кота", "Выучить Go")

fmt.Println(tasks) // [Купить хлеб Помыть кота Выучить Go]
fmt.Println(len(tasks)) // 3
fmt.Println(cap(tasks)) // 4
```

**Важно**: **append** возвращает **новый** срез. Всегда присваивайте результат: **tasks = append(tasks, ...)**. Если забудете **tasks =**, элемент потеряется.

### Перебор (range)

```
names := []string{"Alice", "Bob", "Charlie"}

for i, name := range names {
    fmt.Printf("%d: %s\n", i, name)
}
// 0: Alice
// 1: Bob
// 2: Charlie

for _, name := range names {
    fmt.Println(name)
}
```

### Взятие части среза (Slicing)

Вы можете "вырезать" кусок. Синтаксис: **slice[start:end]**.
- **start** — начало (включительно).
- **end** — конец (**не** включительно).

```
alphabet := []string{"a", "b", "c", "d", "e"}

part := alphabet[1:3]  // ["b", "c"]
first := alphabet[:2]  // ["a", "b"]
last := alphabet[2:]   // ["c", "d", "e"]
```

### Удаление элемента

В Go нет встроенной функции "удалить элемент из среза". Это делается через append и slicing.

```
s := []string{"a", "b", "c", "d"}

s = append(s[:2], s[3:]...)
fmt.Println(s) // ["a", "b", "d"]
```

## Как устроен срез внутри

Срез — это не сами данные. Это маленькая структура из трёх полей:
1. **Указатель** на скрытый массив, где лежат данные.
2. **Длина** (**len**): сколько элементов мы используем.
3. **Ёмкость** (**cap**): сколько места в скрытом массиве.

Когда вы вызываете **append**, а места в скрытом массиве нет, Go:
1. Создает новый массив в 2 раза больше.
2. Копирует старые данные туда.
3. Возвращает срез, указывающий на новый массив.

### Ловушка: Общая память

Когда вы делаете подсрез **b := a[1:3]**, новый срез **b** **смотрит на тот же массив**, что и **a**.

```
original := []int{10, 20, 30}
sub := original[0:2] // [10, 20]

sub[0] = 999

fmt.Println(original) // [999 20 30]
```

Если нужна независимая копия:

```
original := []int{10, 20, 30}
clone := make([]int, len(original))
copy(clone, original)
```

## Итог

1. **Массив** **[5]int**: Размер фиксирован. На практике используется редко.
2. **Срез** **[]int**: Динамический размер. Используется повсеместно.
3. Добавляем через **slice = append(slice, val)**.
4. Помните про общую память при создании подсрезов.
5. Используйте **make([]T, 0, capacity)**, если знаете примерный размер.
