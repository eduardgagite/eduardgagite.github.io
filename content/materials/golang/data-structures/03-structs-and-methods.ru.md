---
title: "Структуры и методы"
category: "golang"
categoryTitle: "Go"
section: "data-structures"
sectionTitle: "Структуры данных"
sectionOrder: 3
order: 3
---

В Go нет классов (как в Java, Python или C#). Вместо них используются **структуры** (structs) — пользовательский тип данных, объединяющий несколько полей.

Если переменная — это "одна ячейка" (число, строка), то структура — это "карточка" с несколькими полями. Например, карточка пользователя с именем, возрастом и email.

## Объявление структуры

```go
type User struct {
    Name  string
    Age   int
    Email string
}
```

`type` — создаем новый тип. `User` — его имя. `struct` — это структура с полями внутри.

## Создание экземпляра

Есть несколько способов.

### 1. По именам полей (рекомендуется)

```go
u := User{
    Name:  "Alice",
    Age:   30,
    Email: "alice@example.com",
}
```

Этот способ самый надежный: если вы добавите новое поле в структуру, код не сломается.

### 2. Частичное заполнение

```go
u := User{Name: "Bob"}
// Age будет 0, Email будет "" (нулевые значения)
```

### 3. Пустая структура

```go
var u User
// Все поля — нулевые значения
fmt.Println(u.Name) // ""
fmt.Println(u.Age)  // 0
```

## Доступ к полям

Через точку. Просто и понятно.

```go
fmt.Println(u.Name) // Чтение
u.Age = 31          // Запись
```

## Методы

Структура — это просто данные. Чтобы добавить **поведение** (функции, которые работают с этими данными), используются методы.

Метод — это обычная функция, но с дополнительным параметром перед именем: **receiver** (получатель). Он привязывает функцию к конкретному типу.

```go
func (u User) Greet() string {
    return fmt.Sprintf("Привет, я %s, мне %d лет", u.Name, u.Age)
}

func main() {
    alice := User{Name: "Alice", Age: 30}
    fmt.Println(alice.Greet()) // "Привет, я Alice, мне 30 лет"
}
```

## Value Receiver vs Pointer Receiver

Это **критически важный** момент. Когда вы пишете метод, у вас есть выбор: работать с копией данных или с оригиналом.

### Value Receiver (Копия)

Получатель `(u User)` получает **копию** структуры. Любые изменения внутри метода **не затронут** оригинал.

```go
func (u User) SetAge(newAge int) {
    u.Age = newAge // Меняем КОПИЮ
}

func main() {
    bob := User{Name: "Bob", Age: 25}
    bob.SetAge(100)
    fmt.Println(bob.Age) // 25 — ничего не изменилось!
}
```

Используйте Value Receiver, когда метод **только читает** данные и структура маленькая.

### Pointer Receiver (Указатель на оригинал)

Получатель `(u *User)` — со звездочкой — получает **указатель** на оригинальную структуру. Изменения **сохранятся**.

```go
func (u *User) SetAge(newAge int) {
    u.Age = newAge // Меняем оригинал!
}

func main() {
    bob := User{Name: "Bob", Age: 25}
    bob.SetAge(100)
    fmt.Println(bob.Age) // 100 — теперь всё работает
}
```

### Когда что использовать?

**Правило**: Если сомневаетесь — используйте Pointer Receiver `*User`. Вот почему:
1. Он позволяет менять данные.
2. Он быстрее для больших структур (не нужно копировать все поля).
3. **Консистентность**: Если хотя бы один метод использует `*User`, делайте все методы с `*User`.

## Конструкторы

В Go нет встроенных конструкторов. Вместо них пишут обычные функции с префиксом `New`.

```go
func NewUser(name, email string) *User {
    return &User{
        Name:  name,
        Email: email,
        Age:   18, // Дефолтное значение
    }
}

func main() {
    user := NewUser("John", "john@mail.com")
    fmt.Println(user.Name) // John
    fmt.Println(user.Age)  // 18
}
```

Конструктор возвращает `*User` (указатель), чтобы:
1. Не копировать структуру при возврате.
2. Методы с Pointer Receiver работали сразу.

## Итог

1. **Структура** — это набор полей (данные).
2. **Методы** — функции, привязанные к структуре (поведение).
3. Если метод меняет данные — используйте **Pointer Receiver** `(u *User)`.
4. Конструктор — это обычная функция `NewТип()`.
