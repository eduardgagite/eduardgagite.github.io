---
title: "Sync примитивы"
category: "golang"
categoryTitle: "Go"
section: "concurrency"
sectionTitle: "Конкурентность"
sectionOrder: 6
order: 3
---

Каналы — это здорово, но это не единственный способ писать параллельный код. Иногда нам нужно просто защитить переменную от одновременной записи или подождать группу задач.

Для этого в Go есть пакет `sync`. Это классические инструменты, которые вы могли видеть в Java или C++.

## Проблема: Состояние гонки (Race Condition)

Представьте счетчик лайков.

```go
count := 0
for i := 0; i < 1000; i++ {
    go func() {
        count++ // ОПАСНО!
    }()
}
```

Если запустить этот код, `count` никогда не будет 1000. Он будет 950, 998 или 800.
Почему? Потому что операция `count++` на самом деле состоит из трёх шагов:
1. Прочитать `count` (например, 5).
2. Прибавить 1 (получилось 6).
3. Записать 6 обратно.

Две горутины могут прочитать "5" одновременно, обе прибавят 1, и обе запишут "6". Одно увеличение потерялось.

## Решение 1: Mutex (Мьютекс)

`sync.Mutex` — это замок. Он гарантирует, что кусок кода выполняется **только одной** горутиной в один момент времени.

```go
import "sync"

type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Inc() {
    c.mu.Lock()   // <-- Закрываем дверь. Другие ждут здесь.
    c.count++     // <-- Безопасно меняем
    c.mu.Unlock() // <-- Открываем дверь. Следующий!
}
```

**Золотое правило**: Всегда используйте `defer`, чтобы разблокировать мьютекс, даже если случится паника.

```go
func (c *SafeCounter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock() // Гарантированно выполнится в конце
    
    c.count++
}
```

### RWMutex (Read-Write)

Если у вас данные часто читают (1000 раз/сек), но редко пишут (1 раз/час), обычный `Mutex` будет всех тормозить.
`sync.RWMutex` позволяет:
- **Многим** читать одновременно (`RLock`).
- Но только **одному** писать (`Lock`), выгоняя всех читателей.

## Решение 2: WaitGroup (Группа ожидания)

Как подождать завершения 10 горутин? `time.Sleep` — это плохой способ. Правильный способ — `sync.WaitGroup`.

Это как счетчик задач:
1. `Add(1)` — добавили задачу.
2. `Done()` — задача выполнена (вычитает 1).
3. `Wait()` — стоим и ждем, пока счетчик не станет 0.

```go
func main() {
    var wg sync.WaitGroup

    for i := 1; i <= 5; i++ {
        wg.Add(1) // +1 задача
        
        go func(id int) {
            defer wg.Done() // -1 задача (в конце)
            fmt.Printf("Воркер %d работает...\n", id)
        }(i)
    }

    wg.Wait() // Ждем, пока все закончат
    fmt.Println("Все готово")
}
```

## Решение 3: Once (Единожды)

Иногда нужно сделать что-то ровно один раз. Например, подключиться к базе данных при первом запросе (Lazy Initialization).

Даже если 100 горутин вызовут `once.Do` одновременно, функция внутри выполнится только один раз.

```go
var once sync.Once
var db *Database

func GetDB() *Database {
    once.Do(func() {
        fmt.Println("Подключаюсь к БД... (только 1 раз)")
        db = connect()
    })
    return db
}
```

## Итог

1. Если данные меняют из разных горутин — нужен `Mutex`.
2. Если нужно дождаться окончания пачки горутин — `WaitGroup`.
3. Если нужно инициализировать что-то лениво и безопасно — `Once`.
4. Используйте `go run -race main.go`, чтобы Go сам проверил ваш код на наличие гонок!
