---
title: "Атомарные операции и race detector"
category: "golang"
categoryTitle: "Go"
section: "concurrency"
sectionTitle: "Конкурентность"
sectionOrder: 6
order: 6
---

Когда несколько горутин работают с одной переменной одновременно, возникают **гонки данных** (data races). Это одна из самых сложных для отладки ошибок — программа может вести себя неправильно лишь иногда, в зависимости от порядка выполнения горутин.

## Что такое гонка данных

Гонка происходит, когда две горутины одновременно обращаются к одной области памяти, и хотя бы одна из них пишет.

```
var counter int

func increment() {
    counter++ // НЕ атомарная операция!
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Println(counter) // Результат непредсказуем: 987, 1000, 956...
}
```

Операция **counter++** на самом деле состоит из трёх шагов: прочитать → увеличить → записать. Если две горутины выполняют их одновременно, одно из приращений теряется.

## Race detector — встроенный детектор гонок

Go поставляется с детектором гонок. Просто добавьте флаг **-race** при запуске или тестировании:

```
go run -race main.go
go test -race ./...
```

При обнаружении гонки вы увидите подробный отчёт: какие горутины и в каком файле обратились к одной памяти одновременно.

Детектор работает в режиме инструментации — он отслеживает все обращения к памяти во время выполнения. Это увеличивает потребление памяти и замедляет программу примерно в 2-20 раз, поэтому в production его не используют, но в тестах — обязательно.

**Правило хорошего тона**: всегда запускайте тесты с **-race** в CI.

## sync/atomic — атомарные операции

Пакет **sync/atomic** предоставляет операции, которые выполняются атомарно — без возможности прерывания другой горутиной.

```
import "sync/atomic"

var counter int64

func increment() {
    atomic.AddInt64(&counter, 1)
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Println(counter) // Всегда 1000
}
```

Основные операции **sync/atomic**:
- **atomic.AddInt64(&x, 1)** — прибавить 1 атомарно
- **atomic.LoadInt64(&x)** — прочитать атомарно
- **atomic.StoreInt64(&x, 42)** — записать атомарно
- **atomic.CompareAndSwapInt64(&x, old, new)** — заменить, если значение равно **old**
- **atomic.SwapInt64(&x, 42)** — заменить и вернуть старое значение

## atomic.Value — атомарное хранение любых значений

Если нужно атомарно менять значения произвольного типа (не только числа), используйте **atomic.Value**:

```
var config atomic.Value

func updateConfig(newCfg *Config) {
    config.Store(newCfg)
}

func getConfig() *Config {
    return config.Load().(*Config)
}
```

Это классический паттерн для hot-reload конфигурации: один поток обновляет конфиг, множество горутин читают без блокировок.

## Когда atomic, а когда Mutex

**sync/atomic** подходит, когда:
- Вы работаете с одним числовым значением (счётчик, флаг).
- Нужна максимальная производительность.
- Операция — одиночное чтение или запись.

**sync.Mutex** (или **sync.RWMutex**) нужен, когда:
- Нужно атомарно изменить несколько переменных одновременно.
- Логика обновления сложная (не просто add/store).
- Работаете со структурами или коллекциями.

```
// atomic — для простого счётчика
var hits int64
atomic.AddInt64(&hits, 1)

// Mutex — для обновления нескольких полей структуры
type Stats struct {
    mu       sync.Mutex
    requests int
    errors   int
}

func (s *Stats) Record(isError bool) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.requests++
    if isError {
        s.errors++
    }
}
```

## Итого

Гонки данных — источник хаотичных, труднопроизводимых багов. **Всегда запускайте тесты с флагом -race** — детектор найдёт проблемы до production. Для простых счётчиков и флагов используйте **sync/atomic**: это быстрее мьютекса и явно выражает намерение. Для сложных инвариантов, затрагивающих несколько полей, **sync.Mutex** безопаснее и понятнее.
