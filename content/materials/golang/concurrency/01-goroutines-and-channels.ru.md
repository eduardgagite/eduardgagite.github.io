---
title: "Горутины и каналы"
category: "golang"
categoryTitle: "Go"
section: "concurrency"
sectionTitle: "Конкурентность"
sectionOrder: 6
order: 1
---

Конкурентность (Concurrency) — это способность программы справляться с множеством задач одновременно. Не обязательно выполнять их в один момент времени (это параллелизм), но быть готовой переключаться между ними.

Go прославился именно своей моделью конкурентности, которая встроена в язык, а не добавлена библиотеками.

## Проблема потоков в других языках

В классических языках (Java, C++, Python) каждый поток (Thread) — это тяжелый ресурс операционной системы.
1. Он занимает много памяти (обычно 1-2 МБ на стек).
2. Его создание и переключение занимает время (Context Switch).
3. Если вы запустите 100 000 потоков, ваш сервер "умрет" от нехватки памяти.

## Решение Go: Горутины (Goroutines)

Горутина — это **легковесный поток**, управляемый самим Go Runtime, а не операционной системой.

- **Память**: Занимает всего ~2 КБ при старте (растягивается при необходимости).
- **Цена**: Переключение между ними почти мгновенное.
- **Масштаб**: Можно запустить **миллионы** горутин на обычном ноутбуке.

### Как запустить горутину

Достаточно добавить слово **go** перед вызовом любой функции.

```
func worker(id int) {
    fmt.Printf("Воркер %d начал работу\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Воркер %d закончил\n", id)
}

func main() {
    go worker(1)
    go worker(2)
    go worker(3)

    time.Sleep(2 * time.Second)
    fmt.Println("Программа завершена")
}
```

В консоли вы увидите, что воркеры начали работу почти одновременно, а не по очереди.

---

## Каналы (Channels)

Когда у вас много горутин, возникает проблема: как им обмениваться данными и не мешать друг другу?

В других языках используют общую память (Shared Memory) и замки (Mutex), чтобы две функции не писали в одну переменную одновременно. Это сложно, опасно (Deadlocks) и чревато ошибками.

Философия Go:
> **"Не общайтесь через общую память; используйте каналы, чтобы пересылать память"**.

Канал — это "труба", соединяющая горутины. Одна кладет данные с одного конца, другая забирает с другого.

### Синтаксис

Каналы строго типизированы.
- **make(chan int)** — создать канал для чисел.
- **ch <- 5** — отправить (записать) данные в канал.
- **val := <-ch** — получить (прочитать) данные из канала.

### Блокировка (Ключевой момент!)

Каналы по умолчанию **небуферизированные**. Это значит, что они обеспечивают **синхронизацию**:

1. **Отправка блокирует**: Если вы пишете **ch <- 5**, горутина остановится и будет ждать, пока кто-нибудь не начнет читать из этого канала.
2. **Чтение блокирует**: Если вы пишете **val := <-ch**, горутина остановится и будет ждать, пока кто-нибудь что-то туда положит.

Это как передача эстафетной палочки: бегун не может отдать палочку, если её никто не берет, и не может бежать дальше, пока не отдаст.

```
func main() {
    messages := make(chan string)

    go func() {
        fmt.Println("Горутина: Готовлю сообщение...")
        time.Sleep(2 * time.Second)
        messages <- "Привет, мир!"
        fmt.Println("Горутина: Сообщение отправлено")
    }()

    fmt.Println("Main: Жду сообщения...")
    msg := <-messages
    fmt.Println("Main: Получил:", msg)
}
```

### Буферизированные каналы

Иногда нам не нужна жесткая синхронизация. Мы хотим положить письмо в почтовый ящик и уйти, даже если почтальон его еще не забрал.

Для этого создают канал с **емкостью** (buffer).

```
ch := make(chan string, 2)

ch <- "сообщение 1"
ch <- "сообщение 2"

fmt.Println(<-ch) // "сообщение 1"
```

### Закрытие канала

Отправитель может закрыть канал, чтобы сказать: "Всё, данных больше не будет".

```
close(ch)
```

Получатель может проверить это:

```
msg, ok := <-ch
if !ok {
    fmt.Println("Канал закрыт и пуст")
}
```

Или читать в цикле **range** (самый удобный способ):

```
for msg := range ch {
    fmt.Println(msg)
}
```

## Итог

1. **Горутины** — дешевый способ делать дела параллельно.
2. **Каналы** — способ безопасного общения между горутинами.
3. По умолчанию каналы блокируют выполнение (ждут партнера).
4. Используйте **range** для чтения из канала, пока он не закроется.
