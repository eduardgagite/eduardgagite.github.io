---
title: "Горутины и каналы"
category: "golang"
categoryTitle: "Go"
section: "concurrency"
sectionTitle: "Конкурентность"
sectionOrder: 6
order: 1
---

Конкурентность (Concurrency) — это способность программы справляться с множеством задач одновременно. Не обязательно выполнять их в один момент времени (это параллелизм), но быть готовой переключаться между ними.

Go прославился именно своей моделью конкурентности, которая встроена в язык, а не добавлена библиотеками.

## Проблема потоков в других языках

В классических языках (Java, C++, Python) каждый поток (Thread) — это тяжелый ресурс операционной системы.
1. Он занимает много памяти (обычно 1-2 МБ на стек).
2. Его создание и переключение занимает время (Context Switch).
3. Если вы запустите 100 000 потоков, ваш сервер "умрет" от нехватки памяти.

## Решение Go: Горутины (Goroutines)

Горутина — это **легковесный поток**, управляемый самим Go Runtime, а не операционной системой.

- **Память**: Занимает всего ~2 КБ при старте (растягивается при необходимости).
- **Цена**: Переключение между ними почти мгновенное.
- **Масштаб**: Можно запустить **миллионы** горутин на обычном ноутбуке.

### Как запустить горутину

Достаточно добавить слово `go` перед вызовом любой функции.

```go
func worker(id int) {
    fmt.Printf("Воркер %d начал работу\n", id)
    time.Sleep(time.Second) // Симуляция работы
    fmt.Printf("Воркер %d закончил\n", id)
}

func main() {
    // Запускаем 3 задачи параллельно
    go worker(1)
    go worker(2)
    go worker(3)

    // ВАЖНО: Если main завершится, все горутины будут убиты!
    // Нам нужно подождать их. Пока используем "грязный хак" со сном.
    time.Sleep(2 * time.Second)
    fmt.Println("Программа завершена")
}
```

В консоли вы увидите, что воркеры начали работу почти одновременно, а не по очереди.

---

## Каналы (Channels)

Когда у вас много горутин, возникает проблема: как им обмениваться данными и не мешать друг другу?

В других языках используют общую память (Shared Memory) и замки (Mutex), чтобы две функции не писали в одну переменную одновременно. Это сложно, опасно (Deadlocks) и чревато ошибками.

Философия Go:
> **"Не общайтесь через общую память; используйте каналы, чтобы пересылать память"**.

Канал — это "труба", соединяющая горутины. Одна кладет данные с одного конца, другая забирает с другого.

### Синтаксис

Каналы строго типизированы.
- `make(chan int)` — создать канал для чисел.
- `ch <- 5` — отправить (записать) данные в канал.
- `val := <-ch` — получить (прочитать) данные из канала.

### Блокировка (Ключевой момент!)

Каналы по умолчанию **небуферизированные**. Это значит, что они обеспечивают **синхронизацию**:

1. **Отправка блокирует**: Если вы пишете `ch <- 5`, горутина остановится и будет ждать, пока кто-нибудь не начнет читать из этого канала.
2. **Чтение блокирует**: Если вы пишете `val := <-ch`, горутина остановится и будет ждать, пока кто-нибудь что-то туда положит.

Это как передача эстафетной палочки: бегун не может отдать палочку, если её никто не берет, и не может бежать дальше, пока не отдаст.

```go
func main() {
    messages := make(chan string)

    go func() {
        fmt.Println("Горутина: Готовлю сообщение...")
        time.Sleep(2 * time.Second)
        messages <- "Привет, мир!" // Блокируемся, пока main не прочитает
        fmt.Println("Горутина: Сообщение отправлено")
    }()

    fmt.Println("Main: Жду сообщения...")
    msg := <-messages // Блокируемся и ждем 2 секунды
    fmt.Println("Main: Получил:", msg)
}
```

### Буферизированные каналы

Иногда нам не нужна жесткая синхронизация. Мы хотим положить письмо в почтовый ящик и уйти, даже если почтальон его еще не забрал.

Для этого создают канал с **емкостью** (buffer).

```go
// Канал с буфером на 2 сообщения
ch := make(chan string, 2)

ch <- "сообщение 1" // Ок, сразу идем дальше
ch <- "сообщение 2" // Ок, сразу идем дальше

// ch <- "сообщение 3" // СТОП! Буфер полон. Тут мы заблокируемся.

fmt.Println(<-ch) // "сообщение 1"
// Теперь в буфере освободилось одно место
```

### Закрытие канала

Отправитель может закрыть канал, чтобы сказать: "Всё, данных больше не будет".

```go
close(ch)
```

Получатель может проверить это:

```go
msg, ok := <-ch
if !ok {
    fmt.Println("Канал закрыт и пуст")
}
```

Или читать в цикле `range` (самый удобный способ):

```go
for msg := range ch {
    fmt.Println(msg)
}
// Цикл закончится сам, когда канал закроют
```

## Итог

1. **Горутины** — дешевый способ делать дела параллельно.
2. **Каналы** — способ безопасного общения между горутинами.
3. По умолчанию каналы блокируют выполнение (ждут партнера).
4. Используйте `range` для чтения из канала, пока он не закроется.
