---
title: "Select и таймауты"
category: "golang"
categoryTitle: "Go"
section: "concurrency"
sectionTitle: "Конкурентность"
sectionOrder: 6
order: 2
---

В реальных системах мы часто ждем ответа сразу от нескольких источников.
- Пример: Мы делаем запрос в быстрый кэш и в медленную базу данных. Кто ответит первым, того и берем.
- Пример: Мы ждем ответа от сервера, но не хотим ждать дольше 5 секунд.

Для таких ситуаций в Go есть оператор **select**. Он позволяет горутине ждать на нескольких каналах одновременно.

## Как работает select

**select** синтаксически похож на **switch**, но вместо условий в **case** стоят операции с каналами (чтение или запись).

```
select {
case msg1 := <-ch1:
    fmt.Println("Пришло от ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("Пришло от ch2:", msg2)
}
```

**Логика работы**:
1. **select** смотрит на все **case** сразу.
2. Если **никто не готов** (каналы пусты), он **блокируется** и ждет.
3. Если **один готов**, он выполняет этот **case** и выходит.
4. Если **готовы несколько** (пришли сообщения одновременно), он выбирает один из них **случайно**.

## Паттерн: Таймаут (Timeout)

Это самый частый случай использования **select**. Мы хотим получить данные, но если это занимает слишком много времени — отменить операцию.

Для этого используем функцию **time.After(duration)**. Она возвращает канал, в который "прилетит" текущее время через заданный промежуток.

```
func main() {
    ch := make(chan string)

    go func() {
        time.Sleep(5 * time.Second)
        ch <- "Результат"
    }()

    select {
    case res := <-ch:
        fmt.Println("Успех:", res)
    case <-time.After(2 * time.Second):
        fmt.Println("Таймаут! Слишком долго.")
    }
}
```

В этом примере через 2 секунды канал от **time.After** станет готов первым. **select** выберет его ветку, напечатает "Таймаут" и завершится. Программа не зависнет на 5 секунд.

## Паттерн: Неблокирующее чтение (Non-blocking read)

Иногда нам нужно проверить: "Есть ли что-то в канале прямо сейчас?". Если нет — мы не хотим ждать, хотим делать другие дела.

Для этого добавляют секцию **default**.

```
select {
case msg := <-ch:
    fmt.Println("Получено:", msg)
default:
    fmt.Println("В канале пусто, иду работать дальше")
}
```

## Паттерн: Завершение (Quit channel)

Как аккуратно остановить горутину, которая крутится в бесконечном цикле? Послать ей сигнал в специальный канал **done** или **quit**.

```
func worker(done chan bool) {
    for {
        select {
        case <-done:
            fmt.Println("Получен сигнал стоп. Выхожу.")
            return
        default:
            fmt.Println("Работаю...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    done := make(chan bool)
    go worker(done)

    time.Sleep(2 * time.Second)
    done <- true
    time.Sleep(100 * time.Millisecond)
}
```

## Итог

1. **select** — это диспетчер каналов. Он ждет, кто первый ответит.
2. Используйте **time.After** внутри **select**, чтобы не зависать навечно.
3. Используйте **default**, чтобы не блокироваться, если данных нет.
