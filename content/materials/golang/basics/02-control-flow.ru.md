---
title: "Условия и циклы"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 2
---

В программировании мы постоянно управляем потоком выполнения: «если произошло X, сделай Y, иначе сделай Z» или «повтори это действие 10 раз». В Go для этого используется минимальный набор инструментов, но они очень мощные.

## Условный оператор if

Конструкция `if` (если) проверяет какое-то условие. Если оно истинно (true), выполняется блок кода внутри фигурных скобок.

### Базовый синтаксис

В отличие от многих языков (C, Java, Python), в Go **не нужны круглые скобки** вокруг условия. Это делает код чище. Но фигурные скобки `{ }` обязательны, даже если внутри всего одна строка.

```go
package main

import "fmt"

func main() {
    x := 10

    // Читаем как: "Если x больше 5, то выполнить код в скобках"
    if x > 5 {
        fmt.Println("Число больше 5")
    }
}
```

### Ветка else (иначе)

Мы можем добавить блок `else`, который выполнится, если условие в `if` оказалось ложным.

```go
age := 16

if age >= 18 {
    fmt.Println("Доступ разрешён")
} else {
    // Выполнится, если age < 18
    fmt.Println("Слишком рано")
}
```

### Множественные условия (else if)

Если нужно проверить несколько вариантов, используйте `else if`.

```go
score := 85

if score >= 90 {
    fmt.Println("Отлично")
} else if score >= 75 {
    fmt.Println("Хорошо") // Сработает эта ветка
} else {
    fmt.Println("Можно лучше")
}
```

### If с инициализацией (продвинутая фишка)

В Go можно выполнить короткое действие прямо перед проверкой условия. Это часто используют, чтобы получить значение и сразу его проверить. Переменная, созданная таким образом, **живет только внутри блока if/else**.

**Зачем это нужно?** Чтобы не засорять основной код временными переменными.

```go
data := map[string]string{"name": "Alice"}

// 1. Создаем переменную val и получаем значение по ключу "name"
// 2. Сразу проверяем ok (нашелся ли ключ)
if val, ok := data["name"]; ok {
    fmt.Println("Имя найдено:", val)
} else {
    fmt.Println("Имя не найдено")
}

// Здесь переменные val и ok уже недоступны, мы не засоряем ими память
```

---

## Цикл for

Цикл позволяет повторять один и тот же код несколько раз. В Go есть только один ключевое слово для циклов — `for`. Оно заменяет все виды циклов из других языков (`while`, `do-while`, `foreach`).

### 1. Классический цикл со счетчиком

Используется, когда мы знаем, сколько раз нужно повторить действие.

Структура: `for инициализация; условие; действие_после_шага`

```go
// i := 0  — создаем счетчик i, равный 0
// i < 5   — цикл работает, пока i меньше 5
// i++     — после каждого круга увеличиваем i на 1
for i := 0; i < 5; i++ {
    fmt.Println("Шаг:", i)
}
// Выведет: 0, 1, 2, 3, 4
```

### 2. Цикл с условием (аналог while)

Используется, когда мы не знаем точное число повторений, но знаем условие, пока цикл должен работать.

```go
n := 1

// "Пока n меньше 100"
for n < 100 {
    n = n * 2 // Удваиваем число на каждом шаге
    fmt.Println(n)
}
// Выведет: 2, 4, 8, 16, 32, 64, 128
```

### 3. Бесконечный цикл

Иногда программе нужно работать вечно (например, сервер, который ждет запросы). Если не указать никаких условий, цикл будет бесконечным.

```go
for {
    fmt.Println("Работаю...")
    
    // Чтобы остановить такой цикл, нужно условие внутри
    if someCondition {
        break // Команда break немедленно прерывает цикл
    }
}
```

---

## Switch (переключатель)

Когда нужно проверить одну переменную на множество конкретных значений, `if-else` становится громоздким. `switch` делает код красивее.

### Как это работает

Мы берем переменную и сравниваем её с разными вариантами (`case`).

```go
day := "Вторник"

switch day {
case "Понедельник":
    fmt.Println("Начало недели")
case "Вторник":
    fmt.Println("Уже легче")
case "Пятница":
    fmt.Println("Почти выходные")
default:
    // Сработает, если ни один case не подошел
    fmt.Println("Обычный день")
}
```

**Особенности Switch в Go:**
1. **Не нужен break**. В других языках, если вы забыли написать `break`, выполнение перейдет к следующему `case`. В Go это не так: выполнился один блок — вышли из `switch`.
2. **Несколько значений в одном case**.

```go
letter := "a"

switch letter {
case "a", "e", "i", "o", "u":
    fmt.Println("Это гласная")
default:
    fmt.Println("Это согласная")
}
```

### Switch без условия (замена длинных if-else)

Можно использовать `switch` вообще без переменной. Тогда каждый `case` — это просто логическое условие. Это выглядит аккуратнее, чем куча `else if`.

```go
t := 15 // Часы

switch {
case t < 12:
    fmt.Println("Утро")
case t < 18:
    fmt.Println("День")
default:
    fmt.Println("Вечер")
}
```

## Итог

1. **if**: Используем для проверок. Круглые скобки не нужны.
2. **if с инициализацией**: Удобно, чтобы создать временную переменную только на время проверки.
3. **for**: Универсальный цикл. Может быть счетчиком (`i=0; i<10; i++`) или работать пока верно условие (`while`).
4. **switch**: Идеален, когда у переменной много возможных значений. Чище и понятнее, чем куча `if`.
