---
title: "Ошибки и проверка результата"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 4
---

В программировании что-то постоянно идет не так: файл не открылся, интернет пропал, пользователь ввел букву вместо цифры.

Во многих языках (Java, Python, C#) для этого придумали **исключения** (`try-catch`). Когда случается ошибка, программа бросает всё, перепрыгивает через код и ищет, кто бы её поймал. Это похоже на панику на корабле.

В Go подход другой. Здесь ошибка — это не катастрофа, а просто **значение**, такое же, как число или строка. Вы просто возвращаете ошибку из функции и спокойно проверяете её. Без паники и прыжков.

## Главное правило: "Проверь ошибку сразу"

Почти любая функция в Go, которая может сломаться, возвращает два значения: **результат** и **ошибку**.

```go
file, err := os.Open("config.txt")
```

Переменная `err` имеет специальный тип `error`.
- Если `err == nil` (пусто), значит всё хорошо, ошибок нет.
- Если `err != nil`, значит что-то случилось, и в `err` лежит описание проблемы.

### Стандартный шаблон

Вы будете писать этот код тысячи раз. Это идиома Go.

```go
file, err := os.Open("data.txt")

if err != nil {
    // Ой, что-то пошло не так
    fmt.Println("Не удалось открыть файл:", err)
    return // Останавливаем работу функции
}

// Если мы дошли сюда, значит err был nil. Можно работать с файлом!
defer file.Close()
```

### Почему так лучше?

1. **Нет скрытых путей**. Читая код, вы сразу видите, где может быть ошибка. Нет такого, что функция внезапно выкинула Exception, о котором вы не знали.
2. **Контроль**. Вы обязаны решить, что делать с ошибкой. Если вы её проигнорируете, компилятор или линтер вас поругают (за неиспользованную переменную `err`).

## Как создать свою ошибку

Допустим, вы пишете функцию, которая проверяет возраст.

```go
import "errors" // Подключаем стандартный пакет

func checkAge(age int) error {
    if age < 0 {
        // Создаем новую ошибку с текстом
        return errors.New("возраст не может быть отрицательным")
    }
    // Всё хорошо, возвращаем nil (ошибки нет)
    return nil
}
```

### Ошибка с подробностями

Часто нужно сказать не просто "ошибка", а добавить деталей (какой именно ID не найден). Для этого используем `fmt.Errorf`.

```go
func getUser(id int) (string, error) {
    if id == 0 {
        // %d заменится на значение id
        return "", fmt.Errorf("пользователь с id %d не найден", id)
    }
    return "User", nil
}
```

## Panic (Паника) — крайняя мера

В Go есть свой аналог исключений — `panic`. Но использовать его в обычном коде считается **дурным тоном**.

Паника полностью останавливает программу (крашит её). Её используют только в ситуациях, когда **невозможно** продолжать работу.
- Пример: программа стартует, а конфигурационного файла нет. Работать бессмысленно -> `panic`.
- Антипример: пользователь ввел неверный пароль. Это штатная ситуация, просто верните `error`.

```go
// Так делать НЕ НАДО в обычном коде
if userInput == "" {
    panic("пустой ввод") 
}

// НАДО делать так
if userInput == "" {
    return errors.New("пустой ввод")
}
```

## Итог

1. Ошибки в Go — это обычные значения. Не бойтесь их.
2. Проверяйте `if err != nil` сразу после вызова функции.
3. Если всё хорошо, возвращайте `nil`.
4. Забудьте про `panic`, пока не станете сеньором (а тогда вы поймете, что она вам почти не нужна).
