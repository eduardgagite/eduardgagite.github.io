---
title: "Ошибки и проверка результата"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 4
---

В Go **нет исключений** (exceptions). Это осознанное решение создателей языка.

Вместо блоков `try-catch`, где поток управления скачет непредсказуемо, Go использует явный возврат ошибок как обычных значений. Ошибка — это просто последнее возвращаемое значение функции. Если ошибок нет, оно равно `nil`.

## Стандартный паттерн проверки

Почти любой вызов функции, которая может сломаться, выглядит так:

```go
file, err := os.Open("config.txt")
if err != nil {
    // Обработка ошибки
    fmt.Println("Не удалось открыть файл:", err)
    return // Или выход, или повтор, или возврат ошибки выше
}

// Если мы здесь, значит err == nil, и с файлом можно работать
defer file.Close()
```

### Почему так лучше?

1. **Явность**: Читая код, вы сразу видите, где может возникнуть проблема.
2. **Локальность**: Ошибка обрабатывается там, где она произошла, а не где-то через 10 уровней стека.
3. **Контроль**: Вы обязаны решить, что делать с ошибкой (хотя бы проигнорировать её), иначе компилятор или линтер напомнят о неиспользованной переменной `err`.

## Создание своих ошибок

Тип `error` — это встроенный интерфейс. Чтобы создать ошибку, используют стандартный пакет `errors` или форматирование через `fmt`.

### Простая ошибка

```go
import "errors"

func validateAge(age int) error {
    if age < 0 {
        return errors.New("возраст не может быть отрицательным")
    }
    return nil
}
```

### Ошибка с данными (fmt.Errorf)

Если нужно добавить в текст ошибки детали (например, ID или значение), используют `fmt.Errorf`.

```go
func getUser(id int) (string, error) {
    if id == 0 {
        return "", fmt.Errorf("пользователь с id %d не найден", id)
    }
    return "User", nil
}
```

## Паника (panic)

В Go всё же есть механизм, похожий на исключения — **panic**. Но он используется только для **фатальных** ситуаций, когда программа не может продолжать работу (например, кончилась память или битая конфигурация при старте).

В обычном коде (валидация, сеть, файлы) панику использовать **нельзя**. Всегда возвращайте `error`.

```go
// Плохо:
if userInput == "" {
    panic("пустой ввод") 
}

// Хорошо:
if userInput == "" {
    return errors.New("пустой ввод")
}
```

## Итог

- Ошибки в Go — это значения типа `error`.
- Проверяйте ошибки сразу: `if err != nil`.
- Возвращайте `nil` в качестве ошибки, если операция прошла успешно.
- Не используйте `panic` для штатных ситуаций.
