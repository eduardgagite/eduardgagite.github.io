---
title: "Ошибки и проверка результата"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 4
---

В программировании что-то постоянно идет не так: файл не открылся, интернет пропал, пользователь ввел букву вместо цифры.

Во многих языках (Java, Python, C#) для этого придумали **исключения** (**try-catch**). Когда случается ошибка, программа бросает всё, перепрыгивает через код и ищет, кто бы её поймал. Это похоже на панику на корабле.

В Go подход другой. Здесь ошибка — это не катастрофа, а просто **значение**, такое же, как число или строка. Вы просто возвращаете ошибку из функции и спокойно проверяете её. Без паники и прыжков.

## Главное правило: "Проверь ошибку сразу"

Почти любая функция в Go, которая может сломаться, возвращает два значения: **результат** и **ошибку**.

```
file, err := os.Open("config.txt")
```

Переменная **err** имеет специальный тип **error**.
- Если **err == nil** (пусто), значит всё хорошо, ошибок нет.
- Если **err != nil**, значит что-то случилось, и в **err** лежит описание проблемы.

### Стандартный шаблон

Вы будете писать этот код тысячи раз. Это идиома Go.

```
file, err := os.Open("data.txt")

if err != nil {
    fmt.Println("Не удалось открыть файл:", err)
    return
}

defer file.Close()
```

### Почему так лучше?

1. **Нет скрытых путей**. Читая код, вы сразу видите, где может быть ошибка. Нет такого, что функция внезапно выкинула Exception, о котором вы не знали.
2. **Контроль**. Вы обязаны решить, что делать с ошибкой. Если вы её проигнорируете, компилятор или линтер вас поругают (за неиспользованную переменную **err**).

## Как создать свою ошибку

Допустим, вы пишете функцию, которая проверяет возраст.

```
import "errors"

func checkAge(age int) error {
    if age < 0 {
        return errors.New("возраст не может быть отрицательным")
    }
    return nil
}
```

### Ошибка с подробностями

Часто нужно сказать не просто "ошибка", а добавить деталей (какой именно ID не найден). Для этого используем **fmt.Errorf**.

```
func getUser(id int) (string, error) {
    if id == 0 {
        return "", fmt.Errorf("пользователь с id %d не найден", id)
    }
    return "User", nil
}
```

## Panic (Паника) — крайняя мера

В Go есть свой аналог исключений — **panic**. Но использовать его в обычном коде считается **дурным тоном**.

Паника полностью останавливает программу (крашит её). Её используют только в ситуациях, когда **невозможно** продолжать работу.
- Пример: программа стартует, а конфигурационного файла нет. Работать бессмысленно -> **panic**.
- Антипример: пользователь ввел неверный пароль. Это штатная ситуация, просто верните **error**.

```
if userInput == "" {
    panic("пустой ввод")
}

if userInput == "" {
    return errors.New("пустой ввод")
}
```

## Итог

1. Ошибки в Go — это обычные значения. Не бойтесь их.
2. Проверяйте **if err != nil** сразу после вызова функции.
3. Если всё хорошо, возвращайте **nil**.
4. Забудьте про **panic**, пока не станете сеньором (а тогда вы поймете, что она вам почти не нужна).
