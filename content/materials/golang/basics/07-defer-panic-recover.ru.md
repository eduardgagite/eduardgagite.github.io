---
title: "Defer, panic и recover"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 7
---

В Go есть три встроенных механизма, которые управляют потоком выполнения в нестандартных ситуациях: **defer** откладывает вызов функции до завершения текущей, **panic** аварийно останавливает программу, а **recover** перехватывает панику и позволяет продолжить работу.

## Defer — отложенный вызов

Ключевое слово **defer** говорит: "Выполни эту функцию, но не сейчас, а когда текущая функция завершится". Неважно, как она завершится — нормально или из-за ошибки.

```
func main() {
    fmt.Println("Начало")
    defer fmt.Println("Это выполнится последним")
    fmt.Println("Конец")
}
```

Вывод:

```
Начало
Конец
Это выполнится последним
```

### Главное применение — освобождение ресурсов

Открыли файл — нужно закрыть. Открыли соединение с базой — нужно закрыть. **defer** гарантирует, что ресурс будет освобождён, даже если в середине функции произойдёт ошибка.

```
func readConfig(path string) ([]byte, error) {
    f, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer f.Close()

    data, err := io.ReadAll(f)
    if err != nil {
        return nil, err
    }
    return data, nil
}
```

Без **defer** пришлось бы вызывать **f.Close()** перед каждым **return**. С **defer** — один раз, сразу после открытия.

### Порядок выполнения: LIFO

Если в функции несколько **defer**, они выполняются в обратном порядке — последний отложенный вызов выполнится первым (стек).

```
func main() {
    defer fmt.Println("первый defer")
    defer fmt.Println("второй defer")
    defer fmt.Println("третий defer")
}
```

Вывод:

```
третий defer
второй defer
первый defer
```

Это логично: если вы открыли ресурс A, потом ресурс B (который зависит от A), закрывать нужно сначала B, потом A.

### Аргументы вычисляются сразу

Важный нюанс: аргументы отложенной функции вычисляются в момент вызова **defer**, а не в момент выполнения.

```
func main() {
    x := 10
    defer fmt.Println("x =", x)
    x = 20
}
```

Вывод: **x = 10**, а не 20. Если нужно захватить актуальное значение, используйте замыкание:

```
defer func() {
    fmt.Println("x =", x)
}()
```

## Panic — аварийная остановка

**panic** — это аварийное завершение текущей горутины. Используется, когда произошло что-то, из чего невозможно восстановиться: нарушена внутренняя логика программы, обнаружен баг.

```
func divide(a, b int) int {
    if b == 0 {
        panic("деление на ноль")
    }
    return a / b
}
```

Когда вызывается **panic**:
1. Текущая функция останавливается.
2. Выполняются все **defer** в текущей функции.
3. Управление возвращается вызывающей функции, и она тоже останавливается (со своими defer).
4. Так вверх по стеку, пока горутина не завершится.

### Когда использовать panic

**Используйте panic** только в ситуациях, которые говорят о баге в коде:
- Нарушение инварианта (невозможное состояние).
- Ошибка инициализации, без которой программа не может работать.

**Не используйте panic** для ожидаемых ошибок (файл не найден, сетевой сбой, неверный ввод пользователя). Для этого существует возврат **error**.

```
func mustParseURL(raw string) *url.URL {
    u, err := url.Parse(raw)
    if err != nil {
        panic(fmt.Sprintf("невалидный URL: %s", raw))
    }
    return u
}
```

Функции с префиксом **must** в Go-сообществе — соглашение: "эта функция паникует вместо возврата ошибки". Применяйте их только при инициализации, когда ошибка означает "программу нельзя запустить".

## Recover — перехват паники

**recover** — это встроенная функция, которая "ловит" панику и позволяет программе продолжить работу. Она работает **только внутри defer**.

```
func safeDiv(a, b int) (result int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("перехвачена паника: %v", r)
        }
    }()

    return a / b, nil
}

func main() {
    result, err := safeDiv(10, 0)
    if err != nil {
        fmt.Println("Ошибка:", err) // "перехвачена паника: runtime error: integer divide by zero"
    } else {
        fmt.Println("Результат:", result)
    }
}
```

### Где recover реально нужен

На практике **recover** используется в двух местах:

1. **HTTP-сервер** — чтобы паника в одном обработчике не убила весь сервер. Стандартный HTTP-сервер Go делает это автоматически.

2. **Middleware для перехвата паник** — во фреймворках и библиотеках.

```
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("паника в обработчике: %v", err)
                http.Error(w, "Internal Server Error", 500)
            }
        }()
        next.ServeHTTP(w, r)
    })
}
```

Не используйте **recover** как замену нормальной обработке ошибок через **error**. Это инструмент последней линии обороны.

## Итог

**defer** — для гарантированного освобождения ресурсов (файлы, соединения, мьютексы). **panic** — для невосстановимых ситуаций, сигнализирующих о баге. **recover** — для перехвата паник на границах системы (HTTP-обработчики, воркеры). В повседневном коде вы будете использовать **defer** постоянно, **panic** — редко, а **recover** — почти никогда.
