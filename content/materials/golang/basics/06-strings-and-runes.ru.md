---
title: "Строки, руны и Unicode"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 6
---

Строки в Go — это не массив символов, как в некоторых языках. Строка — это неизменяемая последовательность **байтов**. Это принципиальный момент, который объясняет многие неочевидные вещи в работе с текстом.

Go использует кодировку **UTF-8** по умолчанию. Латинская буква занимает 1 байт, кириллица — 2 байта, а эмодзи — 4 байта. Поэтому длина строки в байтах и количество "символов" — это разные вещи.

## Байты vs руны

```
s := "Привет"

fmt.Println(len(s)) // 12
```

Функция **len** возвращает количество байтов, а не символов. Для подсчёта символов (рун) нужен пакет **unicode/utf8**.

```
import "unicode/utf8"

s := "Привет"
fmt.Println(utf8.RuneCountInString(s)) // 6
```

**Руна** (rune) — это тип Go для одного Unicode-символа. Технически это алиас для **int32**, то есть числовой код символа.

```
var r rune = 'П'
fmt.Println(r) // 1055
```

## Перебор строки

### Побайтово (обычно не то, что нужно)

```
s := "Go!"
for i := 0; i < len(s); i++ {
    fmt.Printf("Байт %d: %c\n", i, s[i])
}
```

Для ASCII-строк это работает. Но если в строке кириллица или другие многобайтовые символы, вы получите "мусор" — отдельные байты вместо букв.

### По рунам (правильный способ)

Цикл **for range** по строке автоматически декодирует руны.

```
s := "Привет"
for i, r := range s {
    fmt.Printf("Позиция %d: %c\n", i, r)
}
```

Здесь **i** — это позиция в байтах (0, 2, 4, 6, 8, 10), а **r** — руна (символ). Позиции идут не подряд, потому что каждая кириллическая буква занимает 2 байта.

## Преобразования

### Строка в срез байтов и обратно

Строки в Go неизменяемы. Если нужно изменить строку, преобразуйте её в срез байтов, измените и преобразуйте обратно.

```
s := "Hello"
b := []byte(s)
b[0] = 'h'
s2 := string(b)
fmt.Println(s2) // "hello"
```

### Строка в срез рун

Для работы с многобайтовыми символами безопаснее использовать срез рун.

```
s := "Привет"
runes := []rune(s)
runes[0] = 'п'
s2 := string(runes)
fmt.Println(s2)         // "привет"
fmt.Println(len(runes)) // 6
```

## Полезные функции пакета strings

Пакет **strings** содержит всё необходимое для работы с текстом.

```
import "strings"

strings.Contains("Hello, World", "World")  // true
strings.HasPrefix("config.json", "config") // true
strings.HasSuffix("photo.png", ".png")     // true

strings.ToUpper("hello") // "HELLO"
strings.ToLower("HELLO") // "hello"

strings.TrimSpace("  hello  ")          // "hello"
strings.Replace("aaa", "a", "b", 2)     // "bba"
strings.ReplaceAll("aaa", "a", "b")     // "bbb"

strings.Split("a,b,c", ",")             // ["a", "b", "c"]
strings.Join([]string{"a", "b"}, "-")   // "a-b"
```

## Конкатенация строк

Оператор **+** создаёт новую строку при каждом сложении. Для одного-двух склеиваний это нормально. Но если нужно собрать строку из множества кусков (например, в цикле), используйте **strings.Builder** — он эффективнее, потому что не создаёт промежуточные строки.

```
var b strings.Builder
for i := 0; i < 1000; i++ {
    b.WriteString("Go")
}
result := b.String()
```

## Итог

Строка в Go — это последовательность байтов, а не символов. Для работы с Unicode используйте **руны** и цикл **for range**. Пакет **strings** покрывает большинство задач по обработке текста. **Если строка содержит не только ASCII, всегда думайте в терминах рун, а не байтов.**
