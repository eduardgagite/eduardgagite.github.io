---
title: "Указатели"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 5
---

Когда вы передаёте переменную в функцию, Go по умолчанию создаёт **копию** значения. Функция работает с копией, а оригинал остаётся нетронутым. Это безопасно, но иногда нужно изменить именно оригинал. Для этого существуют указатели.

Указатель — это переменная, которая хранит не само значение, а **адрес в памяти**, где это значение лежит. Как записка с адресом дома вместо самого дома.

## Синтаксис

Два оператора — всё, что нужно знать:

- **&** (амперсанд) — "дай мне адрес этой переменной".
- **\*** (звёздочка) — "дай мне значение по этому адресу" (разыменование).

```
func main() {
    age := 25

    ptr := &age
    fmt.Println(ptr)  // 0xc0000b6010
    fmt.Println(*ptr) // 25

    *ptr = 30
    fmt.Println(age) // 30
}
```

Тип указателя записывается как **\*T**, где **T** — тип значения. Указатель на **int** имеет тип **\*int**, указатель на **string** — **\*string**.

## Зачем нужны указатели

### Изменение значения в функции

Без указателя функция работает с копией и не может изменить оригинал.

```
func doubleValue(n int) {
    n = n * 2
}

func doublePointer(n *int) {
    *n = *n * 2
}

func main() {
    x := 10

    doubleValue(x)
    fmt.Println(x) // 10

    doublePointer(&x)
    fmt.Println(x) // 20
}
```

### Экономия памяти

Если структура большая (десятки полей), копировать её при каждом вызове функции — расточительно. Передача указателя копирует только 8 байт (размер адреса), а не всю структуру.

```
type Report struct {
    Title   string
    Content string
    Pages   int
    // ... ещё 20 полей
}

func process(r *Report) {
    r.Pages = 42
}
```

Обратите внимание: при обращении к полям через указатель на структуру Go не требует писать **(\*r).Pages**. Запись **r.Pages** работает автоматически — компилятор сам разыменовывает указатель.

## Методы с указателем-получателем

В разделе о структурах мы создавали методы. Если метод должен изменять поля структуры, получатель должен быть указателем.

```
type Counter struct {
    Value int
}

func (c Counter) IncrementBroken() {
    c.Value++
}

func (c *Counter) Increment() {
    c.Value++
}

func main() {
    counter := Counter{Value: 0}

    counter.IncrementBroken()
    fmt.Println(counter.Value) // 0

    counter.Increment()
    fmt.Println(counter.Value) // 1
}
```

Практическое правило: если хотя бы один метод структуры использует указатель-получатель, **все методы** этой структуры должны использовать указатель. Это соглашение Go-сообщества.

## Нулевое значение указателя — nil

Указатель, которому не присвоен адрес, равен **nil**. Попытка разыменовать **nil** вызовет панику (аварийное завершение программы).

```
var ptr *int // ptr == nil

// fmt.Println(*ptr) // ПАНИКА: runtime error: invalid memory address

if ptr != nil {
    fmt.Println(*ptr)
}
```

Всегда проверяйте указатель на **nil**, если он мог прийти извне (из другой функции, из параметра).

## Когда использовать указатели, а когда — нет

**Используйте указатели**, когда:
- Нужно изменить переданное значение.
- Структура большая и копирование дорого.
- Нужно выразить "значения может не быть" (**nil**).

**Не используйте указатели**, когда:
- Работаете с маленькими типами (**int**, **bool**, **string**).
- Функция только читает значение, не изменяя его.
- Хотите гарантировать, что вызывающий код не повлияет на ваши данные.

Срезы, карты и каналы уже содержат внутренний указатель — передавать **\*[]int** или **\*map[string]int** не нужно.

## Итог

Указатель — это адрес значения в памяти. Оператор **&** берёт адрес, оператор **\*** читает или пишет по адресу. Указатели нужны, чтобы функции могли изменять переданные значения и чтобы не копировать большие структуры. **Всегда проверяйте указатель на nil перед разыменованием.**
