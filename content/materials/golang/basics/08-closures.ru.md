---
title: "Замыкания и анонимные функции"
category: "golang"
categoryTitle: "Go"
section: "basics"
sectionTitle: "Базовые конструкции"
sectionOrder: 2
order: 8
---

В Go функции — полноправные граждане языка. Их можно присваивать переменным, передавать как аргументы и возвращать из других функций. На этом и строятся замыкания.

**Замыкание** (closure) — это функция, которая захватывает переменные из окружающего контекста. Захваченные переменные живут столько, сколько живёт само замыкание.

## Анонимные функции

Функцию можно объявить прямо в коде и сразу же вызвать или сохранить в переменную.

```
greet := func(name string) string {
    return "Привет, " + name
}

fmt.Println(greet("Gopher"))
```

Анонимную функцию также можно вызвать немедленно — это называется IIFE (Immediately Invoked Function Expression):

```
result := func(a, b int) int {
    return a + b
}(10, 20)

fmt.Println(result) // 30
```

Это часто используется в **goroutine** — чтобы передать контекст прямо при запуске:

```
go func(id int) {
    fmt.Printf("Воркер %d запущен\n", id)
}(42)
```

## Замыкание захватывает переменную, а не её значение

Ключевой момент: замыкание захватывает **ссылку** на переменную, а не её копию. Это значит, что изменения переменной снаружи видны внутри замыкания, и наоборот.

```
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

func main() {
    counter := makeCounter()
    fmt.Println(counter()) // 1
    fmt.Println(counter()) // 2
    fmt.Println(counter()) // 3
}
```

Каждый вызов **counter()** увеличивает **count** на 1. Переменная **count** живёт в памяти, пока существует замыкание **counter**.

Если создать два счётчика — у каждого своё независимое состояние:

```
c1 := makeCounter()
c2 := makeCounter()

fmt.Println(c1()) // 1
fmt.Println(c1()) // 2
fmt.Println(c2()) // 1 — свой независимый счётчик
```

## Типичная ловушка с горутинами в цикле

Одна из самых распространённых ошибок в Go — запуск горутин в цикле с захватом переменной цикла.

```
// НЕПРАВИЛЬНО: все горутины напечатают одно и то же значение
for i := 0; i < 3; i++ {
    go func() {
        fmt.Println(i) // захватывает ссылку на i
    }()
}
```

Все горутины захватывают одну и ту же переменную **i**. К моменту их запуска цикл может уже завершиться, и **i** будет равно 3.

Правильный способ — передать значение через параметр:

```
// ПРАВИЛЬНО: каждая горутина получает свою копию
for i := 0; i < 3; i++ {
    go func(id int) {
        fmt.Println(id)
    }(i)
}
```

Или с Go 1.22+ переменная цикла создаётся заново на каждой итерации, но явная передача параметра всё равно читается понятнее.

## Функции как аргументы: паттерн обратного вызова

Замыкания отлично работают как коллбэки. Классический пример — функция-фильтр:

```
func filter(nums []int, predicate func(int) bool) []int {
    var result []int
    for _, n := range nums {
        if predicate(n) {
            result = append(result, n)
        }
    }
    return result
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 6}

    even := filter(nums, func(n int) bool { return n%2 == 0 })
    big := filter(nums, func(n int) bool { return n > 3 })

    fmt.Println(even) // [2 4 6]
    fmt.Println(big)  // [4 5 6]
}
```

Логика фильтрации отделена от логики предиката. Функция **filter** работает с любым условием.

## Замыкание как способ скрыть состояние

Иногда удобно создать функцию с "памятью", не создавая структуру:

```
func makeRateLimiter(limit int) func() bool {
    count := 0
    return func() bool {
        if count >= limit {
            return false
        }
        count++
        return true
    }
}

func main() {
    allow := makeRateLimiter(3)

    for i := 0; i < 5; i++ {
        if allow() {
            fmt.Println("Запрос разрешён")
        } else {
            fmt.Println("Лимит исчерпан")
        }
    }
}
```

Переменная **count** недоступна снаружи, но живёт между вызовами. Это простая альтернатива структуре с методами.

## Итого

Анонимные функции и замыкания — мощный инструмент Go, который делает код компактным и выразительным. **Главное помнить: замыкание захватывает ссылку на переменную, а не её значение** — это источник большинства ошибок. В горутинах всегда передавайте значение явно через параметр.
