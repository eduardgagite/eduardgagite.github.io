---
title: "Проектирование интерфейсов"
category: "golang"
categoryTitle: "Go"
section: "best-practices"
sectionTitle: "Практики и качество"
sectionOrder: 11
order: 6
---

В Go интерфейсы — основа гибкой и тестируемой архитектуры. Но их легко применить неправильно: сделать слишком большими, определить не в том пакете или создать ради создания. Эти принципы помогут проектировать интерфейсы правильно.

## Принцип: интерфейсы маленькие

Одна из ключевых идей Go — маленькие интерфейсы. Стандартная библиотека демонстрирует это лучше всего:

```
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}
```

Один метод — один интерфейс. При необходимости их компонуют:

```
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

**Правило**: если в интерфейсе больше 3-4 методов — подумайте, нельзя ли его разбить.

## Принцип: интерфейсы определяются у потребителя

Частая ошибка — определить интерфейс в том же пакете, где реализация:

```
// Плохо: пакет storage сам определяет свой интерфейс
package storage

type UserRepository interface {  // Здесь не нужен интерфейс!
    GetUser(id int) (*User, error)
    CreateUser(u *User) error
}

type PostgresUserRepo struct { ... }

func (r *PostgresUserRepo) GetUser(id int) (*User, error) { ... }
func (r *PostgresUserRepo) CreateUser(u *User) error { ... }
```

Правильно — интерфейс определяет тот, кто его использует:

```
// Хорошо: пакет service определяет нужный ему интерфейс
package service

// Интерфейс описывает то, что нужно service — не больше
type UserRepo interface {
    GetUser(id int) (*User, error)
    CreateUser(u *User) error
}

type UserService struct {
    repo UserRepo
}
```

Теперь **storage** не знает о **service**, зависимость направлена правильно. В тестах можно подставить мок.

## Accept interfaces, return structs

Классический принцип Go: функции и методы принимают интерфейс, возвращают конкретный тип.

```
// Хорошо: принимаем io.Reader — работаем с любым источником данных
func ParseConfig(r io.Reader) (*Config, error) {
    // ...
}

// Плохо: принимаем конкретный тип — привязка к реализации
func ParseConfig(f *os.File) (*Config, error) {
    // ...
}
```

Если возвращать интерфейс — вы скрываете информацию о типе от вызывающего кода, и он не сможет получить доступ к дополнительным методам конкретного типа.

Исключение: **error** — это интерфейс, и возвращать его правильно.

## Не создавайте интерфейс без причины

Интерфейс нужен, когда:
1. Есть несколько реализаций (PostgreSQL, MySQL, in-memory для тестов).
2. Нужна возможность подменить зависимость в тестах.
3. Поведение может меняться в зависимости от конфигурации.

Не нужен, когда:
1. Есть только одна реализация, и другой не предвидится.
2. Это просто структура с данными.
3. Вы создаёте интерфейс "на будущее".

```
// Лишний интерфейс — есть одна реализация, и она не меняется
type ConfigLoader interface {
    Load() (*Config, error)
}

type fileConfigLoader struct { ... }

// Лучше напрямую:
func LoadConfig(path string) (*Config, error) { ... }
```

## Проверка реализации интерфейса на этапе компиляции

Добавьте эту строку, чтобы компилятор проверял реализацию:

```
// Убеждаемся, что *PostgresUserRepo реализует UserRepo
var _ UserRepo = (*PostgresUserRepo)(nil)
```

Если вы забыли реализовать какой-то метод — получите ошибку компиляции, а не панику в runtime. Это стандартная практика в больших пакетах.

## Интерфейсы и nil — распространённая ловушка

Интерфейс в Go содержит два поля: тип и указатель. Он равен **nil** только если оба поля **nil**:

```
func getError() error {
    var err *MyError = nil
    return err // НЕ nil! Интерфейс содержит тип *MyError
}

func main() {
    err := getError()
    if err != nil { // Всегда true!
        fmt.Println("Ошибка:", err)
    }
}
```

Правило: **никогда не возвращайте типизированный nil через интерфейс**. Возвращайте просто **nil**:

```
func getError() error {
    // ...
    return nil // Правильно: nil без типа
}
```

## Итого

Хороший интерфейс в Go — маленький, определённый у потребителя, существующий по конкретной причине. **Лучший интерфейс — это один метод**. Принимайте интерфейсы в параметрах, возвращайте конкретные типы. И всегда добавляйте проверку `var _ Interface = (*Impl)(nil)` — это бесплатная страховка от ошибок рефакторинга.
