---
title: "Структура проекта и рабочие каталоги"
category: "golang"
categoryTitle: "Go"
section: "packages-modules"
sectionTitle: "Пакеты и модули"
sectionOrder: 4
order: 3
---

Когда проект вырастает за пределы одного файла `main.go`, встает вопрос: как всё разложить, чтобы не запутаться?

В Go есть **стандартный лейаут**, который не является законом, но принят сообществом. Если вы ему следуете, любому Go-разработчику будет легко разобраться в вашем проекте.

## Плоская структура (маленькие проекты)

Если у вас микросервис или утилита на 5-15 файлов, **не усложняйте**. Положите всё в корень.

```
my-tool/
├── go.mod
├── go.sum
├── main.go        # Точка входа
├── handler.go     # HTTP обработчики
├── storage.go     # Работа с БД
└── config.go      # Конфигурация
```

Это нормально и правильно. Не нужно создавать папки ради папок.

## Стандартная структура (средние и большие проекты)

Когда проект растет и в команде больше 2-3 человек, код разделяют на слои.

```
my-project/
├── cmd/                    # Точки входа
│   ├── api/
│   │   └── main.go         # Запуск API сервера
│   └── worker/
│       └── main.go         # Запуск фонового воркера
│
├── internal/               # Приватный код (не виден извне)
│   ├── user/
│   │   ├── model.go        # Структуры: User, CreateUserRequest
│   │   ├── handler.go      # HTTP обработчики для /users
│   │   ├── service.go      # Бизнес-логика
│   │   └── repository.go   # Запросы к базе данных
│   ├── order/
│   │   ├── model.go
│   │   └── service.go
│   └── middleware/
│       └── auth.go         # Аутентификация
│
├── pkg/                    # Публичные библиотеки
│   └── logger/
│       └── logger.go       # Можно использовать в других проектах
│
├── migrations/             # SQL миграции
├── configs/                # Конфигурационные файлы
├── go.mod
├── go.sum
└── Makefile
```

### Разбор папок

### cmd/

Здесь лежат **точки входа** (файлы с `package main` и `func main()`). Логики тут минимум — только инициализация зависимостей и запуск.

Зачем отдельная папка? Потому что у проекта может быть несколько бинарников: API-сервер, фоновый воркер, CLI-утилита для миграций.

```go
// cmd/api/main.go
package main

func main() {
    cfg := config.Load()
    db := database.Connect(cfg.DatabaseURL)
    server := api.NewServer(db)
    server.Run(cfg.Port)
}
```

### internal/

Это **магическая папка** в Go. Компилятор **запрещает** импортировать код из `internal/` другим модулям. Даже если кто-то напишет `import "github.com/you/project/internal/user"` — код не скомпилируется.

Это ваш способ сказать: "Это внутренности моего приложения. Не привязывайтесь к ним, я могу всё переделать завтра".

### pkg/

Код, который вы **не против** дать другим. Например, универсальный логгер или HTTP-клиент.

Если сомневаетесь — кладите в `internal/`. Всегда можно перенести в `pkg/` позже, но обратный путь сложнее (кто-то мог уже начать использовать ваш пакет).

## Группировка по фичам vs по слоям

### По слоям (как в Java)

```
internal/
├── models/      # Все модели
├── handlers/    # Все обработчики
├── services/    # Вся логика
└── repositories/ # Все запросы к БД
```

Проблема: чтобы понять, как работает "пользователь", нужно прыгать между 4 папками.

### По фичам (рекомендуется в Go)

```
internal/
├── user/        # Всё про пользователя в одном месте
├── order/       # Всё про заказ в одном месте
└── payment/     # Всё про оплату в одном месте
```

Преимущество: вся логика одной фичи — рядом. Открыл папку `user/` — и видишь полную картину.

## Чего делать НЕ надо

1. **Не создавайте папку src/**. Это привычка из Java. В Go весь код — это уже "src".
2. **Не создавайте пакет utils/**. Это помойка, в которую складывают всё подряд. Лучше назовите пакет по смыслу: `httputil`, `stringutil`.
3. **Избегайте циклических зависимостей**. Пакет A не может импортировать B, если B уже импортирует A. Если столкнулись с этим — значит, нужно пересмотреть границы пакетов.

## Итог

1. **Начинайте просто**. Один `main.go` в корне — нормально.
2. Когда растете — создайте `cmd/` и `internal/`.
3. Группируйте по **фичам**, а не по слоям.
4. Используйте `internal/`, чтобы защитить внутренности от внешнего использования.
