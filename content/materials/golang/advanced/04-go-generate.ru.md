---
title: "go generate и кодогенерация"
category: "golang"
categoryTitle: "Go"
section: "advanced"
sectionTitle: "Продвинутые возможности"
sectionOrder: 13
order: 4
---

Кодогенерация — написание программ, которые пишут другие программы. В Go это первоклассный инструмент: команда **go generate** запускает генераторы прямо из исходного кода. Сгенерированный код затем компилируется как обычный Go.

## Что такое go generate

**go generate** — не магия. Это просто способ запустить произвольную команду из директивы в исходнике:

```
//go:generate stringer -type=Direction
```

Когда вы запускаете **go generate ./...**, Go находит такие комментарии и выполняет указанные команды. Генераторы создают **.go** файлы, которые попадают в компиляцию.

Директива всегда начинается с **//go:generate** (без пробела) и содержит команду.

## Пример: stringer для читаемого вывода enum

Утилита **stringer** автоматически генерирует метод **String()** для типов с **iota**:

```
go install golang.org/x/tools/cmd/stringer@latest
```

В файле **direction.go**:

```
package main

//go:generate stringer -type=Direction

type Direction int

const (
    North Direction = iota
    South
    East
    West
)
```

После запуска **go generate** появится файл **direction_string.go**:

```
// Code generated by stringer -type=Direction; DO NOT EDIT.

func (i Direction) String() string {
    switch i {
    case North:
        return "North"
    case South:
        return "South"
    case East:
        return "East"
    case West:
        return "West"
    default:
        return fmt.Sprintf("Direction(%d)", int(i))
    }
}
```

Теперь **fmt.Println(North)** выведет **"North"**, а не **"0"**.

## Пример: mockgen для тестовых моков

**mockgen** генерирует мок-реализации интерфейсов для тестов:

```
go install go.uber.org/mock/mockgen@latest
```

Для интерфейса **UserRepository**:

```
//go:generate mockgen -source=repository.go -destination=mock_repository.go -package=service
type UserRepository interface {
    GetUser(ctx context.Context, id int) (*User, error)
    CreateUser(ctx context.Context, u *User) error
}
```

Генерирует файл с мок-объектом, который используется в тестах без реального подключения к базе.

## Пример: sqlc — генерация Go-кода из SQL

**sqlc** генерирует типобезопасный Go-код из SQL-запросов:

```
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
```

Вы пишете SQL:

```
-- name: GetUser :one
SELECT id, name, email FROM users WHERE id = $1;

-- name: ListUsers :many
SELECT id, name, email FROM users;
```

**sqlc** генерирует:

```
func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) { ... }
func (q *Queries) ListUsers(ctx context.Context) ([]User, error) { ... }
```

Никаких **interface{}**, никаких ошибок в именах колонок — всё проверяется на этапе генерации.

## Соглашения

Сгенерированные файлы принято помечать заголовком:

```
// Code generated by <tool>. DO NOT EDIT.
```

Это сигнал для разработчиков и инструментов (линтеров, code review) не редактировать файл вручную.

По соглашению имена сгенерированных файлов часто содержат **_gen.go** или **_string.go** суффиксы.

## Как запускать

```
# Для текущего пакета
go generate

# Для всех пакетов в модуле
go generate ./...

# С выводом команд
go generate -v ./...
```

**go generate** не запускается автоматически при **go build** или **go test** — его нужно запускать явно. Обычно это делается в Makefile или в CI перед сборкой.

```
# Makefile
generate:
    go generate ./...

build: generate
    go build ./...
```

## Итого

**go generate** — декларативный способ запускать генераторы кода из исходников. Три самых полезных инструмента: **stringer** для String() методов, **mockgen** для тестовых моков, **sqlc** для типобезопасных SQL-запросов. Сгенерированные файлы коммитятся в репозиторий — это позволяет собирать проект без дополнительных инструментов. **Помечайте их заголовком "DO NOT EDIT"** и запускайте генерацию в CI.
