---
title: "Практические сценарии"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 5
---

Redis Streams — гибкий инструмент, который можно использовать не только как простую очередь задач. Рассмотрим три распространенных сценария использования в реальных проектах.

## 1. Асинхронные задачи (Job Queue)

Классический пример: пользователь регистрируется на сайте, и нам нужно отправить приветственный email, создать запись в CRM и начислить бонусы. Делать это синхронно в HTTP-запросе долго и ненадежно.

**Решение:**
API-сервер быстро пишет событие в стрим и сразу отвечает пользователю "ОК".

```
XADD jobs:email * to "user@example.com" template "welcome" context_id 42
```

На фоне работает группа воркеров (написанных хоть на Python, хоть на Go), которая разбирает этот стрим. Воркеры обеспечивают повторную отправку при сбоях почтового шлюза, не блокируя основной сайт.

## 2. Event Sourcing и Аудит

В финансовых или админских системах важно знать не только *текущее* состояние объекта, но и *как* он к нему пришел. Кто изменил настройки? Когда поменялся статус заказа?

**Решение:**
Использовать стрим как неизменяемый журнал всех действий.

```
XADD audit:orders * action "status_change" order_id 555 old "new" new "paid" user "manager_alex"
```

В отличие от простых логов в файле, этот стрим можно:
- Читать программно в реальном времени (например, для обновления UI у администраторов через WebSocket).
- Анализировать ретроспективно (восстановить историю заказа №555).
- Использовать для перестроения состояния базы данных в случае аварии.

## 3. Сбор метрик и IoT (Internet of Things)

Представьте тысячи датчиков температуры или GPS-трекеров, которые шлют данные каждую секунду. Писать каждый чих в SQL базу данных — убить диск.

**Решение:**
Датчики шлют данные в Redis Stream. Это очень быстро (в памяти).

```
XADD sensors:temp * device_id "sensor-1" val 24.5 ts 1618590100
```

Отдельный сервис ("агрегатор") читает стрим пачками, усредняет данные (например, средняя температура за минуту) и уже этот агрегированный результат сохраняет в долгосрочное хранилище (PostgreSQL, TimescaleDB, InfluxDB).

Стрим здесь работает как буфер, сглаживающий пиковые нагрузки.

## Когда НЕ стоит использовать Streams

Несмотря на мощь, Streams не заменяют всё подряд:
1. **Kafka** лучше подойдет, если у вас терабайты логов, которые нужно хранить годами (Redis хранит все в оперативной памяти, это дорого).
2. **RabbitMQ** может быть удобнее, если нужна сложная логика маршрутизации (routing keys, exchanges), которой в Redis нет.

## Итого

Redis Streams отлично подходят для:
- Быстрых очередей задач внутри микросервисов.
- Логов активности и аудита.
- Буферизации большого потока данных (IoT, кликстрим).

Это "золотая середина" между простотой списков Redis и сложностью "взрослых" брокеров вроде Kafka.
