---
title: "Практические сценарии"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 5
---

## Практические сценарии использования Redis Streams

Streams в Redis особенно полезны там, где нужно асинхронно обрабатывать события и задачи, не блокируя основной поток запросов. Ниже — несколько типичных сценариев, которые легко реализовать на базе XADD, XREADGROUP и Consumer Groups.

## Отправка писем и уведомлений

Частая задача — не задерживать ответ пользователю из‑за отправки письма или пуш‑уведомления. Вместо этого приложение пишет событие в поток, а отдельный сервис спокойно обрабатывает его в фоне.

Приложение записывает задачу в поток **notify:events**:

```
XADD notify:events * user_id 123 type email template welcome
XADD notify:events * user_id 123 type push template promo
```

Сервис уведомлений создаёт группу потребителей и читает задачи:

```
XGROUP CREATE notify:events notify-workers 0-0 MKSTREAM
XREADGROUP GROUP notify-workers worker-1 COUNT 10 BLOCK 5000 STREAMS notify:events >
```

После успешной отправки уведомления он подтверждает сообщение через XACK. Так бизнес‑логика остаётся простой, а тяжёлая работа переносится в фон.

## Обработка файлов и изображений

Когда пользователи загружают изображения или документы, их часто нужно сжать, создать превью или прогнать через антивирус. Эти операции могут быть тяжёлыми, поэтому удобно ставить их в очередь.

Веб‑приложение пишет событие о загруженном файле:

```
XADD media:tasks * user_id 456 file_id 789 action resize
```

Сервис обработки медиа читает задачи из группы:

```
XGROUP CREATE media:tasks media-workers 0-0 MKSTREAM
XREADGROUP GROUP media-workers worker-1 COUNT 5 BLOCK 5000 STREAMS media:tasks >
```

Если обработка прошла успешно — вызывает XACK. Если произошла ошибка, можно не подтверждать сообщение и позволить другому воркеру забрать его через XAUTOCLAIM после таймаута.

## Логи и бизнес‑события

Streams можно использовать как источник правды для бизнес‑событий: регистрации, оплаты, изменения тарифов. Один или несколько сервисов пишут в общий поток **business:events**, а другие сервисы подписываются и реагируют.

Например, сервис заказов сохраняет события:

```
XADD business:events * type order_created order_id 1001 user_id 123
XADD business:events * type order_paid order_id 1001 user_id 123
```

Аналитический сервис читает эти события (через XREAD или собственную группу) и складывает агрегированные данные куда‑нибудь в хранилище отчётов. При необходимости можно переиграть историю и пересчитать отчёты, просто снова прочитав поток с начала.

## Интеграции с внешними API

Интеграции с платёжными провайдерами, почтовыми сервисами или CRM часто ненадёжны: таймауты, ограничения по количеству запросов, временные ошибки. Streams помогают выстроить надёжную очередь таких вызовов с контролем повторных попыток.

Сервис создаёт задачи на вызов внешнего API:

```
XADD integration:tasks * provider stripe action create_charge user_id 123 amount 1999
```

Воркеры читают поток через Consumer Group, пытаются вызвать внешнее API и:

- при успехе подтверждают задачу XACK;
- при временной ошибке оставляют её непотверждённой, чтобы через несколько минут повторно вытащить через XAUTOCLAIM;
- при фатальной ошибке переписывают в поток **integration:dead-letter** для ручного разбора.

Так приложение остаётся стабильным, даже если внешние системы работают нестабильно.

## Итого

Streams удобно применять для фоновых задач, интеграций, логирования и бизнес‑событий — везде, где нужен надёжный и упорядоченный поток сообщений. Они позволяют разделить быстрый ответ пользователю и тяжёлую работу, не усложняя инфраструктуру.

Главное, что стоит запомнить: **Redis Streams — это универсальный инструмент для событийных систем и очередей задач, который хорошо вписывается в архитектуру микросервисов и не требует тяжёлых брокеров сообщений**.


