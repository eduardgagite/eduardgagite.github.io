---
title: "Consumer Groups"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 3
---

**Consumer Groups** в **Streams** позволяют нескольким обработчикам работать с одним потоком, распределяя записи между ними. Каждая группа отслеживает прогресс, чтобы записи не дублировались и не терялись. Это похоже на consumer groups в Kafka, но проще.

Группы полезны в распределённых системах, где несколько серверов обрабатывают события параллельно, например, для уведомлений или задач.

## Создание и настройка группы

Сначала создайте группу с **XGROUP CREATE**. Укажите поток, имя группы и стартовый ID.

Пример для потока уведомлений:

```
XGROUP CREATE notifications:stream alert-group $ MKSTREAM
```

$ — начинать с конца (новые записи). MKSTREAM создаст поток, если его нет.

Теперь группа готова, и потребители могут присоединяться.

## Чтение через группу

Для чтения используйте **XREADGROUP**. Укажите группу, имя потребителя и поток.

Пример: потребитель worker1 читает 1 запись:

```
XREADGROUP GROUP alert-group worker1 COUNT 1 STREAMS notifications:stream &gt;
```

&gt; значит дать следующую непрочитанную запись. Команда вернёт запись, если она есть, или заблокируется.

После обработки подтвердите с **XACK**:

```
XACK notifications:stream alert-group 1700570000000-0
```

Это отметит запись как обработанную.

## Обработка pending записей

Если потребитель упал, неп обработанные записи попадают в pending. Другие могут их забрать с **XCLAIM**.

Пример: worker2 забирает pending от worker1:

```
XCLAIM notifications:stream alert-group worker2 60000 1700570000000-0
```

60000 — минимальное время простоя в мс.

Это обеспечивает, что записи не застрянут.

## Итог

**Consumer Groups** делают **Streams** надёжным инструментом для распределённой обработки. Они автоматически распределяют нагрузку и отслеживают статус. **Главное — использовать XACK для подтверждений, чтобы избежать потерь.**


