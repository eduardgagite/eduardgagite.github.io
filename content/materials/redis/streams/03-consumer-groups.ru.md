---
title: "Consumer Groups"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 3
---

**Consumer Groups** (группы потребителей) — это, пожалуй, главная фишка Redis Streams. Они позволяют нескольким приложениям-обработчикам совместно читать один стрим, распределяя сообщения между собой. В отличие от Pub/Sub, где все получают копию, здесь каждое сообщение достается только одному потребителю из группы.

Это идеальный сценарий для масштабирования фоновых задач: если один воркер не справляется, вы просто запускаете еще одного, и они автоматически делят поток задач.

## Чтение в группе: XREADGROUP

Для чтения в составе группы используется команда **XREADGROUP**. Она похожа на **XREAD**, но требует указать имя группы и имя потребителя (consumer name). Имя потребителя вы придумываете сами (например, **worker-1**, **pod-abc**, **thread-5**).

Синтаксис: `XREADGROUP GROUP группа потребитель STREAMS ключ ID`

Ключевой момент — специальный ID `>`. Знак "больше" означает: "дай мне новые сообщения, которые еще *никто* в моей группе не читал".

Допустим, мы создали группу **workers** (в прошлом уроке). Запустим чтение от имени **worker-1**:

```
XREADGROUP GROUP workers worker-1 COUNT 1 BLOCK 0 STREAMS events:users >
```

- **COUNT 1**: берем по одной задаче за раз.
- **BLOCK 0**: ждем бесконечно, если задач нет.
- **STREAMS ... >**: читаем абсолютно новые записи.

Когда Redis отдает сообщение потребителю, он "резервирует" его за ним. Другие воркеры в этой же группе это сообщение уже не получат.

## Подтверждение обработки: XACK

Redis Stream не удаляет сообщение сразу после прочтения. Он ждет подтверждения. Пока подтверждение не пришло, сообщение считается "в обработке" (Pending).

Это защищает от сбоев: если воркер взял задачу, но упал с ошибкой и не подтвердил выполнение, задача не потеряется. Она останется висеть за этим воркером.

После успешной обработки задачи воркер обязан выполнить **XACK**:

```
XACK events:users workers 1618590010000-0
```

Здесь мы указываем ID сообщения, которое успешно обработали. Теперь Redis знает, что с этой записью все хорошо, и убирает её из списка ожидающих.

## Pending Entries List (PEL)

Redis хранит список всех сообщений, которые были выданы потребителям, но еще не подтверждены через **XACK**. Этот список называется **PEL** (Pending Entries List).

Чтобы увидеть, какие сообщения "зависли" и кто их держит, используется команда **XPENDING**:

```
XPENDING events:users workers
```

Это вернет сводку: сколько всего неподтвержденных сообщений, минимальный и максимальный ID, и статистику по потребителям.

Если нужно увидеть конкретные ID сообщений:

```
XPENDING events:users workers - + 10
```

## Итого

Используйте **Consumer Groups** для надежного распределения задач. Читайте новые сообщения через специальный ID `>` командой **XREADGROUP**. Всегда отправляйте **XACK** после успешной обработки, чтобы Redis пометил задачу выполненной. Если **XACK** не пришел, сообщение остается в **PEL** и его можно переназначить (об этом далее).
