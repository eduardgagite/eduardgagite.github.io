---
title: "Consumer Groups"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 3
---

## Зачем нужны Consumer Groups

Один поток часто обрабатывают сразу несколько воркеров. Без координации часть задач может выполняться дважды или, наоборот, теряться при сбоях. Consumer Groups решают эту проблему: Redis сам распределяет сообщения между потребителями и отслеживает, какие из них уже подтверждены.

Это превращает Streams в надёжную очередь задач с возможностью повторной доставки и балансировки нагрузки между воркерами.

## Создание группы и первых потребителей

Группа потребителей привязывается к конкретному потоку. Обычно её создаёт отдельный сервис при инициализации:

```
XGROUP CREATE order:events order-workers 0-0 MKSTREAM
```

Здесь:

- **order:events** — поток событий заказов;
- **order-workers** — имя группы;
- 0-0 — начиная с какого сообщения группа увидит историю;
- MKSTREAM — создать поток, если его ещё нет.

Дальше каждый воркер подключается к этой группе под своим именем:

```
XREADGROUP GROUP order-workers worker-1 COUNT 10 STREAMS order:events >
XREADGROUP GROUP order-workers worker-2 COUNT 10 STREAMS order:events >
```

Redis будет по очереди раздавать новые сообщения воркерам worker-1 и worker-2, балансируя нагрузку.

## Подтверждение обработки и «висящие» сообщения

Когда воркер успешно обработал задачу, он должен подтвердить это Redis, чтобы сообщение считалось завершённым. Для этого используется команда **XACK**:

```
XACK order:events order-workers 1713788220000-0
```

Если воркер прочитал сообщение, но завис или упал до XACK, Redis пометит его как «ожидающее подтверждение». Узнать о таких сообщениях можно через **XPENDING**:

```
XPENDING order:events order-workers
```

Так администратор или отдельный сервис могут увидеть, сколько сообщений застряло и у каких потребителей.

## Повторная доставка задач

Если сообщение долго висит без подтверждения, его можно передать другому воркеру. Для этого используют команды повторного захвата сообщений, например XCLAIM или XAUTOCLAIM.

Пример повторной выдачи «застрявших» задач:

```
XAUTOCLAIM order:events order-workers worker-2 60000 0-0 COUNT 10
```

Здесь:

- сообщения, висящие без подтверждения дольше 60 секунд, будут переназначены потребителю worker-2;
- COUNT 10 ограничивает количество переотданных задач за один вызов.

Так можно строить устойчивые к сбоям очереди: если один воркер умер, его незавершённые задачи автоматически подхватят другие.

## Типичные ошибки при работе с группами

Частая ошибка — читать поток через XREAD и XREADGROUP одновременно. Так легко запутаться в подтверждениях и потерять часть логики. Для потока, который обрабатывается группой, всё чтение рабочих задач должно идти через XREADGROUP.

Вторая проблема — забывать вызывать XACK после успешной обработки. В этом случае XPENDING будет постоянно расти, а повторная доставка начнёт дублировать задачи.

## Итого

Consumer Groups добавляют к Streams важный уровень надёжности: сообщения распределяются между воркерами и не теряются при сбоях. Мы можем повторно выдать зависшие задачи и контролировать состояние очереди через XPENDING и команды повторного захвата.

Главное, что стоит запомнить: **группы потребителей превращают поток в полноценную очередь задач с балансировкой нагрузки и гарантией, что ни одно сообщение не пропадёт бесследно**.


