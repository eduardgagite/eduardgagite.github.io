---
title: "Consumer Groups"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 3
---

**Consumer Groups** в **Redis Streams** позволяют нескольким воркерам безопасно обрабатывать один и тот же поток сообщений, не дублируя работу и не теряя события. Каждый воркер входит в группу, получает свою порцию задач и подтверждает обработку, чтобы Redis мог переотдать незавершённые сообщения при сбоях.

Если смотреть на это практическими глазами, Consumer Groups — это способ построить пул воркеров поверх одного потока: сколько бы экземпляров сервиса ни работало, каждое сообщение будет обработано ровно одним из них.

## Базовая схема работы группы

Представим поток задач на обработку заказов:

```
XGROUP CREATE orders:stream orders-workers $ MKSTREAM
```

Дальше в приложении поднимаются несколько воркеров, каждый со своим именем потребителя внутри группы:

```
XREADGROUP GROUP orders-workers worker-1 COUNT 10 STREAMS orders:stream >
XREADGROUP GROUP orders-workers worker-2 COUNT 10 STREAMS orders:stream >
```

Важные детали:

- **orders-workers** — имя группы потребителей;
- **worker-1** и **worker-2** — имена конкретных потребителей (экземпляров сервиса);
- символ **>** говорит «дай мне только новые сообщения, которые ещё никому не назначены».

Redis раздаёт новые сообщения между потребителями внутри группы. Если воркеров несколько, задачи распределяются по ним, как в очереди.

## Подтверждение обработки: XACK и PEL

Когда воркер прочитал сообщение через **XREADGROUP** и успешно его обработал, он обязан подтвердить это командой **XACK**:

```
XACK orders:stream orders-workers 1698249601-0
```

Здесь:

- **orders:stream** — поток;
- **orders-workers** — группа;
- **1698249601-0** — идентификатор обработанного сообщения.

Пока подтверждения нет, сообщение считается «висящим» в специальном списке PEL (Pending Entries List). Посмотреть такие сообщения можно через **XPENDING**:

```
XPENDING orders:stream orders-workers
```

В ответ Redis покажет:

- сколько сообщений «в работе»;
- минимальный и максимальный идентификаторы;
- примеры по потребителям.

Это особенно полезно, когда один из воркеров упал и не успел подтвердить обработку. Сообщения не пропадают, их можно перераспределить.

## Повторная выдача сообщений другим воркерам

Если потребитель перестал отвечать, сообщения, которые числятся за ним в PEL, можно вручную или программно передать другому воркеру. Для этого используется команда **XCLAIM**.

Пример: за **worker-1** «зависли» сообщения, которые висят дольше 60 секунд. Мы хотим передать их **worker-2**:

Сначала смотрим, какие сообщения зависли у **worker-1**:

```
XPENDING orders:stream orders-workers - + 10 worker-1
```

Допустим, среди них есть **1698249601-0**. Тогда:

```
XCLAIM orders:stream orders-workers worker-2 60000 1698249601-0
```

Здесь:

- **worker-2** забирает себе сообщение;
- **60000** — минимальное время в миллисекундах, которое сообщение должно провести в PEL, прежде чем его можно будет «забрать».

После успешной обработки новый воркер так же делает **XACK**, и сообщение окончательно считается завершённым.

## Типичный цикл жизни сообщения в группе

Если собрать всё вместе, жизнь одной записи в **Streams** с Consumer Groups выглядит так:

1. Продюсер добавляет запись в поток через **XADD**.
2. Группа уже создана командой **XGROUP CREATE**.
3. Один из воркеров читает запись через **XREADGROUP** с маркером **>**.
4. Redis назначает сообщение этому потребителю и помещает его в PEL.
5. Воркер обрабатывает задачу и вызывает **XACK**.
6. Сообщение остаётся в потоке как часть истории, но больше не считается «висящим» в группе.

Если воркер падает между шагами 3 и 5, сообщение остаётся в PEL и может быть перераспределено через **XPENDING** и **XCLAIM**.

## Когда стоит использовать Consumer Groups

Consumer Groups особенно полезны в сценариях:

- есть поток задач, которые должны быть выполнены ровно один раз;
- нагрузка плавает, и нужно просто добавлять или убирать воркеры;
- важно не терять сообщения при падении отдельных экземпляров сервиса;
- несколько сервисов читают один и тот же поток по-разному — для этого можно создать несколько независимых групп на одном потоке.

Если же есть всего один потребитель, который читает поток линейно, можно обойтись обычным **XREAD** и собственным хранением последнего прочитанного идентификатора. Consumer Groups здесь дадут больше сложности, чем пользы.

## Итог

**Consumer Groups** превращают Redis Streams в полноценную основу для распределённых очередей: сообщения раздаются между воркерами, отслеживаются в PEL, подтверждаются и при необходимости перераспределяются.

Такой подход позволяет строить надёжные системы обработки задач без потерь и дублирования, сохраняя при этом всю историю событий в самом потоке.