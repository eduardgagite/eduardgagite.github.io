---
title: "Принципы работы"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 1
---

**Redis Streams** — это способ работать с событиями как с непрерывной лентой записей. Вместо того чтобы просто хранить значение по ключу, мы получаем упорядоченный поток сообщений, к которому можно подключаться, читать новые элементы и обрабатывать их как очередь задач или лог событий.

Главная идея проста: в поток постоянно добавляются новые события, каждое получает уникальный идентификатор и набор полей. Клиенты могут читать эти события с нужного места, не теряя порядок, и строить вокруг этого надёжную обработку.

## Поток как лог событий

У обычных структур данных в Redis мы работаем с текущим состоянием: значение ключа, содержимое списка, хеша или множества. В **Streams** мы работаем с историей изменений — каждое событие добавляется в конец потока и остаётся там, пока мы его явно не удалим или не обрежем.

Представим поток событий заказов:

```
XADD orders:stream * user_id 123 status "created" amount 1000
XADD orders:stream * user_id 456 status "paid" amount 500
XADD orders:stream * user_id 123 status "shipped" amount 1000
```

Каждый вызов **XADD** добавляет запись в конец **orders:stream** и возвращает её идентификатор вида время-последовательность, например:

```
1698249572-0
1698249573-0
1698249574-0
```

Базовая модель простая:

- поток — это упорядоченная лента событий;
- каждое событие имеет уникальный идентификатор;
- данные события — это набор полей и значений.

Такой подход удобно использовать для логов, журналов действий пользователей, бизнес-событий между сервисами.

## Структура записи в потоке

Каждое сообщение в **Streams** — это пара: идентификатор и набор полей. Полей может быть сколько угодно, главное — соблюдать разумную схему.

Типичная запись для логирования действий пользователя:

```
XADD user:activity:stream * user_id 123 action "login" ip "10.0.0.5"
XADD user:activity:stream * user_id 123 action "view_page" page "/products/42"
XADD user:activity:stream * user_id 789 action "logout" reason "timeout"
```

Здесь есть несколько важных моментов:

- ключ потока **user:activity:stream** явно говорит о назначении;
- поле **user_id** позволяет связать события с конкретным пользователем;
- поля **action**, **page**, **ip**, **reason** дают контекст для аналитики и отладки.

Когда позже мы будем читать поток, эти же поля используются для разбора сообщения и принятия решения, что с ним делать.

## Идентификаторы сообщений и порядок

Идентификатор в **Streams** обычно генерируется автоматически с помощью звёздочки:

```
XADD metrics:payments:stream * status "ok" amount 150
```

Redis подставляет текущее время и счётчик, формируя значение вида время-последовательность. Это обеспечивает строгий порядок: новые сообщения всегда идут после старых.

Идентификаторы используются:

- чтобы читать поток начиная с нужного места;
- чтобы не пропускать сообщения при повторных чтениях;
- чтобы понимать, какие события уже были обработаны.

Базовое чтение потока выглядит так:

```
XREAD COUNT 2 STREAMS orders:stream 0-0
```

Команда вернёт первые две записи из **orders:stream**, начиная с самого начала. Специальный идентификатор 0-0 означает «читать с начала потока». Если вместо него подставить последний прочитанный идентификатор, можно продолжить чтение с нужного места.

## Когда Streams подходят, а когда нет

**Streams** логичнее всего использовать там, где есть последовательность событий, которые нужно обрабатывать по порядку или раздавать нескольким потребителям:

- логирование действий пользователей;
- события от микросервисов;
- очереди задач с подтверждением обработки;
- аналитические события для последующей агрегации.

Если задача — просто хранить последнее состояние объекта, например текущий баланс или актуальный профиль пользователя, **Streams** будут излишни. В таких случаях проще и дешевле по памяти использовать строки или хеши.

Важно понимать, что поток сам по себе не очищается. Если не использовать обрезку, он будет расти бесконечно. В разделах про команды и очереди сообщений мы разберём, как управлять размером потока и не давать ему разрастаться.

## Итог

**Redis Streams** дают удобную модель лога событий: каждая запись добавляется в конец потока, получает уникальный идентификатор и остаётся доступной для чтения и повторной обработки.

Эта структура идеально подходит для задач, где важна история и порядок событий, а не только текущее состояние. Главное — сразу продумать схему ключей, поля сообщений и политику очистки, чтобы поток оставался управляемым и полезным.