---
title: "Построение очередей сообщений"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 4
---

## Streams как очередь сообщений

Redis Streams часто используют как основу для очередей задач между микросервисами. Один сервис пишет в поток события или задания, а несколько воркеров читают их и выполняют асинхронную работу: отправку писем, обработку изображений, интеграции с внешними API.

В отличие от простых списков, Streams вместе с Consumer Groups дают подтверждения, повторную доставку и возможность масштабировать количество потребителей без переписывания логики.

## Простая очередь задач на одном потоке

Базовый вариант — один поток, одна группа потребителей и несколько воркеров. Допустим, у нас есть сервис, который должен асинхронно отправлять письма пользователям. Сервис приложений пишет задания в поток **email:tasks**:

```
XADD email:tasks MAXLEN ~ 10000 * user_id 123 template welcome
XADD email:tasks MAXLEN ~ 10000 * user_id 456 template reset_password
```

Отдельный сервис создаёт группу потребителей:

```
XGROUP CREATE email:tasks email-workers 0-0 MKSTREAM
```

Каждый воркер подключается к группе и читает задачи:

```
XREADGROUP GROUP email-workers worker-1 COUNT 10 BLOCK 5000 STREAMS email:tasks >
```

После успешной отправки письма воркер подтверждает задачу:

```
XACK email:tasks email-workers 1713788220000-0
```

Так строится простая, но надёжная очередь задач на основе одного потока.

## Масштабирование воркеров

Когда задач становится больше, нам не нужно создавать новые потоки — достаточно добавить ещё потребителей в ту же группу. Redis сам начнёт раздавать новые сообщения разным воркерам.

Например, запускаем ещё два экземпляра сервиса отправки писем:

```
XREADGROUP GROUP email-workers worker-2 COUNT 10 BLOCK 5000 STREAMS email:tasks >
XREADGROUP GROUP email-workers worker-3 COUNT 10 BLOCK 5000 STREAMS email:tasks >
```

Теперь новые сообщения из потока будут распределяться между worker-1, worker-2 и worker-3. Это позволяет линейно масштабировать обработку задач, не меняя схему данных.

## Повторные попытки и отдельная очередь для «битых» задач

Не все задачи удаётся обработать с первого раза: внешний сервис недоступен, данные невалидны, таймауты. Streams позволяют делать контролируемые повторные попытки и при необходимости отправлять «битые» задачи в отдельный поток.

Простейший подход:

1. Воркер читает сообщение через XREADGROUP.
2. Пытается обработать задачу.
3. Если всё хорошо — вызывает XACK.
4. Если произошла ошибка — не подтверждает сообщение, а увеличивает счётчик попыток где‑нибудь снаружи.

Отдельный процесс следит за «висящими» сообщениями:

```
XPENDING email:tasks email-workers
```

Для сообщений, которые слишком долго без подтверждения или превысили лимит попыток, он может:

- либо вернуть задачу в работу через XAUTOCLAIM;
- либо переписать её в отдельный поток **email:dead-letter**:

```
XADD email:dead-letter * reason invalid_template original_stream email:tasks
```

Так мы не теряем проблемные задачи и можем разбирать их отдельно.

## Итого

На основе Streams и Consumer Groups в Redis можно построить полноценную очередь сообщений между сервисами. Один поток и одна группа уже дают балансировку нагрузки, подтверждения и возможность повторных попыток.

Ключевая мысль: **Streams позволяют собрать надёжную очередь задач без дополнительной инфраструктуры, опираясь только на несколько команд Redis и аккуратную обработку подтверждений**.


