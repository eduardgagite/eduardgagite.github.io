---
title: "Построение очередей сообщений"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 4
---

**Streams** в Redis идеально подходят для создания очередей сообщений. В отличие от простых списков, они поддерживают подтверждения, группы и историю, что делает очереди надёжными. Сообщения добавляются в конец, а потребители читают с нужной позиции.

Это удобно для асинхронной обработки задач, где важно не потерять сообщения и распределить их между worker'ами.

## Простая очередь без групп

Для базовой очереди используйте **XADD** для добавления и **XREAD** для чтения.

Добавляем задачу:

```
XADD tasks:queue * job_type &quot;email&quot; recipient &quot;user@example.com&quot;
```

Чтение с блокировкой (BLOCK 0 — ждать вечно):

```
XREAD BLOCK 0 STREAMS tasks:queue $
```

$ — с конца. Команда вернёт новые задачи или подождёт.

После обработки запись остаётся в потоке, но вы можете игнорировать прочитанное по ID.

## Очередь с consumer groups

Для распределения добавьте группу:

```
XGROUP CREATE tasks:queue processing-group 0
```

0 — начинать с начала.

Worker читает:

```
XREADGROUP GROUP processing-group worker1 STREAMS tasks:queue &gt;
```

После обработки:

```
XACK tasks:queue processing-group &lt;id&gt;
```

Если нужно удалить после ACK, используйте **XDEL**, но обычно историю оставляют.

## Обработка ошибок и повторных попыток

Для повторных попыток не ACK'йте сразу. Если обработка failed, оставьте в pending и заберите позже с **XCLAIM**.

Это создаёт resilient очередь без внешних библиотек.

## Итог

**Streams** позволяют строить очереди от простых до сложных с минимальным кодом. **Ключ — в подтверждениях и группах, которые обеспечивают доставку без потерь.** Используйте для задач, где порядок и надёжность критичны.


