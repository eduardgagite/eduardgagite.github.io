---
title: "Построение очередей сообщений"
category: "redis"
categoryTitle: "Redis"
section: "streams"
sectionTitle: "Redis Streams"
sectionOrder: 4
order: 4
---

Построение надежной очереди сообщений на Redis Streams требует правильной обработки сбоев. Что делать, если воркер взял задачу, начал её выполнять, но сервер внезапно перезагрузился или процесс упал с ошибкой Out Of Memory?

Без дополнительных механизмов такая задача "зависнет" навечно в статусе Pending. Она не будет доступна другим воркерам (так как уже зарезервирована), но и не будет выполнена.

## Жизненный цикл надежной очереди

Правильный алгоритм работы потребителя (воркера) выглядит так:

1. Читаем новые сообщения (`XREADGROUP ... >`).
2. Обрабатываем сообщение (отправляем письмо, ресайзим картинку и т.д.).
3. Если успешно — шлем **XACK**.
4. Если ошибка — логируем, возможно повторяем (retry), но не шлем **XACK** (или шлем в спец. очередь ошибок).

Но этого недостаточно. Нужен отдельный процесс (или периодическая задача внутри воркеров), который проверяет "потерянные" сообщения.

## Восстановление сообщений: XAUTOCLAIM

Redis предоставляет механизм для "отъема" (claim) зависших сообщений. Если сообщение висит в PEL слишком долго (дольше разумного таймаута обработки), мы считаем, что владелец умер.

Раньше использовали сложную связку `XPENDING` + `XCLAIM`. В современных версиях Redis (6.2+) есть удобная команда **XAUTOCLAIM**. Она атомарно находит старые зависшие сообщения и переназначает их на того, кто вызвал команду.

Сценарий восстановления ("сборщик мусора"):

```
XAUTOCLAIM events:users workers worker-2 60000 0-0 COUNT 1
```

- **worker-2**: имя потребителя, который заберет себе эти задачи.
- **60000**: минимальное время простоя (idle time) в миллисекундах (1 минута). Если сообщение не подтверждали больше минуты — забираем.
- **0-0**: начинаем поиск с начала PEL.

Получив такие сообщения, **worker-2** должен попробовать обработать их. Если получилось — **XACK**. Если это "ядовитое сообщение" (вызывает сбой кода), его можно после N попыток удалить (**XDEL**) или перенести в Dead Letter Queue (отдельный стрим ошибок).

## Ограничение размера очереди

Очереди имеют свойство бесконечно расти. Чтобы не забить память Redis старыми логами, всегда ограничивайте размер стрима при записи.

Лучшая практика — использовать **MAXLEN** с тильдой при добавлении:

```
XADD events:users MAXLEN ~ 10000 * ...
```

Это держит в стриме около 10 000 последних записей. Старые автоматически вытесняются. Это работает эффективно и почти бесплатно для CPU.

## Итого

Надежная очередь на Redis Streams состоит из трех компонентов:
1. **Producer**, который пишет с `MAXLEN`.
2. **Consumers**, которые читают через группу и шлют `XACK`.
3. **Recovery (Cleaner)**, который периодически делает `XAUTOCLAIM` для подбора брошенных задач.

Этот паттерн гарантирует, что ни одна задача не будет потеряна даже при жестком падении процессов-обработчиков.
