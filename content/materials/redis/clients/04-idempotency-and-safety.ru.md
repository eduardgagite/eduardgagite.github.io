---
title: "Идемпотентность и безопасные операции при повторах"
category: "redis"
categoryTitle: "Redis"
section: "clients"
sectionTitle: "Клиенты и работа из приложений"
sectionOrder: 13
order: 4
---

Когда появляются ретраи, сетевые сбои и сложная логика, легко дважды выполнить одну и ту же операцию. Если команда не идемпотентна, это приводит к удвоенным списаниям, дубликатам задач или странным состояниям в очередях.

Идемпотентность — это свойство операции давать тот же результат при повторном выполнении. В связке с Redis это можно и нужно использовать осознанно.

## Простейшие идемпотентные операции

Многие команды Redis по сути уже идемпотентны:

- SET с одним и тем же значением для ключа;
- EXPIRE и PEXPIRE с одинаковым временем;
- записи, где значение полностью определено содержимым команды.

Пример:

```
SET user:42:name "Alice"
SET user:42:name "Alice"
```

Повтор второй команды не меняет состояние. Если операция реализована именно как установка значения, а не как сложная последовательность шагов, ретраи становятся безопаснее.

## Использование SETNX и атомарных операций

Для сценариев «сделать что‑то один раз» помогают команды **SETNX** и атомарные инкременты.

Пример: один раз выполнить инициализацию для пользователя.

```
SETNX user:42:initialized 1
```

Если ключ уже существует, команда вернёт 0, и повторный вызов не изменит состояние. Аналогично, атомарные операции вроде INCR и HINCRBY гарантируют корректный результат даже при параллельных вызовах.

## Идемпотентность на уровне бизнес‑идентификаторов

Часто удобнее считать идемпотентной не отдельную команду Redis, а всю бизнес‑операцию с собственным идентификатором.

Пример: обработка платежа с идентификатором операции.

Шаги:

1. До начала логики проверить, обрабатывался ли уже этот **payment_id**.
2. Если да — просто вернуть сохранённый результат.
3. Если нет — выполнить бизнес‑логику и пометить операцию как завершённую.

Хранение статуса:

```
SETNX payment:op:12345 "processed"
```

Если SETNX вернул 1, мы считаем, что именно этот инстанс сервиса «выиграл гонку» и будет обрабатывать операцию. Остальные при повторе увидят, что статус уже есть.

## Lua-скрипты для сложных идемпотентных операций

Когда нужно сделать несколько шагов атомарно и при этом сохранить идемпотентность, выручает Lua.

Идея:

- перед выполнением основной логики проверить специальный ключ с идентификатором операции;
- если ключ уже существует — вернуть сохранённый результат или код;
- если нет — выполнить логику и записать маркер выполнения.

Простейший шаблон:

```
EVAL "
  local status = redis.call('GET', KEYS[1])
  if status then
    return status
  end
  redis.call('SET', KEYS[1], ARGV[1])
  return ARGV[1]
" 1 op:12345 "done"
```

Один и тот же скрипт можно безопасно вызывать несколько раз — результат будет предсказуемым.

## Итог

Идемпотентность в связке с **Redis** достигается за счёт простых и атомарных команд, аккуратного использования SETNX и INCR, а при необходимости — Lua‑скриптов, которые проверяют и помечают выполнение операций.

Если проектировать ключи и операции так, чтобы повторный вызов не ломал данные, можно смело использовать ретраи и не бояться случайных дубликатов и двойных списаний.


