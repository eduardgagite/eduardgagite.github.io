---
title: "Распределенные блокировки"
category: "redis"
categoryTitle: "Redis"
section: "patterns"
sectionTitle: "Паттерны и практические кейсы"
sectionOrder: 3
order: 7
---

Распределённые блокировки нужны, когда несколько процессов или серверов должны координировать доступ к общему ресурсу. Например, только один воркер должен обрабатывать задачу, только один процесс может обновлять критичные данные, или нужно предотвратить одновременное выполнение дорогой операции.

**Redis** хорошо подходит для таких блокировок, потому что операции атомарны и выполняются быстро.

## Простая блокировка через SET NX

Базовый способ получить блокировку — использовать команду **SET** с опцией **NX** (только если ключ не существует) и временем жизни.

Пример получения блокировки:

```
SET lock:task:42 "worker-1" NX EX 30
```

Что происходит:

- **lock:task:42** — имя ключа блокировки;
- **worker-1** — идентификатор того, кто получил блокировку (полезно для отладки);
- **NX** — создать ключ только если его ещё нет;
- **EX 30** — ключ автоматически удалится через 30 секунд.

Если команда вернула **OK**, блокировка получена. Если вернула пустой ответ, ключ уже существует — кто‑то другой держит блокировку.

## Освобождение блокировки

Когда работа завершена, блокировку нужно освободить. Важно удалять только свою блокировку, чтобы не снять чужую.

Проверка и удаление:

```
GET lock:task:42
```

Если значение совпадает с идентификатором текущего процесса, можно удалить:

```
DEL lock:task:42
```

Но эта схема не атомарна: между GET и DEL другой процесс может успеть взять блокировку. Безопаснее использовать Lua‑скрипт, который проверяет и удаляет за один шаг.

## Атомарное освобождение через Lua

Скрипт проверяет, что значение ключа совпадает с идентификатором, и только тогда удаляет:

```
EVAL "
  if redis.call('GET', KEYS[1]) == ARGV[1] then
    return redis.call('DEL', KEYS[1])
  else
    return 0
  end
" 1 lock:task:42 worker-1
```

Здесь:

- **KEYS[1]** — имя ключа блокировки;
- **ARGV[1]** — идентификатор процесса, который пытается освободить блокировку.

Если идентификатор совпал, ключ удаляется и возвращается 1. Если нет — возвращается 0, блокировка не снимается.

## Продление времени жизни блокировки

Иногда работа занимает больше времени, чем изначально заданный TTL. В таких случаях блокировку нужно продлить.

Продление тоже лучше делать атомарно через Lua:

```
EVAL "
  if redis.call('GET', KEYS[1]) == ARGV[1] then
    return redis.call('EXPIRE', KEYS[1], ARGV[2])
  else
    return 0
  end
" 1 lock:task:42 worker-1 60
```

Скрипт проверяет владельца и продлевает TTL только если идентификатор совпадает.

## Типичные сценарии использования

**Обработка задач воркерами.** Только один воркер должен взять задачу из очереди. Блокировка гарантирует, что задача не будет обработана дважды.

```
SET lock:process:queue:email "worker-123" NX EX 300
```

**Обновление критичных данных.** При изменении баланса или статуса заказа важно, чтобы два процесса не делали это одновременно.

```
SET lock:order:42:update "api-server-1" NX EX 10
```

**Предотвращение дублирования операций.** Дорогая операция (генерация отчёта, отправка массовой рассылки) должна выполняться только один раз.

```
SET lock:report:daily "scheduler" NX EX 3600
```

## Выбор времени жизни блокировки

TTL блокировки должен быть достаточно большим, чтобы покрыть время выполнения операции, но не слишком большим, чтобы при сбое процесса блокировка не висела часами.

Типичные значения:

- для быстрых операций — 5–30 секунд;
- для обработки задач — 1–5 минут;
- для долгих операций — 10–30 минут с возможностью продления.

Если процесс упал и не освободил блокировку, TTL автоматически удалит ключ, и другой процесс сможет взять блокировку.

## Проблемы и ограничения простой блокировки

Простая блокировка на одном Redis работает хорошо, но есть нюансы:

- если Redis упадёт, все блокировки потеряются;
- при использовании репликации возможны рассинхронизации;
- в кластере Redis нужно учитывать особенности шардирования.

Для критичных систем, где важна максимальная надёжность, используют алгоритм **Redlock**, который работает с несколькими независимыми инстансами Redis. Но для большинства практических задач простая блокировка через **SET NX EX** вполне достаточна.

## Итого

**Распределённые блокировки в Redis** строятся вокруг команды **SET NX EX**: атомарное создание ключа с временем жизни гарантирует, что только один процесс получит блокировку.

Важно правильно освобождать блокировку (лучше через Lua‑скрипт) и выбирать разумное время жизни, чтобы балансировать между защитой от зависших процессов и риском преждевременного освобождения блокировки.

