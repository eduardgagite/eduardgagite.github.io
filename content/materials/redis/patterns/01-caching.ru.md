---
title: "Кэширование"
category: "redis"
categoryTitle: "Redis"
section: "patterns"
sectionTitle: "Паттерны и практические кейсы"
sectionOrder: 3
order: 1
---

Кэширование — одна из самых частых причин использовать Redis. Идея простая: дорогой по времени или ресурсоёмкий результат один раз считается, сохраняется в Redis и потом быстро читается оттуда.

## Простой кэш для тяжёлого запроса

Представим, что есть запрос к базе данных, который занимает сотни миллисекунд. Вместо того чтобы каждый раз ходить в БД, приложение сначала проверяет Redis.

Логика на уровне приложения выглядит так:

1. Посмотреть значение в Redis по заранее известному ключу.
2. Если значение есть — вернуть его.
3. Если значения нет — взять данные из БД, положить в Redis и вернуть пользователю.

Пример работы с ключом cache:article:42:

```
GET cache:article:42
```

Если ответ пустой, приложение читает статью из базы и записывает результат с временем жизни:

```
SETEX cache:article:42 60 "{...json статьи...}"
```

Ключ живёт 60 секунд, после чего удаляется. Следующий запрос снова обратится к БД, обновит кэш и цикл продолжится.

**Плюс такого подхода:** кэш не переполнен старыми данными, потому что они автоматически истекают.

## Кэширование страниц и HTTP-ответов

Redis удобно использовать как кэш для целых страниц или фрагментов HTML.

Например, есть страница товара `/products/10`. Приложение может сформировать HTML один раз и сохранить его в Redis:

```
SETEX cache:page:/products/10 30 "<html>..." 
```

При следующем запросе к странице сначала проверяется Redis:

```
GET cache:page:/products/10
```

Если HTML найден, сервер сразу отдаёт его пользователю, не тратя время на повторную сборку страницы.

## Обновление и сброс кэша

Кэш всегда связан с исходными данными. Если данные поменялись, старый кэш становится бесполезным.

**Простой подход:** после изменения данных удалить связанный ключ.

```
DEL cache:article:42
```

Следующий запрос создаст свежий кэш через SETEX.

Иногда кэш обновляют не только при чтении, но и сразу после записи в основное хранилище: как только данные изменились, новое значение кладут в Redis, чтобы не ждать первого запроса.

## Что кэшировать имеет смысл

**Тяжёлые запросы.** То, что долго считается или часто запрашивается.

**Редко меняющиеся данные.** Справочники, популярные статьи, публичные профили.

**Результаты сложных агрегатов.** Статистика, подготовленные выборки.

Чем дороже получение данных без Redis, тем больше выигрывает кэш.

## Чего кэшировать не стоит

Данные, которые меняются каждую секунду и при этом всегда должны быть строго актуальными (например, баланс счёта в банковской системе), плохо подходят для простого кэширования. В таких случаях используют другие механизмы согласованности.

Кэширование в Redis не требует сложных схем: достаточно выбрать понятные ключи, задать разумный TTL и обновлять кэш при изменении исходных данных.
