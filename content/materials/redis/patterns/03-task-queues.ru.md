---
title: "Очереди задач"
category: "redis"
categoryTitle: "Redis"
section: "patterns"
sectionTitle: "Паттерны и практические кейсы"
sectionOrder: 3
order: 3
---


Очереди задач помогают вынести тяжёлую или долгую работу из основного потока приложения. Вместо того чтобы делать всё сразу во время HTTP-запроса, задача кладётся в очередь, а отдельный рабочий процесс (worker) забирает её и выполняет в фоне.

## Простой вариант на списках

Самый доступный вариант очереди в Redis — обычный список. Один или несколько производителей кладут задачи в список, а воркеры их забирают.

Пример: очередь писем.

Производитель кладёт задачу:

```
LPUSH queue:email "{\"to\":\"user@example.com\",\"subject\":\"Hello\"}"
```

Воркер забирает задачи с конца списка:

```
RPOP queue:email
```

Если очередь пустая, RPOP вернёт пустой результат, и воркер может подождать перед следующей попыткой.

Чтобы не опрашивать Redis в цикле, используют блокирующую команду:

```
BRPOP queue:email 5
```

Команда ждёт до 5 секунд, пока не появится новый элемент. Если за это время ничего не пришло, возвращается пустой результат, и можно повторить попытку.

**Плюсы списков:** простая модель, минимум команд, легко начать.

## Несколько очередей и приоритеты

Часто задач несколько типов: срочные и обычные. Для этого удобно завести несколько списков.

Например:

```
LPUSH queue:email:high "{...}"
LPUSH queue:email:default "{...}"
```

Воркер сначала пытается забрать задачу из приоритетной очереди, потом из обычной:

```
BRPOP queue:email:high queue:email:default 5
```

Redis сам вернёт задачу из первой непустой очереди.

## Очередь на Streams

Списки просты, но у них есть минус: если воркер забрал задачу и упал до обработки, задача потеряется. Потоки (Streams) дают более надёжную схему.

Пример очереди на Streams:

Добавление задачи:

```
XADD queue:email * to "user@example.com" subject "Hello"
```

Создание группы потребителей (делается один раз):

```
XGROUP CREATE queue:email workers $ MKSTREAM
```

Чтение задач воркером из группы:

```
XREADGROUP GROUP workers worker-1 COUNT 1 STREAMS queue:email >
```

После успешной обработки воркер подтверждает задачу:

```
XACK queue:email workers <id-записи>
```

Если воркер упал и не успел отправить XACK, запись можно забрать другим воркером из «подвисших» задач через XCLAIM или XPENDING. Так задачи не теряются.

## Что класть в задачу

Обычно в очередь кладут не весь объём данных, а только то, что нужно для повторного поиска:

**Идентификатор.** Например, **user_id**, **order_id**, **notification_id**.

**Тип действия.** Что именно нужно сделать: **send_email**, **rebuild_cache**, **generate_report**.

**Минимальные параметры.** Всё, что нельзя потом достать из основной базы.

Пример полезной структуры для задачи:

```
{
  "type": "send_email",
  "user_id": 42,
  "template": "welcome"
}
```

Воркер по этим данным берёт остальное из основной базы и выполняет нужную операцию.

## Итого

**Очереди задач на Redis** позволяют разгружать основной поток приложения и выполнять тяжёлые операции в фоне. Для простых случаев достаточно списков и команд LPUSH/BRPOP. Когда важно не терять задачи и распределять их между несколькими воркерами, удобнее использовать Streams с группами потребителей.