---
title: "Масштабирование по нагрузке"
category: "redis"
categoryTitle: "Redis"
section: "ha-cluster"
sectionTitle: "Высокая доступность и кластеризация"
sectionOrder: 8
order: 5
---

Redis хорошо масштабируется вертикально (больше памяти и CPU на одном сервере), но в какой‑то момент этого становится мало. Тогда в игру вступают репликация, Sentinel и Redis Cluster — вместе они позволяют распределять нагрузку по нескольким узлам и переживать рост трафика.

Важно понимать, какие рычаги масштабирования есть и как выбрать подходящий набор под конкретную систему.

## Масштабирование чтения: реплики

Самый простой шаг — разгрузить master, отправив часть чтений на реплики.

Пример идеи:

- все записи идут на master;
- часть чтений (например, отчёты, фоновые выборки) перенаправляется на replica.

Выбор узла на стороне приложения:

- для критичных к консистентности операций (балансы, заказы) читать только с master;
- для менее критичных (отчёты, статистика, ленты новостей) — использовать реплики.

Репликация настраивается так же, как в разделе про master–replica:

```
REPLICAOF 10.0.0.1 6379
```

Так можно постепенно добавлять новые реплики и горизонтально масштабировать чтение.

## Масштабирование записи: кластер и шардинг

Если упираемся уже не только в чтение, но и в запись, одного master становится мало. Здесь помогает Redis Cluster:

- данные распределяются по нескольким master‑узлам;
- каждый мастер обслуживает только свою часть ключей и нагрузку;
- при необходимости каждому мастер‑узлу добавляются свои реплики.

Создание кластера:

```
redis-cli --cluster create \
  10.0.0.1:6379 10.0.0.2:6379 10.0.0.3:6379 \
  --cluster-replicas 1
```

Дальше масштабирование сводится к добавлению новых шардов и перераспределению слотов. Клиенты, которые понимают Redis Cluster, автоматически разруливают маршрутизацию запросов.

## Горизонтальное масштабирование с Sentinel

Sentinel сам по себе не масштабирует Redis по данным, но помогает масштабировать по доступности:

- добавляем несколько master–replica пар для разных подсистем (кэш, сессии, очереди);
- над каждой парой работает свой набор Sentinel;
- клиенты знают только имена логических master и не привязаны к конкретным адресам.

Так можно:

- разделить нагрузку по функциям (один Redis под кэш, другой под сессии);
- независимо масштабировать каждую часть;
- при сбоях на уровне узла получать автоматический failover без даунтайма.

## Выбор стратегии под задачу

Условно можно выделить несколько стадий развития:

- один Redis‑узел с репликами для чтения — достаточно для большинства средних проектов;
- несколько master–replica пар под разные задачи — когда важно изоляция и предсказуемость;
- Redis Cluster — когда общий объём данных и нагрузка выходят за рамки одного сервера.

При этом Sentinel обычно присутствует на всех стадиях, где важна высокая доступность: он не масштабирует, но держит систему живой при отказах.

## Итог

Масштабирование по нагрузке в **Redis** строится слоями: сначала реплики для чтения, затем несколько master–replica пар под разные подсистемы и, при необходимости, Redis Cluster для горизонтального шардинга.

Если заранее продумать, какие данные где хранятся и как клиенты находят актуальный master, можно плавно наращивать инфраструктуру Redis без резких архитектурных переделок.


