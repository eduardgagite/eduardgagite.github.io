---
title: "Оценка размера ключей"
category: "redis"
categoryTitle: "Redis"
section: "memory"
sectionTitle: "Управление памятью"
sectionOrder: 5
order: 2
---

Когда данных становится много, важно понимать, сколько памяти реально занимает каждый ключ и какие структуры «съедают» больше всего. В **Redis** для этого есть отдельные инструменты: команды **MEMORY USAGE**, **MEMORY STATS** и **MEMORY DOCTOR**.

С их помощью можно найти самые тяжёлые ключи, сравнить разные варианты хранения и принять осознанное решение по оптимизации.

## MEMORY USAGE — размер одного ключа

Проще всего начать с оценки конкретного ключа. Команда **MEMORY USAGE** показывает примерный объём памяти в байтах, который занимает значение.

Пример с простым кэшем статьи:

```
SET cache:article:42 "{...json статьи...}"
MEMORY USAGE cache:article:42
```

В ответ Redis вернёт число, например:

```
(integer) 2048
```

Это не точный, но достаточно близкий к реальности размер. Полезно запускать **MEMORY USAGE** на разных типах ключей:

- строки с JSON;
- хеши с теми же данными;
- списки, множества, упорядоченные множества.

Так можно быстро увидеть, какой формат для вашей задачи дешевле по памяти.

## Поиск «тяжёлых» ключей через SCAN

Чтобы понять, какие ключи в инстансе самые крупные, можно пройтись по ним через **SCAN** и для каждого посмотреть **MEMORY USAGE**.

Например, ищем тяжёлые ключи кэша:

```
SCAN 0 MATCH cache:* COUNT 100
MEMORY USAGE cache:article:1
MEMORY USAGE cache:article:2
MEMORY USAGE cache:profile:42
```

Скрипт на стороне приложения:

- вызывает **SCAN** в цикле;
- для каждого найденного ключа делает **MEMORY USAGE**;
- сортирует по размеру и показывает топ-10–20 самых больших.

Такой подход помогает быстро найти неожиданные «пожиратели» памяти: огромные списки логов, ключи без **TTL**, слишком крупные JSON-объекты.

## MEMORY STATS и MEMORY DOCTOR

Для общей картины по памяти можно использовать:

```
MEMORY STATS
```

Команда возвращает большой набор метрик: общую использованную память, накладные расходы на структуры, настройки аллокатора, фрагментацию. Полезно сохранить этот вывод и сравнивать его до и после изменений в схеме хранения.

Если хочется быстрой подсказки от самого Redis:

```
MEMORY DOCTOR
```

Ответ будет в текстовом виде и может содержать советы уровня:

- уменьшить количество маленьких ключей;
- обратить внимание на фрагментацию;
- посмотреть на конфигурацию аллокатора.

Эти рекомендации не всегда точечные, но часто помогают заметить общие проблемы.

## Сравнение вариантов хранения на примере

Допустим, у нас есть 1000 настроек пользователей. Можно хранить их как 1000 отдельных ключей:

```
SET user:1:settings "{...}"
SET user:2:settings "{...}"
...
SET user:1000:settings "{...}"
```

А можно как один хеш:

```
HSET user:settings 1 "{...}"
HSET user:settings 2 "{...}"
...
HSET user:settings 1000 "{...}"
```

Чтобы сравнить, достаточно измерить:

```
MEMORY USAGE user:1:settings
MEMORY USAGE user:settings
```

Во многих случаях один хеш будет экономичнее, чем множество мелких ключей, за счёт меньших накладных расходов. Но лучше всегда проверять на своих данных.

## Итог

Инструменты **MEMORY USAGE**, **MEMORY STATS** и **MEMORY DOCTOR** помогают превратить оптимизацию памяти в измеряемый процесс, а не в угадывание.

Регулярная оценка размеров ключей и поиск самых тяжёлых записей позволяет вовремя заметить неэффективные структуры и переработать схему хранения до того, как Redis начнёт упираться в лимит.


