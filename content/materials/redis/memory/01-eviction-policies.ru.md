---
title: "Политики вытеснения"
category: "redis"
categoryTitle: "Redis"
section: "memory"
sectionTitle: "Управление памятью"
sectionOrder: 5
order: 1
---

**Redis** обычно держит все данные в памяти. Если её не хватает, поведение сервера зависит от настроек: он либо начнёт вытеснять старые ключи, либо просто перестанет принимать записи с ошибкой. За это отвечает связка **maxmemory** и **maxmemory-policy**.

Чтобы не получить неожиданный отказ от записи в продакшене, важно понимать, какие есть политики и в каких сценариях какую выбирать.

## Лимит памяти maxmemory

Сначала задаётся общий лимит, сколько памяти **Redis** может использовать под данные.

Посмотреть текущий лимит:

```
CONFIG GET maxmemory
```

Установить, например, 1 гигабайт:

```
CONFIG SET maxmemory 1gb
```

После достижения лимита начинает работать политика вытеснения. Если лимит не задан (0), Redis будет пытаться использовать всю доступную память процесса и операционной системы — в продакшене это почти всегда плохая идея.

Обычно лимит фиксируют на уровне, который удобно мониторить и под который рассчитан сервер.

## Основные политики вытеснения

Политику можно узнать так:

```
CONFIG GET maxmemory-policy
```

И поменять:

```
CONFIG SET maxmemory-policy allkeys-lru
```

Распространённые варианты:

- **noeviction** — новая запись при нехватке памяти завершится ошибкой. Подходит для сценариев, где нельзя терять данные и есть внешний контроль за объёмом.
- **volatile-lru** — выталкивать по принципу LRU только те ключи, у которых есть **TTL**.
- **allkeys-lru** — выталкивать по LRU любые ключи. Часто используется для кэша.
- **volatile-ttl** — удалять в первую очередь ключи с минимальным оставшимся **TTL**.
- **allkeys-random** и **volatile-random** — выбирать ключи для удаления случайно.

В новых версиях есть также варианты на основе **LFU** (частоты использования): **allkeys-lfu** и **volatile-lfu**.

## Практические сценарии выбора политики

Для чистого кэша, где данные всегда можно восстановить из основной базы, чаще всего выбирают:

```
CONFIG SET maxmemory-policy allkeys-lru
```

Сценарий: хранение ключей вида **cache:article:42**, **cache:profile:10** без строгих гарантий сохранности. Redis сам будет удалять давно неиспользуемые записи, чтобы укладываться в заданный лимит.

Если в Redis лежит не только кэш, но и важные данные, и при этом у временных ключей всегда есть **TTL**, уместен вариант:

```
CONFIG SET maxmemory-policy volatile-lru
```

Тогда при нехватке памяти будут удаляться только ключи с временем жизни, а постоянные данные останутся нетронутыми. Важно следить, чтобы все «одноразовые» и кэширующие ключи действительно имели TTL.

## Типичные ошибки при настройке

Частые проблемы:

- лимит **maxmemory** не задан, Redis занимает всю память сервера;
- выбрана политика **noeviction**, а приложение не умеет обрабатывать ошибку записи;
- политика требует **TTL**, но ключи кэша и сессий создаются без явного времени жизни;
- разные типы данных смешаны в одном инстансе Redis: и кэш, и критичные данные, и очереди.

Практичный подход — разделять назначения по разным инстансам: один Redis только под кэш с политикой **allkeys-lru**, другой — под сессии и очереди с аккуратной работой с TTL и без агрессивного вытеснения.

## Итог

Политики вытеснения в **Redis** определяют, что произойдёт, когда сервер упрётся в лимит памяти: какие ключи будут удаляться и будут ли операции записи вообще успешны.

Грамотный выбор **maxmemory** и **maxmemory-policy** под конкретный сценарий (кэш, сессии, очереди, критичные данные) помогает избежать неожиданного падения сервиса и контролировать поведение Redis под нагрузкой.


