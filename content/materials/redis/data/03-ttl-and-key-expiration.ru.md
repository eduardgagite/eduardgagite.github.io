---
title: "TTL и управление временем жизни ключей"
category: "redis"
categoryTitle: "Redis"
section: "data"
sectionTitle: "Структуры данных"
sectionOrder: 2
order: 3
---

**TTL** позволяет сделать ключи «временными». По умолчанию данные в Redis живут вечно, пока их явно не удалить. Время жизни ключа задаётся отдельно и измеряется в секундах или миллисекундах.

## Основная идея

Можно записать значение, дать ему срок жизни и не думать о ручной очистке. После истечения срока Redis удалит ключ сам. Это удобно для кэша, сессий, одноразовых кодов и временных флагов.

**Простейший пример:**

```
SET session:123 "user data"
EXPIRE session:123 60
```

Ключ session:123 будет жить 60 секунд, потом исчезнет.

**Проверка оставшегося времени:**

```
TTL session:123
```

Если ключ ещё жив, возвращается число секунд. Возможны специальные значения:
- **-1** — у ключа нет срока жизни;
- **-2** — ключ уже не существует.

## Запись сразу с временем жизни

Можно не вызывать EXPIRE отдельно, а задать срок прямо при записи.

**SETEX — запись сразу с временем жизни (в секундах):**

```
SETEX cache:user:1 300 "{\"name\":\"Alice\"}"
```

Ключ cache:user:1 будет автоматически удалён через 300 секунд.

**PSETEX — вариант с миллисекундами:**

```
PSETEX cache:page:1 1500 "html..."
```

## Снятие срока жизни

**PERSIST — сделать ключ снова постоянным:**

```
PERSIST session:123
```

После этого у ключа больше нет таймера удаления.

Важно помнить: если перезаписать значение, TTL сбрасывается. Новое значение будет без срока жизни, пока его не задать заново.

## Поведение при истечении

Redis не удаляет ключи строго в ту же миллисекунду, когда истечёт время. Он периодически проверяет истекающие ключи и дополнительно удаляет их при обращении. Для приложения это выглядит так, будто ключ просто перестал существовать:

```
GET session:123     # до истечения
# "user data"

# проходит время

GET session:123     # после истечения
# (nil)
```

## Практические случаи

**Кэш.** Хранить результат тяжёлого запроса несколько секунд или минут.

```
SETEX cache:popular:posts 60 "..."
```

**Сессии.** Хранить данные пользователя, пока он активен.

```
SET session:456 "data"
EXPIRE session:456 1800
```

**Одноразовые коды и токены.** Срок действия задаётся сразу и не требует ручной очистки.

Грамотная работа с TTL помогает не захламлять память Redis и автоматически удалять ненужные данные.

## Итого по TTL и командам

TTL делает ключи временными и позволяет не заниматься ручной очисткой. У каждого ключа может быть свой срок жизни: его можно задать при записи, изменить, снять или проверить.

Команды, которые важно знать:

- **EXPIRE key seconds** — установить время жизни в секундах.
- **PEXPIRE key milliseconds** — то же самое, но в миллисекундах.
- **EXPIREAT key timestamp** — истечение по Unix-времени в секундах.
- **PEXPIREAT key milliseconds-timestamp** — истечение по Unix-времени в миллисекундах.
- **TTL key** — показать оставшееся время жизни в секундах.
- **PTTL key** — показать оставшееся время жизни в миллисекундах.
- **SETEX key seconds value** — записать значение и сразу задать срок жизни.
- **PSETEX key milliseconds value** — вариант с миллисекундами.
- **PERSIST key** — убрать время жизни и сделать ключ постоянным.

Понимая, как работают эти команды, можно строить кэш, сессии, временные токены и любые другие механизмы, которые должны исчезать сами через заданный промежуток времени.
