---
title: "Поведение при сбоях"
category: "redis"
categoryTitle: "Redis"
section: "replication"
sectionTitle: "Репликация"
sectionOrder: 7
order: 3
---

Репликация в Redis сама по себе не даёт автоматического переключения при сбоях, но задаёт базовую модель, как система ведёт себя, когда падает master или отваливается сеть. Понимание этого поведения важно, чтобы не потерять данные и правильно строить сценарии аварийного восстановления.

Разберём типичные ситуации: отказ master, потеря связи с replica и ручной перевод роли.

## Если упал master

Когда основной узел недоступен:

- записи на него перестают работать — приложение получает ошибки подключения;
- реплики продолжают обслуживать запросы на чтение с теми данными, которые у них уже есть;
- репликация останавливается до восстановления связи.

Приложение может временно переключить чтение на реплики, но записи всё равно придётся куда‑то направлять. Без Sentinel или кластера переключение ролей происходит вручную.

Простой сценарий ручного failover:

1. Убедиться, что master действительно недоступен и не вернётся.
2. Выбрать одну из реплик как новую основную.
3. На этой реплике выполнить:

```
REPLICAOF NO ONE
```

Теперь узел станет самостоятельным master. Приложение переводит записи на этот адрес.

## Если потерялась связь с репликой

Когда сеть между master и replica рвётся:

- master продолжает работать как обычно;
- replica перестаёт получать новые данные, но всё ещё обслуживает чтение на своём старом состоянии;
- в **INFO replication** на master видно, что состояние реплики offline, а offset не растёт.

Если реплика используется для чтения, важно понимать, что данные на ней могут отставать на минуту, час или дольше, в зависимости от того, сколько длится проблема с сетью.

Когда связь восстанавливается, Redis пытается сделать частичную синхронизацию. Если это невозможно (слишком большое отставание, переполнен журнал), происходит полная ресинхронизация заново.

## Риск потери данных при принудительном переключении

В ручном failover есть важная тонкость. Если:

- master успел принять часть записей;
- эти записи ещё не долетели до replica из‑за задержки или сети;
- мы переводим replica в master;

то эти «последние» записи на старом master будут потеряны.

Поэтому:

- при возможности стоит использовать Sentinel или кластер, которые учитывают задержки и согласованность;
- в критичных системах полезно применять команду **WAIT**, чтобы убедиться, что запись дошла до нужного числа реплик:

```
SET user:42:name "Alice"
WAIT 1 1000
```

Здесь Redis вернёт, на сколько реплик запись точно дошла за 1000 миллисекунд. Это не полностью решает проблему, но даёт больше контроля.

## Автоматический failover: куда смотреть дальше

Чистая репликация решает задачу копирования данных, но не управляет ролями master и replica. Для автоматического переключения при сбоях используют:

- **Redis Sentinel** — наблюдает за узлами, голосует о недоступности master и продвигает одну из реплик;
- **Redis Cluster** — распределяет данные по шартам и имеет встроенный механизм failover.

Основные принципы остаются прежними, но логика выбора нового master и перенастройки клиентов перекладывается на инфраструктуру.

## Итог

При сбоях в репликации **Redis** ведёт себя предсказуемо: master остаётся единственной точкой записи, реплики продолжают обслуживать чтение, а переключение ролей нужно делать вручную или через Sentinel и кластер.

Если учитывать возможное отставание реплик и аккуратно подходить к ручному failover, можно избежать потери последних записей и построить надёжную схему аварийного восстановления.


