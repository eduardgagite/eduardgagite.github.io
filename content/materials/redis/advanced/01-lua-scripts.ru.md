---
title: "Lua-скрипты"
category: "redis"
categoryTitle: "Redis"
section: "advanced"
sectionTitle: "Продвинутые темы"
sectionOrder: 12
order: 1
---

Иногда одной команды Redis недостаточно: нужно сделать несколько проверок, обновить пару ключей и при этом сохранить атомарность. В таких случаях выручает встроенная поддержка **Lua-скриптов**: небольшой скрипт выполняется целиком как одна команда, без гонок между конкурентными клиентами.

Главная идея: сложная логика с несколькими шагами переносится в Redis и выполняется там, где лежат данные.

## Запуск простого Lua-скрипта

Базовая команда — **EVAL**. Внутри скрипта доступны массивы **KEYS** и **ARGV**: первые используются для имён ключей, вторые — для произвольных аргументов.

Пример: атомарно увеличить счётчик только если он меньше порога.

```
EVAL "
  local current = tonumber(redis.call('GET', KEYS[1]) or '0')
  if current >= tonumber(ARGV[1]) then
    return current
  end
  current = current + 1
  redis.call('SET', KEYS[1], current)
  return current
" 1 metrics:actions 100
```

Что происходит:

- скрипт читает значение **metrics:actions**;
- если значение достигло порога **100**, просто возвращает его;
- иначе увеличивает и сохраняет обратно;
- вся логика выполняется как одна атомарная операция.

## Использование SHA и кэширование скриптов

Каждый скрипт можно загрузить в Redis и вызывать по SHA‑хэшу. Это уменьшает накладные расходы при частом запуске.

Загрузка:

```
SCRIPT LOAD "
  return redis.call('INCRBY', KEYS[1], tonumber(ARGV[1]))
"
```

Redis вернёт SHA скрипта, например:

```
"f2b3c0..."
```

Вызов по SHA:

```
EVALSHA f2b3c0... 1 metrics:views 10
```

Если скрипт уже загружен, Redis сразу выполнит его, минуя повторный разбор текста.

## Ограничения и практические рекомендации

Важно помнить:

- скрипты выполняются в одном потоке и блокируют выполнение других команд до завершения;
- нельзя вызывать команды, которые требуют пользовательского ввода или делают блокировки;
- скрипты должны быть быстрыми и предусказуемыми по времени выполнения.

Практичные советы:

- выносить в Lua только логику, где критична атомарность и несколько шагов;
- не загонять в скрипт огромные циклы по тысячам ключей;
- держать код скриптов в репозитории, а не писать случайный текст прямо в консоли.

## Итог

**Lua-скрипты** позволяют реализовывать сложные атомарные операции прямо в Redis, без гонок и дополнительных сетевых запросов.

Если использовать их точечно — для проверки и обновления нескольких ключей за один шаг — можно заметно упростить код приложения и повысить надёжность критичных операций.


