---
title: "Транзакции и мультикоманды"
category: "redis"
categoryTitle: "Redis"
section: "advanced"
sectionTitle: "Продвинутые темы"
sectionOrder: 12
order: 2
---

В **Redis** нет привычных транзакций с изоляцией и откатом, как в классических СУБД, но есть механизм **MULTI/EXEC** и оптимистичные блокировки через **WATCH**. Вместе они позволяют группировать несколько команд в одну «мультикоманду» и атомарно применять изменения, если никто не успел вмешаться.

Важно понимать, что транзакции в Redis — это скорее последовательное выполнение команд без прерывания, чем полноценная ACID‑модель.

## MULTI/EXEC — группировка команд

Базовый паттерн:

1. Открываем транзакцию командой **MULTI**.
2. Отправляем несколько команд — они не выполняются сразу, а попадают в очередь.
3. Фиксируем изменения через **EXEC**.

Пример: инкремент двух счётчиков как одной операции.

```
MULTI
INCR metrics:views
INCR metrics:clicks
EXEC
```

Здесь:

- обе команды попадут в очередь;
- при EXEC Redis выполнит их последовательно, без вмешательства других клиентов между ними;
- отката при ошибке одной команды нет — ответственность на приложении.

## WATCH — оптимистичная блокировка

Если важно убедиться, что данные не менялись между чтением и записью, используют **WATCH**. Он помечает один или несколько ключей как наблюдаемые; если какой‑то из них изменится до EXEC, транзакция не выполнится.

Пример: безопасное списание баланса.

```
WATCH user:42:balance
GET user:42:balance
MULTI
DECRBY user:42:balance 100
EXEC
```

Сценарий:

- после WATCH и GET приложение решает, достаточно ли средств;
- если в это время другой клиент изменит **user:42:balance**, EXEC вернёт nil — транзакция не применится;
- приложение может повторить попытку или сообщить об ошибке.

Такой подход называют оптимистичной блокировкой: нет тяжёлых лочков, но есть проверка на конкурентные изменения.

## Пайплайны против транзакций

Важно не путать:

- транзакции (**MULTI/EXEC**) — про атомарность группы команд;
- пайплайны — про уменьшение сетевых задержек за счёт отправки нескольких команд одним пакетом.

Многие клиентские библиотеки позволяют отправлять пачку команд без ожидания ответов по очереди. Это ускоряет работу, но не даёт никаких гарантий атомарности.

Комбинировать подходы можно: внутри пайплайна использовать MULTI/EXEC, если нужна и скорость, и атомарность.

## Итог

Транзакции в **Redis** через **MULTI/EXEC** и **WATCH** помогают группировать команды и защищаться от гонок при конкурентных изменениях.

Если правильно использовать оптимистичные блокировки и помнить об отсутствии автоматического отката, можно реализовать надёжные сценарии обновления нескольких ключей без излишнего усложнения архитектуры.


